<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Wobujiaoxyy3">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Wobujiaoxyy3">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Wobujiaoxyy3</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wobujiaoxyy3</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/09/recblog-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/09/recblog-3/" class="post-title-link" itemprop="url">recblog-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-09 23:05:06" itemprop="dateCreated datePublished" datetime="2025-05-09T23:05:06+08:00">2025-05-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/09/recblog-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/09/recblog-2/" class="post-title-link" itemprop="url">recblog-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-09 23:04:37" itemprop="dateCreated datePublished" datetime="2025-05-09T23:04:37+08:00">2025-05-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/27/solana-simple-socialfi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/27/solana-simple-socialfi/" class="post-title-link" itemprop="url">Solana小项目：简易SocialFi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-27 22:36:50" itemprop="dateCreated datePublished" datetime="2024-11-27T22:36:50+08:00">2024-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-01 01:06:26" itemprop="dateModified" datetime="2024-12-01T01:06:26+08:00">2024-12-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简易socialfi">简易SocialFi</h1>
<p>在这里，我们需要完成一个简易的SocialFi项目，其中包含以下功能： -
初始化用户 - 关注用户 - 取消关注 - 查询关注列表 - 发帖 - 查询帖子</p>
<p>将功能转化为需要实现的指令： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">SocialInstruction</span> &#123;</span><br><span class="line">    InitializeUser&#123;seed_type: <span class="type">String</span>&#125;,</span><br><span class="line">    FollowUser&#123;user_to_follow: Pubkey&#125;,</span><br><span class="line">    UnfollowUser&#123;user_to_unfollow: Pubkey&#125;,</span><br><span class="line">    QueryFollows,</span><br><span class="line">    PostContent&#123;content: <span class="type">String</span>&#125;,</span><br><span class="line">    QueryPosts,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="具体实现">具体实现</h2>
<p>接下来，让我们在<code>processor.rs</code>中具体实现每一个指令对应的操作，首先，导入相应的包并定义主函数：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br><span class="line"><span class="keyword">use</span> solana_program::&#123;</span><br><span class="line">    account_info::&#123;next_account_info, AccountInfo&#125;, address_lookup_table::&#123;instruction, state::ProgramState&#125;, borsh1::try_from_slice_unchecked, entrypoint::ProgramResult, lamports, msg, program::&#123;invoke, invoke_signed&#125;, program_error::ProgramError, pubkey::Pubkey, system_instruction, system_program, sysvar::&#123;rent::Rent, Sysvar&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> spl_associated_token_account::tools::account;</span><br><span class="line"><span class="keyword">use</span> crate::instruction::*;</span><br><span class="line"><span class="keyword">use</span> crate::state::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一些常量</span></span><br><span class="line"><span class="keyword">const</span> PUBKEY_SIZE: <span class="type">usize</span> = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">const</span> U16_SIZE: <span class="type">usize</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> USER_PROFILE_SIZE: <span class="type">usize</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> MAX_FOLLOWER_COUNT: <span class="type">usize</span> = <span class="number">200</span>;  <span class="comment">//最大关注者数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> USER_POST_SIZE: <span class="type">usize</span> = <span class="number">8</span>;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Processor</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    <span class="comment">//定义主函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">process_instruction</span>(</span><br><span class="line">        program_id: &amp;Pubkey,</span><br><span class="line">        accounts: &amp;[AccountInfo],</span><br><span class="line">        instruction_data: &amp;[<span class="type">u8</span>],</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">        <span class="comment">//解序列化指令</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">instruction</span> = SocialInstruction::<span class="title function_ invoke__">try_from_slice</span>(instruction_data)?;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配传入的指令</span></span><br><span class="line">        <span class="keyword">match</span> instruction &#123;</span><br><span class="line">            SocialInstruction::InitializeUser &#123; seed_type &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">Self</span>::<span class="title function_ invoke__">initialize_user</span>(program_id, accounts, seed_type)</span><br><span class="line">            &#125;</span><br><span class="line">            SocialInstruction::FollowUser &#123; user_to_follow &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">Self</span>::<span class="title function_ invoke__">follow_user</span>(accounts, user_to_follow)</span><br><span class="line">            &#125;</span><br><span class="line">            SocialInstruction::QueryFollows =&gt; &#123;</span><br><span class="line">                <span class="keyword">Self</span>::<span class="title function_ invoke__">query_follows</span>(accounts)</span><br><span class="line">            &#125;</span><br><span class="line">            SocialInstruction::UnfollowUser &#123; user_to_unfollow &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">Self</span>::<span class="title function_ invoke__">unfollow_user</span>(accounts, user_to_unfollow)</span><br><span class="line">            &#125;</span><br><span class="line">            SocialInstruction::PostContent &#123; content &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">Self</span>::<span class="title function_ invoke__">post_content</span>(program_id, accounts, content)</span><br><span class="line">            &#125;</span><br><span class="line">            SocialInstruction::QueryPosts =&gt; &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> (下面写的比较随意，见谅)</p>
<h3 id="state.rs和一些简单函数">state.rs和一些简单函数</h3>
<p>在实现简易SocialFi的过程中，我们需要一些特定的账户来为我们存储一些数据：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> solana_program::pubkey::Pubkey;</span><br><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> data_len: <span class="type">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span> follows: <span class="type">Vec</span>&lt;Pubkey&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UserPost</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> post_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> timestamp: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            data_len: <span class="number">0</span>,</span><br><span class="line">            follows: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">follow</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, user_to_follow: Pubkey) &#123;</span><br><span class="line">        <span class="keyword">self</span>.follows.<span class="title function_ invoke__">push</span>(user_to_follow);</span><br><span class="line">        <span class="keyword">self</span>.data_len = <span class="keyword">self</span>.follows.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">u16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unfollow</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, user_to_unfollow: Pubkey) &#123;</span><br><span class="line">        <span class="keyword">self</span>.follows.<span class="title function_ invoke__">retain</span>(|&amp;x| x != user_to_unfollow);</span><br><span class="line">        <span class="keyword">self</span>.data_len = <span class="keyword">self</span>.follows.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">u16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">UserPost</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            post_count: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_post</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.post_count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_count</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.post_count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(content: <span class="type">String</span>, timestamp: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            content,</span><br><span class="line">            timestamp,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 同时，我们还需要一些定义一些简单的函数： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义计算账户占用空间的函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">compute_profile_space</span>(pubkey_count: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> USER_PROFILE_SIZE + pubkey_count * PUBKEY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义将字节转化为u16的函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">bytes_to_u16</span>(bytes: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u16</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> bytes.<span class="title function_ invoke__">len</span>() != <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>; <span class="comment">//确保输入是2个字节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array</span> = [<span class="number">0u8</span>; <span class="number">2</span>];</span><br><span class="line">    array.<span class="title function_ invoke__">copy_from_slice</span>(bytes);</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">u16</span>::<span class="title function_ invoke__">from_le_bytes</span>(array))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="initializeuser">InitializeUser</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义initialize_user方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">initialize_user</span>(program_id: &amp;Pubkey, accounts: &amp;[AccountInfo], seed_type: <span class="type">String</span>) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="comment">//获取账户信息</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配传入的seed以创建不同的账户</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">seed</span> = <span class="keyword">match</span> seed_type.<span class="title function_ invoke__">as_str</span>() &#123;</span><br><span class="line">        <span class="string">&quot;profile&quot;</span> =&gt; <span class="string">&quot;profile&quot;</span>, </span><br><span class="line">        <span class="string">&quot;post&quot;</span> =&gt; <span class="string">&quot;post&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ProgramError::InvalidArgument),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;seed: &#123;:?&#125;&quot;</span>, seed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用find_program_address方法，生成PDA账户（bump_seed用于防止生成账户重复）</span></span><br><span class="line">    <span class="keyword">let</span> (pda, bump_seed) = Pubkey::<span class="title function_ invoke__">find_program_address</span>(&amp;[user_account.key.<span class="title function_ invoke__">as_ref</span>(), seed.<span class="title function_ invoke__">as_bytes</span>()], program_id);</span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;pda: &#123;:?&#125;&quot;</span>, pda);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证传入的PDA账户是否与程序中生成的匹配，如果一致，则说明传入的PDA账户正确,否则报错</span></span><br><span class="line">    <span class="keyword">if</span> pda != pda_account.key.<span class="title function_ invoke__">clone</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="title function_ invoke__">Err</span>(ProgramError::InvalidArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前区块链的租金参数（rent是sysvar中的参数）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rent</span>= Rent::<span class="title function_ invoke__">get</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算该账户所需的存储空间大小</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">space</span> = <span class="keyword">match</span> seed_type.<span class="title function_ invoke__">as_str</span>() &#123;</span><br><span class="line">        <span class="string">&quot;profile&quot;</span> =&gt; <span class="title function_ invoke__">compute_profile_space</span>(MAX_FOLLOWER_COUNT),</span><br><span class="line">        <span class="string">&quot;post&quot;</span> =&gt; USER_POST_SIZE, </span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ProgramError::InvalidArgument),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据账户所需的存储空间，计算创建账户的最低租金金额</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lamports</span> = rent.<span class="title function_ invoke__">minimum_balance</span>(space);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建create_account_ix指令</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">create_account_ix</span> = system_instruction::<span class="title function_ invoke__">create_account</span>(</span><br><span class="line">        user_account.key,</span><br><span class="line">        &amp;pda,</span><br><span class="line">        lamports,</span><br><span class="line">        space <span class="keyword">as</span> <span class="type">u64</span>,</span><br><span class="line">        program_id</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用invoke调用函数</span></span><br><span class="line">    <span class="title function_ invoke__">invoke_signed</span>(</span><br><span class="line">        &amp;create_account_ix,</span><br><span class="line">        &amp;[</span><br><span class="line">            user_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            pda_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        ],</span><br><span class="line">        &amp;[&amp;[user_account.key.<span class="title function_ invoke__">as_ref</span>(), seed.<span class="title function_ invoke__">as_bytes</span>(), &amp;[bump_seed]]],     <span class="comment">//需要签名</span></span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续匹配传入的seed以决定对user_profile账户或user_post账户进行初始化</span></span><br><span class="line">     <span class="keyword">match</span> seed_type.<span class="title function_ invoke__">as_str</span>() &#123;</span><br><span class="line">        <span class="string">&quot;profile&quot;</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">user_profile</span> = UserProfile::<span class="title function_ invoke__">new</span>();  <span class="comment">//初始化UserProfile</span></span><br><span class="line">            user_profile.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> *pda_account.<span class="title function_ invoke__">try_borrow_mut_data</span>()?)?;  <span class="comment">//通过serialize方法将UserProfile传入PDA账户中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;post&quot;</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">user_post</span> = UserPost::<span class="title function_ invoke__">new</span>();    <span class="comment">//初始化UserPost</span></span><br><span class="line">            user_post.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> *pda_account.<span class="title function_ invoke__">try_borrow_mut_data</span>()?)?; <span class="comment">//通过serialize方法将UserPost传入PDA账户中</span></span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ProgramError::InvalidArgument),</span><br><span class="line">    &#125;;</span><br><span class="line">    msg!(<span class="string">&quot;User init success&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="followuser">FollowUser</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义follow_user方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">follow_user</span>(accounts: &amp;[AccountInfo], user_to_follow: Pubkey) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算size</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">size</span>: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = &amp;pda_account.data.<span class="title function_ invoke__">borrow</span>();  <span class="comment">//提取存储在PDA账户中data的内容</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = &amp;data[..U16_SIZE];    <span class="comment">//提取UserProfile结构体中的data_len字段（前两个字节）</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pubkey_count</span> = <span class="title function_ invoke__">bytes_to_u16</span>(len).<span class="title function_ invoke__">unwrap</span>();  <span class="comment">//将data_len字段从字节转换为u16类型，获取该PDA账户关注的数量</span></span><br><span class="line">        size = <span class="title function_ invoke__">compute_profile_space</span>(pubkey_count <span class="keyword">as</span> <span class="type">usize</span>);    <span class="comment">//通过关注的数量计算该PDA账户所需的存储字节数</span></span><br><span class="line">        msg!(<span class="string">&quot;size is &#123;:?&#125;&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user_profile</span> = UserProfile::<span class="title function_ invoke__">try_from_slice</span>(&amp;pda_account.data.<span class="title function_ invoke__">borrow</span>()[..size])?;    <span class="comment">//通过之前计算的存储字节数提取链上PDA账户的UserProfile（需要精确计算存储字节数，否则会报错）</span></span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;user_profile is &#123;:?&#125;&quot;</span>, user_profile);</span><br><span class="line"></span><br><span class="line">    user_profile.<span class="title function_ invoke__">follow</span>(user_to_follow);    <span class="comment">//通过一个follow方法对UserProfile进行更新，添加关注者</span></span><br><span class="line"></span><br><span class="line">    user_profile.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> *pda_account.<span class="title function_ invoke__">try_borrow_mut_data</span>()?)?;  <span class="comment">//将更新好的UserProfile重新导入到链上PDA账户的data中</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="queryfollow">QueryFollow</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义query_follows方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">query_follows</span>(accounts: &amp;[AccountInfo]) <span class="punctuation">-&gt;</span> ProgramResult&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一种比较简便的方法，从PDA账户的data中读取UserProfile</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_profile</span> = try_from_slice_unchecked::&lt;UserProfile&gt;(&amp;pda_account.data.<span class="title function_ invoke__">borrow</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取好UserProfile并打印出来</span></span><br><span class="line">    msg!(<span class="string">&quot;user_profile is &#123;:?&#125;&quot;</span>, user_profile);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unfollowuser">UnfollowUser</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义unfollow_user方法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unfollow_user</span>(accounts: &amp;[AccountInfo], user_to_unfollow: Pubkey) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不计算size会报错</span></span><br><span class="line">    <span class="comment">//let mut user_profile = UserProfile::try_from_slice(&amp;pda_account.data.borrow())?;</span></span><br><span class="line"></span><br><span class="line">    user_profile.<span class="title function_ invoke__">unfollow</span>(user_to_unfollow);</span><br><span class="line"></span><br><span class="line">    user_profile.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> *pda_account.<span class="title function_ invoke__">try_borrow_mut_data</span>()?)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="postcontent">PostContent</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义post_content方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">post_content</span>(program_id: &amp;Pubkey, accounts: &amp;[AccountInfo], content: <span class="type">String</span>) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post_pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前时间戳</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">clock</span> = Clock::<span class="title function_ invoke__">get</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">timestamp</span> = clock.unix_timestamp <span class="keyword">as</span> <span class="type">u64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取链上账户中的UserPost数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user_post</span> = try_from_slice_unchecked::&lt;UserPost&gt;(&amp;pda_account.data.<span class="title function_ invoke__">borrow</span>())?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等同于id增长</span></span><br><span class="line">    user_post.<span class="title function_ invoke__">add_post</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一种将数据写到链上账户的方法</span></span><br><span class="line">    user_post.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> &amp;<span class="keyword">mut</span> pda_account.data.<span class="title function_ invoke__">borrow_mut</span>())?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最新的post_count</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = user_post.<span class="title function_ invoke__">get_count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成一个新的pda账户，用于存放Post</span></span><br><span class="line">    <span class="keyword">let</span> (pda, bump_seed) = Pubkey::<span class="title function_ invoke__">find_program_address</span>(</span><br><span class="line">        &amp;[</span><br><span class="line">            user_account.key.<span class="title function_ invoke__">as_ref</span>(),</span><br><span class="line">            <span class="string">&quot;post&quot;</span>.<span class="title function_ invoke__">as_bytes</span>(),</span><br><span class="line">            &amp;[count <span class="keyword">as</span> <span class="type">u8</span>],</span><br><span class="line">        ],</span><br><span class="line">        program_id,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据内容和时间戳创建新的post</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post</span> = Post::<span class="title function_ invoke__">new</span>(content, timestamp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rent</span> = Rent::<span class="title function_ invoke__">get</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">space</span> = borsh::<span class="title function_ invoke__">to_vec</span>(&amp;post).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lamports</span> = rent.<span class="title function_ invoke__">minimum_balance</span>(space);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成新账户的指令</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">create_account_ix</span> = &amp;system_instruction::<span class="title function_ invoke__">create_account</span>(</span><br><span class="line">        user_account.key,</span><br><span class="line">        &amp;post_pda_account,</span><br><span class="line">        lamports, </span><br><span class="line">        space <span class="keyword">as</span> <span class="type">u64</span>,</span><br><span class="line">        program_id,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用invoke执行命令</span></span><br><span class="line">    <span class="title function_ invoke__">invoke_signed</span>(</span><br><span class="line">        create_account_ix,</span><br><span class="line">        &amp;[</span><br><span class="line">            user_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            post_pda_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            system_program.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">        ],</span><br><span class="line">        &amp;[&amp;[</span><br><span class="line">            user_account.key.<span class="title function_ invoke__">as_ref</span>(),</span><br><span class="line">            <span class="string">&quot;post&quot;</span>.<span class="title function_ invoke__">as_bytes</span>(),</span><br><span class="line">            &amp;[count <span class="keyword">as</span> <span class="type">u8</span>],</span><br><span class="line">            &amp;[bump_seed],</span><br><span class="line">        ]]</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新的post内容写入新建的post_pda账户中</span></span><br><span class="line">    post.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> *post_pda_account.<span class="title function_ invoke__">try_borrow_mut_data</span>()?)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="querypost">QueryPost</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询帖子</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">query_posts</span>(accounts: &amp;[AccountInfo]) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">accounts_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post_pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_post</span> = try_from_slice_unchecked::&lt;UserPost&gt;(&amp;pda_account.data.<span class="title function_ invoke__">borrow</span>())?;</span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;user_post: &#123;:?&#125;&quot;</span>, user_post);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post</span> = try_from_slice_unchecked::&lt;Post&gt;(&amp;post_pda_account.data.<span class="title function_ invoke__">borrow</span>())?;</span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;post: &#123;:?&#125;, at &#123;:?&#125;&quot;</span>, post.content, post.timestamp); </span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/23/solana-SPL-token/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/23/solana-SPL-token/" class="post-title-link" itemprop="url">Solana小项目：SPL-token合约创建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-23 10:09:34" itemprop="dateCreated datePublished" datetime="2024-11-23T10:09:34+08:00">2024-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-01 01:06:37" itemprop="dateModified" datetime="2024-12-01T01:06:37+08:00">2024-12-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="spl-token合约">SPL-Token合约</h1>
<p>为了更加了解如何使用Rust在Solana上部署合约并使用合约，我们完成了一个SPL-token的合约练习，该合约包含了两个内容：
- CreateToken创建代币 - Mint铸造代币</p>
<h2 id="项目文件的基本结构">项目文件的基本结构</h2>
<p>我们首先使用<code>cargo new --lib token</code>来创建该项目，此时该项目的<code>src</code>文件夹下只有<code>lib.rs</code>文件。此时，我们需要在继续创建如下文件：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--lib.rs (创建时就有)</span><br><span class="line">--processor.rs</span><br><span class="line">--instruction.rs</span><br><span class="line">--state.rs</span><br><span class="line">--error.rs</span><br></pre></td></tr></table></figure> 其中： -
<code>lib.rs</code>是项目的入口文件，定义程序的主要逻辑模块。 -
<code>processor.rs</code>通过定义<code>process()</code>函数，实现程序的核心逻辑处理。
- <code>instruction.rs</code>用于定义程序可以处理的指令类型。 -
<code>state.rs</code>用于定义程序中持久化的账户数据结构和逻辑。 -
<code>error.rs</code>用于自定义程序中的错误类型。</p>
<h2 id="导入基本依赖">导入基本依赖</h2>
<p>在开始写代码前，我们还需要使用<code>cargo add</code>命令来导入该项目所需的依赖：<code>solana-program</code>、<code>spl-associated-token-account</code>、<code>spl-token</code>。最后，<code>Cargo.toml</code>文件的内容如下所示：
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = <span class="string">&quot;token&quot;</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">edition = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">borsh = <span class="string">&quot;1.5.1&quot;</span></span><br><span class="line">solana-program = <span class="string">&quot;=2.0.10&quot;</span></span><br><span class="line">spl-associated-token-account = &#123;version = <span class="string">&quot;5.0.1&quot;</span>, features = [<span class="string">&quot;no-entrypoint&quot;</span>]&#125;</span><br><span class="line">spl-token = &#123;version = <span class="string">&quot;6.0.0&quot;</span>, features = [<span class="string">&quot;no-entrypoint&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">[lib]</span><br><span class="line">crate-type = [<span class="string">&quot;cdylib&quot;</span>, <span class="string">&quot;lib&quot;</span>]</span><br><span class="line"></span><br><span class="line">[features]</span><br><span class="line">no-entrypoint = []</span><br></pre></td></tr></table></figure>
在上面的代码中，我们为<code>spl-associated-token-account</code>和<code>spl-token</code>赋予了<code>no-entrypoint</code>的特征。这是因为，使用<code>Rust</code>开发<code>Solana</code>程序时，<code>entrypoint</code>是程序的主要入口点，用于接收外部传入的指令和参数。在默认情况下，<code>Solana</code>的框架会期望程序有一个入口点，以便处理事务请求。然而，有些模块（例如<code>spl-associated-token-account</code>或<code>spl-token</code>）并不是一个独立的程序，而是为其他程序提供功能的库，因此它们不需要一个默认的入口点。</p>
<p>正因为此，我们需要为<code>spl-associated-token-account</code>和<code>spl-token</code>赋予了<code>no-entrypoint</code>的特征，用于禁用这些依赖的默认入口点，避免不必要的代码运行。</p>
<p>同时，我们添加了<code>cdylib</code>，这是一种用于生成动态库的目标类型，它是为了与外部的非Rust代码交互设计的。Solana可以使用动态库来部署程序，使其运行在链上。</p>
<h2 id="着手写代码">着手写代码</h2>
<p>在理清了一个Solana项目的基本结构后，我们就可以开始着手写代码了。首先，让我们看一下<code>lib.rs</code>的基本架构：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入需要的库</span></span><br><span class="line"><span class="keyword">use</span> solana_program::&#123;</span><br><span class="line">    entrypoint,</span><br><span class="line">    entrypoint::ProgramResult,</span><br><span class="line">    pubkey::Pubkey,</span><br><span class="line">    account_info::AccountInfo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> spl_token::state::Account;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//导入processor.rs 、 instruction.rs</span></span><br><span class="line"><span class="keyword">mod</span> processor; </span><br><span class="line"><span class="keyword">mod</span> instruction;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入Processor类型</span></span><br><span class="line"><span class="keyword">use</span> crate::processor::Processor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义程序的入口点为process_instruction</span></span><br><span class="line">entrypoint!(process_instruction);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义程序的入口函数，符合solana的标准接口</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_instruction</span>(</span><br><span class="line">    program_id: &amp;Pubkey,    <span class="comment">//当前程序的公钥</span></span><br><span class="line">    accounts: &amp;[AccountInfo],   <span class="comment">//调用指令时传递的账户信息数组</span></span><br><span class="line">    instruction_data: &amp;[<span class="type">u8</span>],    <span class="comment">//调用时的输入数据（指令和参数）</span></span><br><span class="line">) <span class="punctuation">-&gt;</span> ProgramResult &#123;    <span class="comment">//返回ProgramResult， 表示程序的执行结果</span></span><br><span class="line">    Processor::<span class="title function_ invoke__">process</span>(program_id, accounts, instruction_data)  <span class="comment">//调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面<code>lib.rs</code>的代码是Solana程序的标准框架。首先，我们引入了一堆需要的库。</p>
<p>其次，使用了<code>mod processor</code>和<code>mod instruction</code>分别声明了<code>processor</code>模块和<code>instruction</code>模块，分别用于负责核心逻辑的实现和定义与程序交互的指令。之后使用<code>use crate::processor::Processor;</code>引入<code>Processor</code>类型，这是在<code>processor</code>模块中定义的核心逻辑处理器。它通常包含一个静态方法<code>process</code>，用于根据传入的指令数据解析并调用对应的逻辑。</p>
<p>随后，使用<code>entrypoint!()</code>宏用于定义程序的入口点为<code>process_instruction</code>。当Solana程序在链上运行时，会从该入口点开始执行，传入<code>program_id</code>、<code>accounts</code>、<code>instruction_data</code>参数。</p>
<p>最后，定义程序的入口函数<code>process_instruction</code>:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">process_instruction</span>(</span><br><span class="line">    program_id: &amp;Pubkey,</span><br><span class="line">    accounts: &amp;[AccountInfo],</span><br><span class="line">    instruction_data: &amp;[<span class="type">u8</span>],</span><br><span class="line">) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    Processor::<span class="title function_ invoke__">process</span>(program_id, accounts, instruction_data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
它需要传入三个参数：第一个是当前智能合约的地址；第二个是调用指令时所需要传递的账户信息；第三个是具体的指令和参数。该函数返回一个ProgramResult结果，表示程序的执行结果。该函数内部调用了另一个函数:<code>Processor::process(program_id, accounts, instruction_data)</code>，这个函数具体执行了指令，是整个智能合约的关键。</p>
<h2 id="指令instruction">指令Instruction</h2>
<p>在具体深入<code>Processor::process</code>前，让我们先看看这个合约需要实现的指令：
- CreateToken创建代币 - Mint铸造代币</p>
<p>我们将其写进<code>instruction.rs</code>中： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">TokenInstruction</span> &#123;</span><br><span class="line">    CreateToken&#123;decimals: <span class="type">u8</span>&#125;,</span><br><span class="line">    Mint&#123;amount: <span class="type">u64</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面，我们定义了一个<code>TokenInstruction</code>枚举来存储我们的两个指令。该<code>TokenInstruction</code>枚举实现了<code>BorshDeserialize</code>和<code>BorshSerialize</code>。这是因为在区块链中，所有数据（包括指令）都以字节流<code>byte stream</code>的形式在节点之间传输。因此指令需要实现序列化，以将指令转化为字节流，以便在区块链上传播；同时需要实现反序列化，将字节流还原为程序可以识别和操作的结构化数据。</p>
<h2 id="processor">Processor</h2>
<p><code>processor.rs</code>中具体实现了<code>process</code>函数，首先导入了必要的库：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> solana_program::&#123;</span><br><span class="line">    account_info::&#123;next_account_info, AccountInfo&#125;, address_lookup_table::instruction, entrypoint::ProgramResult, msg, program::&#123;invoke, invoke_signed&#125;, pubkey::Pubkey, system_instruction, sysvar::&#123;rent::Rent, Sysvar&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> spl_associated_token_account::instruction::create_associated_token_account;</span><br><span class="line"><span class="keyword">use</span> spl_token::&#123;instruction::&#123;initialize_mint, mint_to&#125;, state::Mint&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::instruction::TokenInstruction;</span><br><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其次，定义了一个空的结构体<code>Processor</code>，用于封装<code>process</code>函数：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Processor</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">process</span>(</span><br><span class="line">        program_id: &amp;Pubkey,</span><br><span class="line">        accounts: &amp;[AccountInfo],</span><br><span class="line">        instruction_data: &amp;[<span class="type">u8</span>],</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">instruction</span> = TokenInstruction::<span class="title function_ invoke__">try_from_slice</span>(instruction_data)?;</span><br><span class="line">        <span class="keyword">match</span> instruction &#123;</span><br><span class="line">            TokenInstruction::CreateToken &#123; decimals &#125; =&gt; <span class="keyword">Self</span>::<span class="title function_ invoke__">create_token</span>(accounts, decimals),</span><br><span class="line">            TokenInstruction::Mint &#123; amount &#125; =&gt; <span class="keyword">Self</span>::<span class="title function_ invoke__">mint_token</span>(accounts, amount),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的<code>process</code>函数中，首先使用了<code>try_from_slice</code>方法将<code>instruction_data</code>解序列化为实际的指令，随后对指令进行模式匹配，对不同的指令执行不同的操作。接下来，我们需要针对两个不同的指令：<code>CreateToken</code>和<code>Mint</code>，构建不同的函数以实现指令。</p>
<h3 id="creattoken">CreatToken</h3>
<p>让我们先针对<code>CreateToken</code>指令实现<code>create_token</code>函数：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">create_token</span>(accounts: &amp;[AccountInfo], decimals: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> ProgramResult &#123;&#125;</span><br></pre></td></tr></table></figure>
首先，该函数接收必须的账号信息<code>accounts</code>和需要创建的token的精度<code>decimal</code>两个参数，并返回一个<code>ProgramResult</code>结果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;   </span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_authority</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rent_sysvar</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br></pre></td></tr></table></figure>
<p>随后，将传入的账号信息数组转化为迭代器，并依次提取出程序所需的账户信息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg!(<span class="string">&quot;Creating mint account...&quot;</span>);</span><br><span class="line">msg!(<span class="string">&quot;Mint account is &#123;&#125;&quot;</span>, mint_account.key);</span><br></pre></td></tr></table></figure>
<p>打印日志，表明正在创建代币的Mint账户。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">create_account_ix</span> = &amp;system_instruction::<span class="title function_ invoke__">create_account</span>(</span><br><span class="line">    payer.key,</span><br><span class="line">    mint_account.key,</span><br><span class="line">    (Rent::<span class="title function_ invoke__">get</span>()?).<span class="title function_ invoke__">minimum_balance</span>(<span class="number">82</span>),</span><br><span class="line">    <span class="number">82</span>,</span><br><span class="line">    token_program.key,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">invoke</span>(</span><br><span class="line">    create_account_ix,</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在这之后，调用了<code>system_instrucion::create_account</code>方法，创建一个<code>create_account_ix</code>指令，该指令是solana系统指令中的创建账户指令。随后，使用<code>invoke()</code>调用该指令（传入必要的账户信息），实现了创建账户这一个操作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">mint_init_ix</span> = <span class="title function_ invoke__">initialize_mint</span>(</span><br><span class="line">    token_program.key,</span><br><span class="line">    mint_account.key,</span><br><span class="line">    mint_authority.key,</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    decimals,</span><br><span class="line">)?;</span><br><span class="line"></span><br><span class="line">msg!(<span class="string">&quot;initialize_mint account...&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">invoke_signed</span>(</span><br><span class="line">    &amp;mint_init_ix,</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        rent_sysvar.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        mint_authority.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ],</span><br><span class="line">    &amp;[],</span><br><span class="line">)?;</span><br></pre></td></tr></table></figure>
<p>之后，我们又调用了<code>system_instrucion::initialize_mint</code>方法，创建一个<code>mint_init_ix</code>指令，该指令是solana系统指令中的初始化Mint账户指令。随后，使用<code>invoke()</code>调用该指令（传入必要的账户信息），将我们刚刚创建的账户初始化为一个Mint账户。<code>Mint Account</code>是一种代币的根账户，控制该代币的生成、销毁和管理。每种代币对应一个<code>Mint Account</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg!(<span class="string">&quot;SPL Token Mint create success&quot;</span>);</span><br><span class="line">         </span><br><span class="line"><span class="title function_ invoke__">Ok</span>(()) </span><br></pre></td></tr></table></figure>
<p>最后，打印日志<code>SPL Token Mint create success</code>表明成功创建了一个SPL
Token Mint account，并返回<code>Ok(())</code>。</p>
<h3 id="mint">Mint</h3>
<p>在成功创建完了一个Mint账户之后，让我们来构建<code>mint_token</code>函数来Mint一定数量的代币到指定的账户中：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mint_token</span>(accounts: &amp;[AccountInfo], amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> ProgramResult &#123;&#125;</span><br></pre></td></tr></table></figure>
该函数需要我们传入相关账户信息以及需要mint的代币数量，并返回一个<code>ProgramResult</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">associated_token_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rent_sysvar</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">associated_token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"></span><br><span class="line">msg!(<span class="string">&quot;ATA is &#123;:?&#125;&quot;</span>, associated_token_account);</span><br></pre></td></tr></table></figure>
<p>同上一个函数一样，从传入的账户信息中匹配相对应的账户地址，并打印日志。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> associated_token_account.<span class="title function_ invoke__">lamports</span>() == <span class="number">0</span> &#123;</span><br><span class="line">    msg!(<span class="string">&quot;Creating associated token account ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">create_ata_ix</span> = &amp;spl_associated_token_account::instruction::<span class="title function_ invoke__">create_associated_token_account</span>(</span><br><span class="line">        payer.key, </span><br><span class="line">        payer.key, </span><br><span class="line">        mint_account.key, </span><br><span class="line">        token_program.key,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">invoke</span>(</span><br><span class="line">        create_ata_ix,</span><br><span class="line">        &amp;[</span><br><span class="line">            payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            associated_token_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            rent_sysvar.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            associated_token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        ]</span><br><span class="line">    )?;</span><br></pre></td></tr></table></figure>
<p>首先，确认传入的地址中是否存在余额，如果没有余额，则表明该账户尚未被创建过，可以继续进行下面的操作将其初始化为一个ata账户。接下来，创建一个<code>create_associated_token_account</code>的指令，并使用<code>invoke()</code>函数调用它，生成一个ata账户。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">mint_ix</span> = &amp;<span class="title function_ invoke__">mint_to</span>(</span><br><span class="line">    token_program.key,</span><br><span class="line">    mint_account.key,</span><br><span class="line">    associated_token_account.key,</span><br><span class="line">    payer.key,</span><br><span class="line">    &amp;[payer.key],</span><br><span class="line">    amount</span><br><span class="line">)?;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">invoke</span>(</span><br><span class="line">    mint_ix,</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        associated_token_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">msg!(<span class="string">&quot;Tokens minted to ata&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>之后，再创建一个<code>mint_to</code>指令，表示需要将一定数量的代币mint出来并转账至给定的ata账户中，并使用<code>invoke()</code>函数调用它，完成该指令。</p>
<p>至此，我们就成功构建了两个指令的具体操作函数，完成了这一份智能合约。</p>
<h2 id="cli调用">CLI调用</h2>
<p>接下来，我们构建一个cli来调用我们刚刚创建好的SPL-Token智能合约:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br><span class="line"><span class="keyword">use</span> solana_client::rpc_client::&#123;<span class="keyword">self</span>, RpcClient&#125;;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::account::Account;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::address_lookup_table::instruction;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::instruction::&#123;AccountMeta, Instruction&#125;;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::signature::read_keypair_file;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::pubkey::Pubkey;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::signer::keypair::Keypair;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::transaction::Transaction;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::signer::Signer;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::sysvar;</span><br><span class="line"><span class="keyword">use</span> spl_associated_token_account_client::address::get_associated_token_address;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">TokenInstruction</span> &#123;</span><br><span class="line">    CreateToken&#123;decimals: <span class="type">u8</span>&#125;,</span><br><span class="line">    Mint&#123;amount: <span class="type">u64</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 首先我们导入必要的库，以及需要调用的指令。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_fn</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rpc_client</span> = RpcClient::<span class="title function_ invoke__">new</span>(<span class="string">&quot;http://127.0.0.1:8899&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">read_keypair_file</span>(<span class="string">&quot;/Users/wbjxyy/.config/solana/id.json&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">program_id</span> = Pubkey::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;6SorUwdvqsn2LUsZp7zKHiQSVkWydBpStBgGyn7MBBwD&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mint_account</span> = Keypair::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;mint_account is : &#123;&#125;&quot;</span>, mint_account.<span class="title function_ invoke__">pubkey</span>().<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    _ = <span class="title function_ invoke__">create_token</span>(&amp;rpc_client, &amp;program_id, &amp;payer, &amp;mint_account, &amp;payer.<span class="title function_ invoke__">pubkey</span>(), <span class="number">6</span>);</span><br><span class="line">    _ = <span class="title function_ invoke__">mint</span>(&amp;rpc_client, &amp;program_id, &amp;payer, &amp;mint_account, <span class="number">100_000_000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后我们构建一个测试函数： -
首先，使用<code>RpcClient</code>方法，创建了一个连接到本地Solana节点的客户端（<code>http://127.0.0.1:8899</code>是本地Solana节点的RPC地址，默认端口为8899），该方法返回了一个<code>RpcClient</code>对象，后续可以使用该对象调用链上方法。
-
其次，我们使用<code>read_keypair_file</code>方法从文件中读取出一个密钥对(<code>KeyPair</code>)，作为交易签名者，并支付相应的交易费用。
-
这之后，通过<code>Pubkey::from_str</code>读取我们先前就部署好的SPL-Token合约。
-
再通过<code>Keypair::new()</code>创建一个全新的账户，用于后续将其初始化为Mint账户
-
最后，分别调用<code>create_token</code>和<code>mint</code>两个函数（不是合约里的两个）。</p>
<h3
id="cli中的create_token函数">CLI中的<code>create_token</code>函数</h3>
<p>之后，我们再创建一个<code>create_token</code>函数，用于模仿在实际操作中调用SPL-Token合约中的<code>CreateToken</code>指令：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">create_token</span>(</span><br><span class="line">    rpc_client: &amp;RpcClient,</span><br><span class="line">    program_id: &amp;Pubkey,</span><br><span class="line">    payer: &amp;Keypair,</span><br><span class="line">    mint_account: &amp;Keypair, </span><br><span class="line">    mint_authority: &amp;Pubkey,    <span class="comment">//铸造权限地址，这个地址有权铸造代币</span></span><br><span class="line">    decimals: <span class="type">u8</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
首先，该函数接收如上六个参数，其中一个是<code>&amp;RpcClient</code>客户端，一个是<code>decimals</code>代表Token的精度，剩下四个均是账户信息，对应合约中需要传入的<code>&amp;[AccountInfo]</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">instruction_data</span> = borsh::<span class="title function_ invoke__">to_vec</span>(&amp;TokenInstruction::CreateToken &#123; decimals &#125;).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>
<p>先指定要调用的指令为<code>CreateToken</code>并将其序列化。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new</span>(mint_account.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(*mint_authority, <span class="literal">false</span>),</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(payer.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">false</span>),</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(sysvar::rent::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(solana_sdk::system_program::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_token::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>将传入该函数的账户信息参数转化为合约中<code>create_token</code>函数所需的账户信息参数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">token_instruction</span> = Instruction&#123;</span><br><span class="line">    program_id: *program_id,</span><br><span class="line">    accounts,</span><br><span class="line">    data: instruction_data,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将需要调用的合约地址，对应的账户信息以及指令打包成一个指令。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">latest_blockhash</span> = rpc_client.<span class="title function_ invoke__">get_latest_blockhash</span>()?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">tx</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">    &amp;[token_instruction],</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>()),      <span class="comment">//交易费用支付者的公钥</span></span><br><span class="line">    &amp;[payer, mint_account],     <span class="comment">//用于签署交易的签名者数组</span></span><br><span class="line">    latest_blockhash</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>获取最新的blockhash, 并创建一个包含上面指令的交易。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送交易并等待确认</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = rpc_client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;tx)?;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;create token successfully&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">Ok</span>(())</span><br></pre></td></tr></table></figure>
<p>发送交易并等待确认。</p>
<h3 id="cli中的mint函数">CLI中的<code>mint</code>函数</h3>
<p><code>mint</code>函数的逻辑与<code>create_token</code>函数基本一致，这里只展示代码，不再过多赘述：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mint</span>(</span><br><span class="line">    rpc_client: &amp;RpcClient,</span><br><span class="line">    program_id: &amp;Pubkey,</span><br><span class="line">    payer: &amp;Keypair,</span><br><span class="line">    mint_account: &amp;Keypair, </span><br><span class="line">    amount: <span class="type">u64</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据payer的公钥和mint_account的公钥创建一个ata账户</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ata</span> = <span class="title function_ invoke__">get_associated_token_address</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>(), &amp;mint_account.<span class="title function_ invoke__">pubkey</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ata is &#123;&#125;&quot;</span>, ata.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">instruction_data</span> = borsh::<span class="title function_ invoke__">to_vec</span>(&amp;TokenInstruction::Mint &#123; amount &#125;).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">accounts</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new</span>(mint_account.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new</span>(ata, <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(sysvar::rent::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new</span>(payer.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(solana_sdk::system_program::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_token::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_associated_token_account::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line"></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">token_instruction</span> = Instruction&#123;</span><br><span class="line">        program_id: *program_id,</span><br><span class="line">        accounts,</span><br><span class="line">        data: instruction_data,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">latest_blockhash</span> = rpc_client.<span class="title function_ invoke__">get_latest_blockhash</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">        &amp;[token_instruction],</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>()),</span><br><span class="line">        &amp;[payer, mint_account],</span><br><span class="line">        latest_blockhash</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送交易并等待确认</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = rpc_client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;tx)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;mint token successfully&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/02/rust-concurrency2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/02/rust-concurrency2/" class="post-title-link" itemprop="url">Rust进阶-并发2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-02 12:36:24" itemprop="dateCreated datePublished" datetime="2024-11-02T12:36:24+08:00">2024-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:43:16" itemprop="dateModified" datetime="2024-11-14T07:43:16+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="共享内存">共享内存</h1>
<p>在上一节课中，我们学习了消息传递并发模型，消息传递并发模型通过通道（channel）在多个线程之间传递消息，从而实现并发。而实际上我们还可以通过<strong>共享内存</strong>的方式来实现并发。</p>
<p>在通过通道进行通信时，我们实际上是在通过消息传递的方式进行通信，这种方式类似于<strong>所有权</strong>，一旦我们将值的所有权转移至Channel中，我们就无法再使用该值。而共享内存并发则类似于多所有权，多个线程可以同时读写同一块内存。</p>
<h2 id="互斥锁-mutex">互斥锁 Mutex</h2>
<p>互斥锁<code>Mutex</code>是Rust标准库提供的用于共享内存的并发原语。它是<code>multipule exlusion</code>的缩写，意为<strong>多线程互斥</strong>。<code>Mutex</code>让多个线程并发的访问同一个值变成了排队访问：同一时间，只允许一个线程<code>A</code>访问该值，其他线程<code>B</code>则需要等待线程<code>A</code>访问结束。</p>
<p>如果想要访问数据： -
线程<code>A</code>需要先获取<code>Mutex</code>的锁(<code>lock</code>)，只有获取到锁，才能访问数据。
-
lock数据结构是<code>Mutex</code>的一部分，它能跟踪谁对数据拥有独占访问权
- <code>mutex</code>通常被描述为：通过锁定系统来保护它所持有的数据</p>
<h2 id="mutex-的两条规则">Mutex 的两条规则</h2>
<ul>
<li>在使用数据之前，必须尝试获取锁（<code>lock</code>）</li>
<li>在使用完<code>mutex</code>所保护的数据后，必须释放锁（<code>unlock</code>），以便其他的线程可以获取锁</li>
</ul>
<h2 id="使用-mutex">使用 Mutex</h2>
<h3 id="单线程中使用mutex">单线程中使用Mutex</h3>
<p>让我们通过一个例子来看看单线程中如何使用<code>Mutex</code>：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个Mutex智能指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// lock返回的是Result类型</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">// 离开作用域时，自动释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;&#125;&quot;</span>, m);  <span class="comment">// 打印结果为：m = Mutex &#123; data: 6 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码示例中，我们使用<code>Mutex::new(5)</code>创建了一个<code>Mutex</code>智能指针，并将其初始值设置为5。接着，我们使用了<code>m.lock()</code>方法来为<code>m</code>申请一个<strong>锁</strong>，并将其赋值给<code>num</code>。该方法会阻塞当前线程，直到获取到锁。因此当多个线程同时访问该数据时，只有一个线程能获取到锁，其它线程只能阻塞着等待，这样就保证了数据能被安全的修改！</p>
<p><code>m.lock()</code>方法也有可能返回一个错误，例如当前正在持有锁的线程<code>panic</code>了。在这种情况下，其它线程不可能再获得锁，因此<code>lock</code>方法会返回一个错误。</p>
<p>实际上，<code>lock</code>方法返回的是一个<code>MutexGuard</code>类型的智能指针，它实现了<code>Deref</code>特征，因此我们可以像解引用一个常规的指针一样，直接访问<code>Mutex</code>中的数据。同时，它还实现了<code>Drop</code>特征，当<code>MutexGuard</code>离开作用域时，会自动释放锁，因此不需要我们手动调用<code>unlock</code>方法。</p>
<h3 id="多线程中使用-mutex">多线程中使用 Mutex</h3>
<p>让我们先来看下面一个例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个Mutex智能指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建10个线程，每个线程将计数器加1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的的代码中，我们试图创建一个被<code>Mutex</code>保护的计数器，并创建了10个线程，每个线程将计数器加<code>1</code>。最后，打印出计数器的值。但很遗憾的是，这段代码并不能正常工作。原因在于<code>counter</code>变量已经被<code>move</code>移动到了线程中，主线程无法再访问该变量。</p>
<p>那么，我们之前学过<code>Rc&lt;T&gt;</code>智能指针，它允许我们在多个地方共享所有权。那么，我们是否可以用<code>Rc&lt;Mutex&lt;T&gt;&gt;</code>来解决这个问题呢？
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 通过`Rc`实现`Mutex`的多所有权</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="comment">// 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有子线程完成</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终的计数结果</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里，由于子线程需要通过<code>move</code>拿走锁的所有权，因此我们需要使用多所有权来保证每个线程都拿到数据的独立所有权，从而避免主线程无法访问<code>counter</code>变量。但是，遗憾又来了，当我们运行该程序时，会报错：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">                // `Rc`无法在线程中安全的传输</span><br><span class="line">   --&gt; src/main.rs:11:22</span><br><span class="line">    |</span><br><span class="line">13  |           let handle = thread::spawn(move || &#123;</span><br><span class="line">    |  ______________________^^^^^^^^^^^^^_-</span><br><span class="line">    | |                      |</span><br><span class="line">    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">14  | |             let mut num = counter.lock().unwrap();</span><br><span class="line">15  | |</span><br><span class="line">16  | |             *num += 1;</span><br><span class="line">17  | |         &#125;);</span><br><span class="line">    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`</span><br><span class="line">    |</span><br><span class="line">    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`</span><br><span class="line">     // `Rc`没有实现`Send`特征</span><br><span class="line">    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`</span><br></pre></td></tr></table></figure>
上面的错误信息告诉我们，<code>Rc</code>没有实现<code>Send</code>特征，因此无法在线程间安全的传输。这听起来有点难理解，<code>Rc</code>不是线程安全的吗？单线程中，<code>Rc</code>确实可以安全的进行使用，但是当<code>Rc</code>被用在多线程中时，就会变得不安全。原因在于<code>Rc</code>本身是不可变的，它无法自动更新引用计数，因此当多个线程同时修改引用计数时，就会导致数据不一致的问题。想象一下，如果一个线程正在修改引用计数，而另一个线程正在读取引用计数，那么就会导致数据不一致的问题。</p>
<h4 id="多线程安全的arct">多线程安全的<code>Arc&lt;T&gt;</code></h4>
<p><code>Arc&lt;T&gt;</code>是<code>Rc&lt;T&gt;</code>的多线程版本，它通过<code>Atomic</code>原子操作实现了线程安全的引用计数。因此，我们可以使用<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>来替代<code>Rc&lt;Mutex&lt;T&gt;&gt;</code>，从而解决多线程中<code>Mutex</code>的问题。值得注意的是，<code>Arc</code>与<code>Rc</code>的API基本一致，因此我们可以直接将<code>Rc</code>替换为<code>Arc</code>。</p>
<p>那么就引出了一个问题，为什么所有的基础类型都不是原子的，为什么标准库类型不默认使用<code>Arc</code>呢？原因在于实现原子性需要额外的性能开销。</p>
<p>接下来，让我们使用<code>Arc&lt;T&gt;</code>来实现多线程中<code>Mutex</code>的访问：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 以上代码可以顺利运行，打印结果为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result: 10</span><br></pre></td></tr></table></figure></p>
<h3
id="rctrefcellt-versus-arctmutext"><code>Rc&lt;T&gt;</code>/<code>RefCell&lt;T&gt;</code>
Versus <code>Arc&lt;T&gt;</code>/<code>Mutex&lt;T&gt;</code></h3>
<ul>
<li><code>Mutex&lt;T&gt;</code>也提供了内部可变性，和<code>RefCell&lt;T&gt;</code>类似，但是<code>Mutex&lt;T&gt;</code>需要在访问数据之前先获取锁，因此性能上不如<code>RefCell&lt;T&gt;</code>。</li>
<li>我们使用<code>RefCell&lt;T&gt;</code>来改变<code>Rc&lt;T&gt;</code>里面的内容。</li>
<li>我们使用<code>Mutex&lt;T&gt;</code>来改变<code>Arc&lt;T&gt;</code>里面的内容。</li>
<li><code>Mutex&lt;T&gt;</code>有死锁的风险。</li>
</ul>
<h2 id="send和sync特征"><code>Send</code>和<code>Sync</code>特征</h2>
<ul>
<li><code>Send</code>特征：允许在线程间安全的传输数据</li>
<li><code>Sync</code>特征：允许在线程间安全的共享数据</li>
</ul>
<p>Rust语言中，所有基本类型都实现了<code>Send</code>和<code>Sync</code>特征，因此它们在线程间可以安全的传输和共享。但是，这并不是Rust语言本身的特性，而是来自标准库。</p>
<h3
id="send允许在线程间安全的转移所有权">Send：允许在线程间安全的转移所有权</h3>
<p><code>Send</code>特征允许在线程间安全的转移所有权。如果一个类型实现了<code>Send</code>特征，那么它就可以被安全的移动到另一个线程中。Rust中几乎所有的类型都实现了<code>Send</code>特征，除了<code>Rc&lt;T&gt;</code>。</p>
<p>任何完全由<code>Send</code>类型组成的类型也是<code>Send</code>类型。
除了原始指针（<code>*T</code>）之外，所有指针都实现了<code>Send</code>特征。</p>
<h3
id="sync允许在线程间安全的共享数据">Sync：允许在线程间安全的共享数据</h3>
<p><code>Sync</code>特征允许在线程间安全的共享数据，也即多线程访问。如果一个类型实现了<code>Sync</code>特征，那么它就可以安全的被多个线程引用。也就是说：
-
如果<code>T</code>实现了<code>Sync</code>，那么<code>&amp;T</code>就是<code>Send</code>。
- 所有<code>Send</code>类型都实现了<code>Sync</code>。 -
基础类型都实现了<code>Sync</code>，因此任何完全由<code>Sync</code>类型组成的类型也实现了<code>Sync</code>。
-
<code>Rc&lt;T&gt;</code>没有实现<code>Sync</code>，<code>RefCell&lt;T&gt;</code>和<code>Cell&lt;T&gt;</code>也没有实现<code>Sync</code>。
-
而<code>Mutex&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>都实现了<code>Sync</code>。</p>
<h2 id="课后作业">课后作业</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务描述</span></span><br><span class="line"><span class="comment">// 你需要缩写一个简单的多线程任务调度器，它能够接收多个任务，并将这些任务分发到多个工作线程中执行。调度器使用 Channel 进行任务的分发和结果的收集。你需要使用 Rust 的 Send 和 Sync 特性来确保任务调度器在多线程环境中的安全性。</span></span><br><span class="line"><span class="comment">// 具体要求</span></span><br><span class="line"><span class="comment">// 任务结构：</span></span><br><span class="line"><span class="comment">// 定义一个 Task 结构体，表示需要执行的任务。任务包含一个唯一的 id 和一个用于执行的闭包。</span></span><br><span class="line"><span class="comment">// 调度器结构：</span></span><br><span class="line"><span class="comment">// 创建一个 Scheduler 结构体，包含一个任务队列和一个线程池。调度器应当使用 channel 来分发任务到不同的工作线程。</span></span><br><span class="line"><span class="comment">// 功能实现：</span></span><br><span class="line"><span class="comment">// 调度器应当具有以下功能:</span></span><br><span class="line"><span class="comment">// 添加任务：向调度器添加一个任务。</span></span><br><span class="line"><span class="comment">// 启动调度器：启动多个线程，开始从任务队列中获取任务并执行。</span></span><br><span class="line"><span class="comment">// 获取结果：在所有任务完成后，收集并打印每个任务的执行结果。</span></span><br><span class="line"><span class="comment">// 多线程安全：</span></span><br><span class="line"><span class="comment">// 通过使用 Arc 和 Mutex 确保任务队列在多个线程之间的安全访问。</span></span><br><span class="line"><span class="comment">// 确保任务的结果能够正确地在线程之间传递和收集。</span></span><br><span class="line"><span class="comment">// 问题提示：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列：</span></span><br><span class="line"><span class="comment">// 使用 Mutex 来保护任务队列，确保多个线程不会同时修改队列中的数据。</span></span><br><span class="line"><span class="comment">// 使用 Arc 来共享任务队列的所有权，使得多个线程能够访问同一个任务队列。</span></span><br><span class="line"><span class="comment">// 任务分发：</span></span><br><span class="line"><span class="comment">// 使用 channel 来将任务的完成状态发送回主线程，从而可以在主线程中收集和打印任务完成的结果。</span></span><br><span class="line"><span class="comment">// 线程池：</span></span><br><span class="line"><span class="comment">// 通过循环创建多个工作线程，每个线程从任务队列中取出任务并执行。线程池的大小可以通过 Scheduler 的构造函数来指定</span></span><br><span class="line"><span class="comment">// 任务执行：</span></span><br><span class="line"><span class="comment">// 每个任务都应该是一个闭包，使用 Box&lt;dyn FnOnce()&gt;将其存储在 Task 结构体中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;mpsc, Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    task_id: <span class="type">usize</span>,</span><br><span class="line">    job: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;,    <span class="comment">// 任务闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>&lt;F&gt;(task_id: <span class="type">usize</span>, job: F) <span class="punctuation">-&gt;</span> Task </span><br><span class="line">    <span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        Task &#123;</span><br><span class="line">            task_id,</span><br><span class="line">            job: <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(job),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">    tasks: Arc&lt;Mutex&lt;VecDeque&lt;Task&gt;&gt;&gt;,    <span class="comment">// 任务队列，VecDeque是双端队列</span></span><br><span class="line">    num_workers: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(num_workers: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Scheduler &#123;</span><br><span class="line">            tasks: Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(VecDeque::<span class="title function_ invoke__">new</span>())),</span><br><span class="line">            num_workers,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_task</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, task_id: <span class="type">usize</span>, job: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tasks</span> = <span class="keyword">self</span>.tasks.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        tasks.<span class="title function_ invoke__">push_back</span>(Task::<span class="title function_ invoke__">new</span>(task_id, job));   <span class="comment">// 将任务添加到任务队列的末尾</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">activate</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">worker_id</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="keyword">self</span>.num_workers &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tasks</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.tasks);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tx</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">            thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">task_opt</span> = &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tasks</span> = tasks.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    tasks.<span class="title function_ invoke__">pop_front</span>()</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = task_opt &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; is executing task &#123;&#125;&quot;</span>, worker_id, task.task_id);</span><br><span class="line">                    (task.job)();</span><br><span class="line">                    tx.<span class="title function_ invoke__">send</span>(task.task_id).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(task_id) = rx.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Task &#123;&#125; completed&quot;</span>, task_id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;All tasks are completed.&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建调度器，指定线程池大小为 4</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scheduler</span> = Scheduler::<span class="title function_ invoke__">new</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到调度器</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        scheduler.<span class="title function_ invoke__">add_task</span>(i, <span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Executing task &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>)); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动调度器，开始执行任务</span></span><br><span class="line">    scheduler.<span class="title function_ invoke__">activate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;All tasks have been processed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/02/rust-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/02/rust-concurrency/" class="post-title-link" itemprop="url">二十五、Rust进阶-并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-02 01:03:11" itemprop="dateCreated datePublished" datetime="2024-11-02T01:03:11+08:00">2024-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:43:02" itemprop="dateModified" datetime="2024-11-14T07:43:02+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="并发-concurrency">并发 Concurrency</h1>
<p>安全和高效的处理并发是Rust语言的主要目标之一。随着现代处理器的核心数不断增加，并发和并行已经成为日常编程不可或缺的一部分，甚至于Go语言已经将并发简化到一个<code>go</code>关键字就可以。</p>
<p>可惜的是，在Rust中由于语言设计理念、安全、性能的多方面考虑，并没有采用Go语言大道至简的方式，而是选择了多线程与<code>async/await</code>相结合，优点是可控性更强、性能更高，缺点是复杂度并不低，当然这也是系统级语言的应有选择：使用复杂度换取可控性和性能。</p>
<h2 id="并发与并行">并发与并行</h2>
<p>并发（Concurrency）和并行（Parallelism）是两个非常相似的概念，虽然我们平时统称并发与并行为并发，但它们之间存在一些细微的差别。</p>
<p>并发是指系统能够同时处理多个任务的能力，这些任务可能处于不同的状态，但它们共享同一个处理器。并发通常涉及任务的切换和调度，使得多个任务虽然在时间上交替执行，但是看起来就像是同时运行的。</p>
<p>并行则是指系统能够同时执行多个任务的能力，这些任务在不同的处理器上运行，每个任务都占用一个独立的处理器。并行通常涉及任务的分配和执行，使得多个任务看起来是同时运行的。</p>
<h2 id="进程与线程">进程与线程</h2>
<p>在大多数的操作系统OS中，代码运行在进程（process）中，OS同时管理里面的多个进程。</p>
<p>在我们的程序中，各独立部分可以同时运行，运行这些独立部分的就是线程（thread）。</p>
<h3 id="多线程运行">多线程运行</h3>
<p>多线程运行可以提升程序的性能表现，但是也会增加复杂度，无法保障各线程的执行顺序，同时带来安全问题：</p>
<ul>
<li>竞态条件（Race
Condition）：多个线程以非一致性的顺序同时访问数据资源，导致数据不一致。</li>
<li>死锁（Deadlock）：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。</li>
<li>活锁（Livelock）：多个线程不断尝试解决冲突，但始终无法成功，导致所有线程都无法继续执行。</li>
<li>一些因为多线程导致的很隐晦的BUG，难以复现并解决。</li>
</ul>
<h2 id="实现线程的方式">实现线程的方式</h2>
<p>不同语言对于线程的实现大相径庭： -
由于操作系统提供了创建线程的API，因此部分语言会直接调用该 API
来创建线程，因此最终程序内的线程数和该程序占用的操作系统线程数相等，一般称之为<strong>1:1线程模型</strong>，例如
Rust。这种设计的优点是运行时（runtime）较小。
-还有些语言在内部实现了自己的线程模型（绿色线程、协程），程序内部的 M
个线程最后会以某种映射方式使用 N
个操作系统线程去运行，因此称之为<strong>M:N线程模型</strong>，其中 M 和
N 并没有特定的彼此限制关系。一个典型的代表就是 Go
语言。这种设计则需要较大的运行时。 -还有些语言使用了 Actor
模型，基于消息传递进行并发，例如 Erlang 语言。</p>
<h2 id="在rust中创建线程">在Rust中创建线程</h2>
<p>在Rust中，我们可以使用<code>thread::spawn</code>函数来创建线程：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123; <span class="comment">// 子线程，主线程结束时，子线程也会结束</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123; <span class="comment">// 主线程，在i=4时，主线程结束</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 有几点值得注意：</p>
<ul>
<li>线程内部的代码使用闭包来执行。</li>
<li><code>main</code>线程一旦结束，程序就立刻结束，因此需要保持它的存活，直到其它子线程完成自己的任务。在上面的代码中，主线程在<code>i=4</code>时，子线程还在运行，因此会输出<code>hi number 5 from the spawned thread!</code>，但是之后主线程结束，子线程也会结束。</li>
<li><code>thread::sleep</code>会让当前线程休眠指定的时间，随后其它线程会被调度运行，因此就算你的电脑只有一个
CPU 核心，该程序也会表现的如同多 CPU 核心一般，这就是并发！</li>
</ul>
<p>让我们来看一下输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 4 from the main thread!</span><br><span class="line">hi number 5 from the spawned thread!</span><br></pre></td></tr></table></figure>
如果多运行几次，你会发现好像每次输出会不太一样，因为：虽说线程往往是轮流执行的，但是这一点无法被保证！线程调度的方式往往取决于你使用的操作系统。总之，<strong>千万不要依赖线程的执行顺序</strong>。</p>
<h3 id="等待子线程结束">等待子线程结束</h3>
<p>在上面的代码中，我们发现了一个问题，就是当主线程结束时，子线程也将随之立刻结束。那如果我们想要让上面的子线程从1顺序打印到9，该怎么做呢？</p>
<p>此时我们可以通过<code>join</code>方法来等待子线程结束。<code>thread::spawn</code>的返回值是一个<code>JoinHandle</code>，它是一个智能指针，可以让我们等待线程的结束。<code>JoinHandle</code>持有值的所有权，调用其<code>join</code>方法时，会阻塞当前线程，直到对应的线程结束。</p>
<p><code>join</code>方法：调用<code>handle.join()</code>会阻塞当前线程的运行，直到<code>handle</code>对应的线程终结。
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由于<code>hanle.join</code>返回的是<code>Option</code>类型的值，因此我们需要使用<code>unwrap</code>来解包。在上面的代码中，我们在子线程后添加了<code>handle.join().unwrap()</code>，此时<code>main</code>线程会被阻塞，直到子线程结束之后才会自己输出：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 4 from the main thread!</span><br></pre></td></tr></table></figure> 以上输出清晰的展示了线程阻塞的作用。</p>
<h3 id="在线程闭包中使用move">在线程闭包中使用move</h3>
<p>在先前的闭包章节中，我们有讲过<code>move</code>关键字在闭包中的使用可以让该闭包拿走环境中某个值的所有权，同样地，你可以使用<code>move</code>来将值的所有权从一个线程转移到另外一个线程。</p>
<p>首先，来看看在一个线程中直接使用另一个线程中的数据会如何：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上述代码中，子线程中的闭包捕获了主线程中的变量<code>v</code>，让我们来看一下输出：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function</span><br><span class="line"> --&gt; src/main.rs:6:32</span><br><span class="line">  |</span><br><span class="line">6 |     let handle = thread::spawn(|| &#123;</span><br><span class="line">  |                                ^^ may outlive borrowed value `v`</span><br><span class="line">7 |         println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">  |                                           - `v` is borrowed here</span><br><span class="line">  |</span><br><span class="line">note: function requires argument type to outlive `&#x27;static`</span><br><span class="line"> --&gt; src/main.rs:6:18</span><br><span class="line">  |</span><br><span class="line">6 |       let handle = thread::spawn(|| &#123;</span><br><span class="line">  |  __________________^</span><br><span class="line">7 | |         println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">8 | |     &#125;);</span><br><span class="line">  | |______^</span><br><span class="line">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword</span><br><span class="line">  |</span><br><span class="line">6 |     let handle = thread::spawn(move || &#123;</span><br><span class="line">  |                                ++++</span><br></pre></td></tr></table></figure> 其实上述代码本身并没有问题，问题在于 Rust
无法确定新的线程会活多久（多个线程的结束顺序并不是固定的），所以也无法确定新线程所引用的<code>v</code>
是否在使用过程中一直合法。</p>
<p>因此，我们需要使用<code>move</code>关键字来将<code>v</code>的所有权转移到子线程中，这样子线程就可以随意使用<code>v</code>了：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们需要记住，线程的启动时间点和结束时间点是不确定的，如果我们不添加<code>move</code>关键字，那么主线程中的<code>v</code>可能会在子线程结束之前被释放，导致子线程无法正常使用。</p>
<h1 id="多线程通信">多线程通信</h1>
<p>在多线程间有多种方式可以共享、传递数据。</p>
<h2 id="消息传递">消息传递</h2>
<p>一种很流行且能保证安全并发的技术就是：<strong>消息传递</strong>。线程(<code>Actor</code>)通过彼此发送消息（数据）来进行通信。</p>
<p>在Go语言中有一句很经典的话：<strong>Don’t communicate by sharing
memory, share memory by communicating</strong>。</p>
<p>与Go语言内置的<code>chan</code>不同，Rust
是在标准库里提供了消息通道(<code>channel</code>)。</p>
<h3 id="消息通道channel">消息通道Channel</h3>
<p>消息通道(<code>channel</code>)是Rust标准库提供的一种线程间通信机制，它可以让多个线程之间安全地传递数据，它由两部分组成：发送端(<code>Sender</code>)和接收端(<code>Receiver</code>)。</p>
<p>调用<code>channel</code>的<code>send</code>方法可以发送消息，调用<code>Receiver</code>的<code>recv</code>方法可以检查和接收到达的消息。</p>
<p>如果发送端或者接收端中的任意一端被丢弃了，那么<code>channel</code>就会被关闭，此时<code>recv</code>方法会返回一个错误。</p>
<p>显而易见的是，一个通道应该支持多个发送者和接收者。但是，在实际使用通道的过程中，我们需要使用不同的通道类型来满足诸如：
- 单个发送者和单个接收者 - 多个发送者和单个接收者 -
单个发送者和多个接收者 - 多个发送者和多个接收者
的多个应用场景。让我们先从<strong>多发送者，单接收者</strong>的场景开始讲起：</p>
<h3 id="多发送者单接收者">多发送者，单接收者</h3>
<p>标准库提供了通道<code>std::sync::mpsc</code>，其中<code>mpsc</code>是<code>multiple producer, single consumer</code>的缩写，代表了该通道支持多个发送者，但是只支持唯一的接收者。
需要注意的是，支持了多个发送者，自然也就支持了单个发送者。</p>
<p>我们可以使用<code>mspc::channel</code>函数来创建一个通道，这个函数会返回一个元组，元组中第一个元素是发送端，第二个元素是接收端：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个消息通道, 返回一个元组：(发送者，接收者)</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程，并发送消息</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// 发送一个数字1, send方法返回Result&lt;T,E&gt;，通过unwrap进行快速错误处理</span></span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option&lt;i32&gt;类型将产生不匹配错误</span></span><br><span class="line">        <span class="comment">// tx.send(Some(1)).unwrap()</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中接收子线程发送的消息并输出</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 让我们再来解读下上面的代码： -
<code>tx</code>,<code>rx</code>对应发送者和接收者，它们的类型由编译器自动推导:
<code>tx.send(1)</code>发送了整数，因此它们分别是<code>mpsc::Sender&lt;i32&gt;</code>和<code>mpsc::Receiver&lt;i32&gt;</code>类型，需要注意，由于内部是泛型实现，一旦类型被推导确定，该通道就只能传递对应类型的值,
例如此例中非<code>i32</code>类型的值将导致编译错误。 -
<code>send</code>方法发送想要发送的数据，并返回<code>Result&lt;T,E&gt;</code>，如果发送失败，则返回<code>Err</code>，成功则返回<code>Ok</code>。
-
<code>recv</code>方法会阻止当前线程的执行，直到它从通道中接收到消息，就会返回<code>Result&lt;T,E&gt;</code>，如果接收失败，则返回<code>Err</code>，成功则返回<code>Ok</code>。</p>
<h3 id="不阻塞的try_recv方法">不阻塞的<code>try_recv</code>方法</h3>
<p>在上面的代码中，我们使用了<code>recv</code>方法，该方法会阻塞当前线程，直到接收到消息。如果我们不希望阻塞当前线程，可以使用<code>try_recv</code>方法，该方法不会阻塞当前线程，而是立即返回<code>Result&lt;T,E&gt;</code>：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;:?&#125;&quot;</span>, rx.<span class="title function_ invoke__">try_recv</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由于子线程的创建需要时间，因此<code>println!</code>和<code>try_recv</code>方法会先执行，而此时子线程的消息还未被发出。<code>try_recv</code>会尝试立即读取一次消息，因为消息没有发出，此次读取最终会报错，且主线程运行结束：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receive Err(Empty)</span><br></pre></td></tr></table></figure>
如上，<code>try_recv</code>返回了一个错误，错误内容是Empty，代表通道并没有消息。如果你尝试把<code>println!</code>复制一些行，就会发现一个有趣的输出：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">receive Err(Empty)</span><br><span class="line">receive Ok(1)</span><br><span class="line">receive Err(Disconnected)</span><br></pre></td></tr></table></figure>
如上，当子线程创建成功且发送消息后，主线程会接收到<code>Ok(1)</code>的消息内容，紧接着子线程结束，发送者也随着被<code>drop</code>，此时接收者又会报错，但是这次错误原因有所不同：<code>Disconnected</code>代表发送者已经被关闭。</p>
<p>从上面的例子中，我们可以得出一个启示：通常需要使用循环调用来检查<code>try_recv</code>的结果。</p>
<h3 id="mspcsenderclone"><code>mspc::sender::clone</code></h3>
<p>在上面的例子中，我们始终使用了单发送者，单接受者的通道。如果我们需要多个发送者，该怎么做呢？</p>
<p>标准库为我们提供了<code>clone</code>方法，可以克隆发送者：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx1</span> = mpsc::Sender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx2</span> = mpsc::Sender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line"></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    tx1.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx2.<span class="title function_ invoke__">send</span>(<span class="number">2</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;:?&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;:?&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 课后习题 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 课后习题1：实现多线程文件处理器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// •任务描述</span></span><br><span class="line"><span class="comment">// 	•你需要编写一个多线程文件处理器。它从一个通道（channel）中接收文件路径，并在线程池中处理这些文件。文件处理的具体任务可以是读取文件内容并打印到控制台。你需要使用 Rust 的带缓冲区的 channel 来控制并发线程的数量，从而限制同时处理的文件数量。</span></span><br><span class="line"><span class="comment">// •具体要求</span></span><br><span class="line"><span class="comment">// 	•文件处理任务：</span></span><br><span class="line"><span class="comment">// 	•定义一个函数 process_file，该函数接受一个文件路径，读取文件内容，并将内容打印到控制台。</span></span><br><span class="line"><span class="comment">// •多线程控制：</span></span><br><span class="line"><span class="comment">// 	•创建一个带缓冲区的 channel，用于在主线程和工作线程之间传递文件路径。</span></span><br><span class="line"><span class="comment">// 	•使用多线程来实现文件处理的并发性，限制线程的并发数量（例如，最多同时处理 4 个文件）。</span></span><br><span class="line"><span class="comment">// •主线程作为生产者：</span></span><br><span class="line"><span class="comment">// 	•主线程负责向通道发送文件路径。假设我们有 10 个文件路径要处理。</span></span><br><span class="line"><span class="comment">// •工作线程作为消费者：</span></span><br><span class="line"><span class="comment">// 	•创建多个工作线程，每个线程从通道中接收文件路径，并调用 process_file 函数来处理文件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;   </span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex; </span><br><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_test_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dir_path</span> = <span class="string">&quot;test_files&quot;</span>;</span><br><span class="line">    fs::<span class="title function_ invoke__">create_dir_all</span>(dir_path)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file_path</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;/file_&#123;&#125;.txt&quot;</span>, dir_path, i);</span><br><span class="line">        fs::<span class="title function_ invoke__">write</span>(file_path, <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, i, i, i))?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_file</span>(file_path: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    <span class="keyword">match</span> fs::<span class="title function_ invoke__">read_to_string</span>(&amp;file_path) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(content) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;处理文件: &#123;&#125;&quot;</span>, file_path);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;读取文件 &#123;&#125; 时发生错误: &#123;&#125;&quot;</span>, file_path, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="title function_ invoke__">create_test_file</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;创建测试文件时发生错误: &#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rx</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(rx));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rx</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;rx);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;工作线程 &#123;&#125; 已启动&quot;</span>, id);</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="comment">// 获取锁并立即释放，只在接收消息时短暂持有锁</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">try_recv</span>();</span><br><span class="line">                <span class="keyword">match</span> received &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(file_path) =&gt; &#123;</span><br><span class="line">                        <span class="title function_ invoke__">process_file</span>(file_path);</span><br><span class="line">                        thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(mpsc::TryRecvError::Empty) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// 通道为空，短暂等待后重试</span></span><br><span class="line">                        thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(mpsc::TryRecvError::Disconnected) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// 通道已关闭，退出循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;工作线程 &#123;&#125; 已结束&quot;</span>, id);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">path</span> = <span class="built_in">format!</span>(<span class="string">&quot;test_files/file_&#123;&#125;.txt&quot;</span>, i);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;已发送文件路径: file_&#123;&#125;.txt&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 课后习题2：使用Channel实现程序的优雅停止</span></span><br><span class="line"><span class="comment">// • 任务描述</span></span><br><span class="line"><span class="comment">//     。在这道练习中，你需要编写一个多线程程序，该程序会创建多个工作线程，持续处理任务。在接收到停止信号时，所有工作线程应该优雅地停止工作，并确保所有未完成的任务都被处理完毕。</span></span><br><span class="line"><span class="comment">//     你将使用Rust的channel来实现任务的调度和优雅停止机制。</span></span><br><span class="line"><span class="comment">// • 具体要求</span></span><br><span class="line"><span class="comment">//     • 工作线程：</span></span><br><span class="line"><span class="comment">//         创建一个工作线程池，工作线程从通道接收任务并处理。</span></span><br><span class="line"><span class="comment">//         工作线程应能够响应停止信号，并在完成当前任务后优雅地退出。</span></span><br><span class="line"><span class="comment">//     • 任务结构：</span></span><br><span class="line"><span class="comment">//         任务可以是简单的打印操作，模拟一些耗时工作，例如打印任务ID并暂停一段时间。</span></span><br><span class="line"><span class="comment">//     • 优雅停止：</span></span><br><span class="line"><span class="comment">//         通过发送一个特殊的停止信号，通知所有工作线程停止接收新的任务，并在完成当前任务后退出。</span></span><br><span class="line"><span class="comment">//         确保所有已接收的任务都被处理完毕。</span></span><br><span class="line"><span class="comment">//     • 主线程控制：</span></span><br><span class="line"><span class="comment">//         主线程应当能够发送任务，也能够在适当的时候发送停止信号，触发工作线程的优雅停止。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;mpsc, Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">NewTask</span>(<span class="type">u32</span>),</span><br><span class="line">    Stop,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: <span class="type">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">message</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> message &#123;</span><br><span class="line">                Message::<span class="title function_ invoke__">NewTask</span>(task_id) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;工作线程&#123;&#125;正在处理任务&#123;&#125;&quot;</span>, id, task_id);</span><br><span class="line">                    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;工作线程&#123;&#125;完成任务&#123;&#125;&quot;</span>, id, task_id);</span><br><span class="line">                &#125;</span><br><span class="line">                Message::Stop =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;工作线程&#123;&#125;收到停止信号&quot;</span>, id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123; id, thread: <span class="title function_ invoke__">Some</span>(thread) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rx</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(rx));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">worker_id</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">worker</span> = Worker::<span class="title function_ invoke__">new</span>(worker_id, Arc::<span class="title function_ invoke__">clone</span>(&amp;rx));</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(worker);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">10</span> &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(Message::<span class="title function_ invoke__">NewTask</span>(i)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;主线程发送任务 &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..handles.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(Message::Stop).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.thread.<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;所有任务完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/01/rust-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/01/rust-test/" class="post-title-link" itemprop="url">二十四、Rust测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-01 16:44:06" itemprop="dateCreated datePublished" datetime="2024-11-01T16:44:06+08:00">2024-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-02 09:02:00" itemprop="dateModified" datetime="2024-11-02T09:02:00+08:00">2024-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="测试">测试</h1>
<p>Rust在工程化方面完美的支持了各种测试配置，包括<code>Unit Test</code>单元测试、<code>Integration Test</code>集成测试、<code>Doc Test</code>文档测试、<code>Bench Test</code>基准测试、<code>Example Test</code>示例测试等。</p>
<h2 id="单元测试-unit-test">单元测试 Unit Test</h2>
<p>单元测试目标是测试某一个代码单元(一般都是函数)，验证该单元是否能按照预期进行工作，例如测试一个<code>add</code>函数，验证当给予两个输入时，最终返回的和是否符合预期。</p>
<p>我们首先使用<code>cargo new --lib rust-lib</code>创建一个库项目，此时打开<code>lib.rs</code>文件，可以看到如下代码：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">usize</span>, right: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;   <span class="comment">// 使用super::*来访问父模块中的所有公共项</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这串代码就是一个单元测试的模块。在上面的示例代码中，我们首先使用<code>#[cfg(test)]</code>属性来标记测试模块<code>mod tests</code>，然后使用<code>#[test]</code>属性来标记测试函数<code>it_works</code>。</p>
<h3 id="条件编译cfgtest">条件编译<code>#[cfg(test)]</code></h3>
<p>上面代码中的<code>#[cfg(test)]</code>标注可以告诉Rust只有在<code>cargo test</code>时才编译和运行模块<code>tests</code>，其它时候当这段代码是空气即可，例如在<code>cargo build</code>时。这么做有几个好处：
- 节省构建代码时的编译时间 - 减小编译出的可执行文件的体积</p>
<h3 id="使用assert宏">使用<code>assert!</code>宏</h3>
<p>在上面的测试模块中，我们使用<code>assert_eq!</code>宏来断言<code>add</code>函数的返回值是否等于<code>4</code>。<code>assert!</code>宏是<code>assert_eq!</code>宏的简化版，它用于断言一个条件为真。如果条件为假，<code>assert!</code>宏会立即终止程序，并输出错误信息。</p>
<p>在上面的代码中<code>assert_eq!(result, 4);</code>显然是成功的，因此该语句返回了一个单元类型<code>()</code>。但如果断言失败，<code>assert!</code>宏会输出错误信息，并返回一个<code>panic!</code>，使得测试失败。</p>
<p>但如上面所说，
<code>assert!</code>宏自己抛出的错误信息只会告诉我们错误发生的地方，并没有提供更多的信息，在有些时候会让人一头雾水。因此，我们可以为<code>assert!</code>宏提供一个可选的错误信息，这样可以帮助我们更好的定位错误：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert!</span>(result == <span class="number">4</span>, <span class="string">&quot;计算错误，result为&#123;&#125;，不等于4&quot;</span>, result);</span><br></pre></td></tr></table></figure>
这段代码跟之前并无不同，只是为<code>assert!</code>新增了几个格式化参数，这种使用方式与<code>format!</code>并无区别，但是，我们可以得到更加精确的报错信息。</p>
<h3 id="使用resultt-e">使用<code>Result&lt;T, E&gt;</code></h3>
<p>我们也可以使用在单元测试中让函数返回一个<code>Result&lt;(), E&gt;</code>，这样可以帮助我们更好的处理错误：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">feature_test</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;2 + 2 != 5&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果函数返回<code>Ok(())</code>，则测试通过;但若测试失败，则返回<code>Err(String)</code>，并输出错误信息。</p>
<h3 id="使用should_panic">使用<code>should_panic</code></h3>
<p>想象一下，如果一个函数在某些情况下会抛出错误，那么我们如何测试这种情况呢？为此，Rust为我们提供了<code>should_panic</code>属性：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_todo</span>() &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在使用<code>should_panic</code>属性时，如果测试函数成功抛出错误，则测试成果，但如果没有抛出错误，则测试失败。</p>
<h4 id="使用expected">使用<code>expected</code></h4>
<p>在上面我们提到可以使用<code>should_panic</code>属性来测试函数是否抛出错误，但有时候我们希望测试函数抛出的错误信息与我们预期的一致，这时我们就可以使用<code>expected</code>属性：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic(expected = <span class="string">&quot;计算错误&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_todo</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;计算错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>expected</code>属性用于指定我们期望测试函数抛出的错误信息，如果测试函数抛出的错误信息与期望的不一致，则测试失败。</p>
<h3 id="使用ignore">使用<code>ignore</code></h3>
<p>在有些时候，我们希望跳过某个测试，这时我们可以使用<code>ignore</code>属性：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_ignore</span>() &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样，在执行<code>cargo test</code>时，<code>test_ignore</code>函数将被跳过。</p>
<h3
id="使用cargo-test---test-test_name">使用<code>cargo test --test test_name</code></h3>
<p>在有些时候，我们希望只运行某一个测试，这时我们可以使用<code>cargo test --test test_name</code>命令：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> --<span class="built_in">test</span> test_name</span><br></pre></td></tr></table></figure>
此时，只有函数名为<code>test_name</code>的测试会被运行。</p>
<h2 id="集成测试-integration-test">集成测试 Integration Test</h2>
<p>在单元测试中，我们可以直接在<code>lib.rs</code>文件中编写测试代码，但这样会使得测试代码与业务代码耦合在一起，不便于管理。为此，Rust为我们提供了集成测试。</p>
<p>我们可以在与<code>src</code>目录平级的<code>tests</code>目录中编写集成测试代码，Rust会自动将<code>tests</code>目录中的所有<code>.rs</code>文件识别为集成测试文件。</p>
<p>集成测试与单元测试还有一点不同：单元测试是对代码单元进行测试，而集成测试就是对某一个功能或者接口进行测试。因此单元测试的通过，并不代表集成测试就会通过：局部上反映不出的问题，在全局上很可能会暴露出来。</p>
<p>让我们在<code>tests</code>目录中创建一个<code>integration.rs</code>文件，并编写如下代码：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rust_lib::add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_add</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
首先与单元测试不同的是，我们并没有使用<code>mod</code>创建测试模块，也没有使用<code>#[cfg(test)]</code>标注。这是因为集成测试本身就在<code>tests</code>目录中，说明了它的特殊用途，因此无需额外标注。其次，我们使用了<code>use</code>关键字导入了<code>add</code>函数，这是因为集成测试与单元测试不同，它不在<code>lib.rs</code>文件中，因此需要手动导入后才能进行测试。</p>
<p>如果此时我们直接运行<code>cargo test</code>，会输出如下信息：
<figure class="highlight plaintext"><figcaption><span>cargo test</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     Running unittests (target/debug/deps/adder-8a400aa2b5212836)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests/integration_test.rs (target/debug/deps/integration_test-2d3aeee6f15d1f20)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test it_adds_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>
可以看到在上述输出中，测试的内容共有3个部分：单元测试、集成测试和文档测试。</p>
<p>但如果此时我们只希望进行集成测试，就可以使用<code>cargo test --test integration</code>命令：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> --<span class="built_in">test</span> integration</span><br></pre></td></tr></table></figure>
这与单元测试中的<code>cargo test --test test_name</code>命令类似，只不过将<code>test_name</code>替换为<code>integration</code>即可。</p>
<h3 id="共享模块">共享模块</h3>
<p>在集成测试的<code>tests</code>目录下，每一个文件都是一个独立的包，这种组织方式可以很好的帮助我们理清测试代码的关系，但是如果大家想要在多个文件中共享同一个功能该怎么做？例如函数<code>setup</code>可以用于状态初始化，然后多个测试包都需要使用该函数进行状态的初始化。</p>
<p>也许你会想要创建一个<code>tests/common.rs</code>文件，然后将<code>setup</code>函数放入其中：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">setup</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化一些测试状态</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是当我们运行<code>cargo test</code>后，会发现<strong>该函数被当作集成测试函数运行了</strong>，即使它并没有包含任何测试功能，也没有被其它测试文件所调用:
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span></span><br><span class="line">     Running tests/common.rs (target/debug/deps/common-5c21f4f2c87696fb)</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.00s</span><br></pre></td></tr></table></figure>
显然，这个结果并不是我们想要的。为了避免这种输出，我们不能创建<code>tests/common.rs</code>，而是要创建<code>tests/common/mod.rs</code>，此时再运行<code>cargo test</code>就不会再看到相应的输出。
原因是通过这种文件组织和命名方式，Rust不再将<code>common</code>模块看作是集成测试文件。</p>
<p>总结来说，<code>tests</code>目录下的子目录中的文件不会被当作独立的包，也不会有测试输出。
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> common;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    common::<span class="title function_ invoke__">setup</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此时，就可以在测试中调用<code>common</code>中的共享函数了，不过还有一点值得注意，为了使用<code>common</code>，这里使用了<code>mod common</code>的方式来声明该模块。</p>
<h2 id="文档测试-doc-test">文档测试 Doc Test</h2>
<p>在上面我们运行<code>cargo test</code>时，会发现终端输出的测试信息包括了单元测试、集成测试和文档测试。在前面我们已经提到了单元测试和集成测试，接下来让我们来看一下文档测试。</p>
<p>文档测试分为两部分，一部分是针对模块的测试，而另一部分则是针对函数的测试。</p>
<p>我们可以通过<code>///</code>来进行书写文档测试： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Add to number</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">/// ``` rust</span></span><br><span class="line"><span class="comment">/// assert_eq!(rust_lib::add(2, 2), 4);</span></span><br><span class="line"><span class="comment">/// ``` </span></span><br></pre></td></tr></table></figure>
以上代码有几点需要注意： -
文档注释需要位于<code>lib</code>类型的包中，例如<code>src/lib.rs</code>中
-
文档注释可以使用markdown语法！例如<code># Examples</code>的标题，以及代码块高亮
-
被注释的对象需要使用<code>pub</code>对外可见，记住：文档注释是给用户看的，内部实现细节不应该被暴露出去</p>
<p>我们可以通过<code>cargo test --doc</code>来运行文档测试：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> --doc</span><br></pre></td></tr></table></figure></p>
<p>同时，我们也可以使用<code>//!</code>来为模块进行测试：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! A library for adding numbers</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! # utils</span></span><br><span class="line"><span class="comment">//! ```rust</span></span><br><span class="line"><span class="comment">//! assert_eq!(rust_lib::utils::add(2, 2), 4);</span></span><br><span class="line"><span class="comment">//! ```</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">usize</span>, right: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        left + right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基准测试-bench-test">基准测试 Bench Test</h2>
<p>几乎所有开发都知道，如果要测量程序的性能，就需要性能测试。</p>
<p>性能测试包含了两种：压力测试和基准测试。前者是针对接口
API，模拟大量用户去访问接口然后生成接口级别的性能数据；而后者是针对代码，可以用来测试某一段代码的运行速度，例如一个排序算法。</p>
<p>Rust中提供了<code>#[bench]</code>属性来标记基准测试，并使用<code>criterion</code>库来生成性能数据。
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(test)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> test::Bencher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[bench]</span>    <span class="comment">// 使用#[bench]属性来标记基准测试</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">bench_add_two</span>(b: &amp;<span class="keyword">mut</span> Bencher) &#123;</span><br><span class="line">        b.<span class="title function_ invoke__">iter</span>(|| <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="目录结构规范">目录结构规范</h2>
<p>最后，让我们来回顾一下整个项目的目录规范； <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── src/</span><br><span class="line">│   ├── lib.rs        <span class="comment"># 库代码</span></span><br><span class="line">│   ├── main.rs       <span class="comment"># 二进制代码</span></span><br><span class="line">│   ├── bin/          <span class="comment"># 额外的二进制文件</span></span><br><span class="line">│   │   └── demo.rs</span><br><span class="line">│   └── utils/        <span class="comment"># 内部模块</span></span><br><span class="line">│       ├── mod.rs</span><br><span class="line">│       └── math.rs</span><br><span class="line">├── tests/            <span class="comment"># 集成测试目录</span></span><br><span class="line">│   ├── common/       <span class="comment"># 测试公共模块</span></span><br><span class="line">│   │   └── mod.rs</span><br><span class="line">│   └── integration_test.rs</span><br><span class="line">├── benches/          <span class="comment"># 基准测试目录</span></span><br><span class="line">│   └── bench.rs</span><br><span class="line">├── examples/         <span class="comment"># 示例代码</span></span><br><span class="line">│   └── demo.rs</span><br><span class="line">└── docs/            <span class="comment"># 文档</span></span><br><span class="line">    └── api.md</span><br></pre></td></tr></table></figure></p>
<h2 id="课后习题">课后习题</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/01/rust-iterator-associated-types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/01/rust-iterator-associated-types/" class="post-title-link" itemprop="url">二十三、Rust进阶-迭代器与关联类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-01 10:43:59" itemprop="dateCreated datePublished" datetime="2024-11-01T10:43:59+08:00">2024-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:43:58" itemprop="dateModified" datetime="2024-11-14T07:43:58+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="迭代器iterator">迭代器Iterator</h1>
<p>迭代器（Iterator）是Rust标准库中提供的一种数据类型，用于遍历集合中的元素。迭代器可以用于遍历数组、向量、哈希表等数据结构。在此过程中，我们只需关心集合中的元素如何处理，而无需关心如何开始、如何结束以及需要按照什么样的索引去访问等问题。</p>
<p>迭代器会负责遍历集合中的每个元素，并确定遍历何时完成。</p>
<h2 id="惰性初始化">惰性初始化</h2>
<p>Rust的迭代器是懒惰的，除非我们调用消费迭代器的方法，否则迭代器本身没有任何效果。
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里虽然创建了迭代器，但是在不使用时并不会遍历，因为Rust的迭代器是懒惰的</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当for循环使用迭代器时，迭代器才会开始遍历</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> v1_iter &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这种惰性初始化的方式确保了创建迭代器不会有任何额外的性能损耗，其中的元素也不会被消耗，只有使用到该迭代器的时候，一切才开始。</p>
<h2 id="迭代器的实现">迭代器的实现</h2>
<p>迭代器是一个能够注意生成元素的对象。它提供了一个统一的接口，用于遍历容器中的元素，同时保重了类型安全和内存安全。</p>
<p>在Rust中，迭代器是基于trait实现的。这个trait被称为<code>Iterator</code>，它定义了迭代器的基本行为。在该trait中，定义了<code>next</code>方法，该方法会返回迭代器中的下一个值，当迭代器结束时，返回<code>None</code>。
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>type Item</code>和<code>Self::Item</code>定义了与该trait关联的类型，用于指定迭代器生成的元素的类型。</p>
<p>实现<code>Iterator</code>trait需要你定义一个<code>item</code>类型，并且使用<code>Self::Item</code>来指定，它用于<code>next</code>方法返回的值的类型。</p>
<h2 id="关联类型">关联类型</h2>
<p>上面我们所提到的就是关联类型。关联类型是trait中的类型占位符，它可以用于trait的方法签名中，trait的实现者需要为它指定具体的类型。它可以定义出包含某些类型的trait，而无需在实现前就知道这些类型是什么。</p>
<h3 id="泛型与关联类型的区别">泛型与关联类型的区别</h3>
<p><strong>泛型</strong>： -泛型需要在每次实现trait时标注类型
-可以为一个泛型多次实现某个trait（不同的泛型参数） <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyIterator</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">MyIterator</span> &#123;  <span class="comment">// 为泛型T指定String类型并实现next方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">MyIterator</span> &#123;  <span class="comment">// 为泛型T指定i32类型并实现next方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>关联类型</strong>： -关联类型无需在实现trait时标注类型
-不能为单个关联类型多次实现某个trait <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator2</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyIterator</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator2</span> <span class="keyword">for</span> <span class="title class_">MyIterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator2</span> <span class="keyword">for</span> <span class="title class_">MyIterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">i32</span>;    <span class="comment">// 此时会报错，因为关联类型不能被多次实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="简单迭代器">简单迭代器</h2>
<p>下面让我们来实现一个简单的迭代器： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个迭代器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">numbers_iter</span> = numbers.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用while循环遍历迭代器中的元素</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(num) = numbers_iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，我们首先使用<code>numbers.iter()</code>创建了一个迭代器，然后使用<code>while let</code>循环遍历了迭代器中的元素，<code>iter.next()</code>方法会返回迭代器中的下一个元素，当迭代器结束时，返回<code>None</code>。</p>
<p>同时，我们可以发现，上面的代码中我们使用了<code>let mut</code>来声明迭代器，这是因为<code>next</code>方法会修改迭代器的状态，所以需要使用<code>mut</code>关键字。但是之前在使用<code>for</code>循环时，我们并没有使用<code>mut</code>关键字，这是因为<code>for</code>循环会自动将迭代器声明为<code>mut</code>，所以不需要我们手动声明。</p>
<h2 id="几个迭代的方法">几个迭代的方法</h2>
<p>我们有几个不同的方法来创建迭代器： -
<code>iter()</code>：在不可变引用上创建一个不可变的迭代器 -
<code>iter_mut()</code>：在可变引用上创建一个可变的迭代器 -
<code>into_iter()</code>：创建一个拥有所有权的迭代器</p>
<p>让我们来看一个例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">values</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">v</span> <span class="keyword">in</span> values.<span class="title function_ invoke__">into_iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的代码将报错，因为 values 的所有权在上面 `for` 循环中已经被转移走</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,values);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">values</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_values_iter</span> = values.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不会报错，因为 values_iter 只是借用了 values 中的元素</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, values);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">values</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 对 values 中的元素进行可变借用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">values_iter_mut</span> = values.<span class="title function_ invoke__">iter_mut</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出第一个元素，并修改为0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = values_iter_mut.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        *v = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出[0, 2, 3]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实际上，以后很多含有<code>into_</code>的方法都会拿走所有权，而<code>_mut</code>方法会创建一个可变引用，剩下的都是不可变借用。</p>
<h2 id="消耗迭代器的方法">消耗迭代器的方法</h2>
<p>消费者是迭代器上的方法，它会消费掉迭代器中的元素，然后返回其类型的值，这些消费者都有一个共同的特点：在它们的定义中，都依赖<code>next</code>方法来消费元素，因此这也是为什么迭代器要实现<code>Iterator</code>特征，而该特征必须要实现<code>next</code>方法的原因。</p>
<h3 id="消费者适配器">消费者适配器</h3>
<p>只要迭代器上的某个方法<code>A</code>在其内部调用了<code>next</code>方法，那么<code>A</code>就被称为消费性适配器：因为<code>next</code>方法会消耗掉迭代器上的元素，所以方法<code>A</code>的调用也会消耗掉迭代器上的元素。</p>
<p>其中一个例子是<code>sum</code>方法，它会拿走迭代器的所有权，然后通过不断调用<code>next</code>方法遍历所有元素并进行求和：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = v1_iter.<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v1_iter 是借用了 v1，因此 v1 可以照常使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下代码会报错，因为 `sum` 拿到了迭代器 `v1_iter` 的所有权</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,v1_iter);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如代码注释中所说明的：在使用<code>sum</code>方法后，我们将无法再使用<code>v1_iter</code>，因为<code>sum</code>拿走了该迭代器的所有权：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>&lt;S&gt;(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> S</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">        S: Sum&lt;<span class="keyword">Self</span>::Item&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        Sum::<span class="title function_ invoke__">sum</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
从<code>sum</code>源码中也可以清晰看出，<code>self</code>类型的方法参数拿走了所有权。</p>
<h3 id="迭代器适配器">迭代器适配器</h3>
<p>定义在<code>Iterator</code>trait中的另一些方法被称为迭代器适配器，它们不会消耗掉迭代器中的元素，相反，它们会返回一个新的迭代器。这是实现链式方法调用的关键：<code>v.iter().map().filter()...</code>。</p>
<p>与消费者适配器不同，迭代器适配器是惰性的，这意味着你需要一个消费者适配器来触发它们的执行，最终将迭代器转换成一个具体的值：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
这里的<code>map</code>方法就是一个迭代器适配器，允许我们对迭代器中的每个元素应用一个函数，并返回一个新的迭代器。在上面的代码示例中，<code>map</code>将一个闭包<code>|x| x + 1</code>应用到迭代器中的每个元素，并返回一个新的迭代器。</p>
<p>运行后输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">warning: unused `Map` that must be used</span><br><span class="line"> --&gt; src/main.rs:4:5</span><br><span class="line">  |</span><br><span class="line">4 |     v1.iter().map(|x| x + 1);</span><br><span class="line">  |     ^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_must_use)]` on by default</span><br><span class="line">  = note: iterators are lazy and do nothing unless consumed // 迭代器`map`是惰性的，这里不产生任何效果</span><br></pre></td></tr></table></figure>
如上述中文注释所说，这里的<code>map</code>方法是一个迭代者适配器，它是惰性的，不产生任何行为，因此我们还需要一个消费者适配器进行收尾：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure></p>
<h3 id="collect">collect</h3>
<p>在上面代码中，我们使用了<code>collect</code>方法，它就是一个消费者适配器，它接受一个迭代器，并将其转换为一个集合类型，如<code>Vec</code>、<code>HashMap</code>等。这里我们为<code>v2</code>标注了<code>Vec&lt;_&gt;</code>类型，就是为了告诉<code>collect</code>：将迭代器中的元素收集到一个<code>Vec</code>中。</p>
<p>再来看看如何使用<code>collect</code>收集成<code>HashMap</code>集合：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">names</span> = [<span class="string">&quot;sunface&quot;</span>, <span class="string">&quot;sunfei&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ages</span> = [<span class="number">18</span>, <span class="number">18</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">folks</span>: HashMap&lt;_, _&gt; = names.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">zip</span>(ages.<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,folks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>zip</code>是一个迭代器适配器，它的作用就是将两个迭代器的内容压缩到一起，形成<code>Iterator&lt;Item=(ValueFromA, ValueFromB)&gt;</code>这样的新的迭代器，在此处就是形如<code>[(name1, age1), (name2, age2)]</code>的迭代器。</p>
<p>然后再通过<code>collect</code>将新迭代器中<code>(K, V)</code>形式的值收集成<code>HashMap&lt;K, V&gt;</code>，同样的，这里必须显式声明类型，然后<code>HashMap</code>内部的<code>KV</code>类型可以交给编译器去推导，最终编译器会推导出<code>HashMap&lt;&amp;str, i32&gt;</code>，完全正确！</p>
<h3 id="filter">filter</h3>
<p><code>filter</code>方法用于过滤迭代器中的元素，它接受一个闭包作为参数，该闭包会返回一个布尔值，<code>filter</code>方法会根据这个布尔值来决定是否保留该元素:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shoe</span> &#123;</span><br><span class="line">    size: <span class="type">u32</span>,</span><br><span class="line">    style: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shoes_in_size</span>(shoes: <span class="type">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|s| s.size == shoe_size).<span class="title function_ invoke__">collect</span>() <span class="comment">// 使用filter过滤出size等于shoe_size的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>filter</code>是迭代器适配器，用于对迭代器中的每个值进行过滤。
它使用闭包作为参数，该闭包的参数<code>s</code>是来自迭代器中的值，然后使用<code>s</code>跟外部环境中的<code>shoe_size</code>进行比较，若相等，则在迭代器中保留<code>s</code>值，若不相等，则从迭代器中剔除<code>s</code>值，最终通过<code>collect</code>收集为<code>Vec&lt;Shoe&gt;</code>类型。</p>
<h2 id="实现iteratortrait">实现<code>Iterator</code>trait</h2>
<p>之前的内容我们都是使用Rust标准库中已经实现好的迭代器，那么如果我们想要实现自己的迭代器，就需要实现<code>Iterator</code>trait。在这里，我们必须要实现<code>next</code>方法，因为该方法定义了迭代器如何产生下一个元素。</p>
<p>让我们来自己实现一个吧！</p>
<p>首先，创建一个计数器： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们为计数器<code>Counter</code>实现了一个关联函数<code>new</code>，用于创建新的计数器实例。下面我们继续为计数器实现<code>Iterator</code>特征：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)   </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
首先，将该特征的关联类型设置为<code>u32</code>，由于我们的计数器保存的<code>count</code>字段就是<code>u32</code>类型，
因此在<code>next</code>方法中，最后返回的是实际上是<code>Option&lt;u32&gt;</code>类型。</p>
<p>每次调用<code>next</code>方法，都会让计数器的值加一，然后返回最新的计数值，一旦计数大于<code>5</code>，就返回<code>None</code>。</p>
<p>最后，使用我们新建的<code>Counter</code>进行迭代： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="课后作业">课后作业</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    a: <span class="type">u32</span>,</span><br><span class="line">    b: <span class="type">u32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Fibonacci &#123; a: <span class="number">0</span>, b: <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">take</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, n: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">            result.<span class="title function_ invoke__">push</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Iterator trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">next_value</span> = <span class="keyword">self</span>.a + <span class="keyword">self</span>.b;</span><br><span class="line">        <span class="keyword">self</span>.a = <span class="keyword">self</span>.b;</span><br><span class="line">        <span class="keyword">self</span>.b = next_value;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fib</span> = Fibonacci::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> fib.<span class="title function_ invoke__">take</span>(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/31/rust-closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/31/rust-closure/" class="post-title-link" itemprop="url">二十二、Rust进阶-闭包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-31 23:42:39" itemprop="dateCreated datePublished" datetime="2024-10-31T23:42:39+08:00">2024-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:41:57" itemprop="dateModified" datetime="2024-11-14T07:41:57+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="闭包closure">闭包Closure</h1>
<p>Rust在程序设计中收到了很多语言的影响，其中就包括函数式编程语言。函数式编程有特点如下：</p>
<ul>
<li>函数是一等公民，它既可以存储在变量中，也可以作为参数传递给其他函数，还可以作为返回值返回。</li>
</ul>
<p>闭包是函数式编程语言中非常重要的概念，Rust也引入了闭包的概念。</p>
<h2 id="闭包的定义">闭包的定义</h2>
<p>闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值，例如：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = |y: <span class="type">i32</span>| x + y;</span><br></pre></td></tr></table></figure>
上面的代码展示了非常简单的闭包<code>sum</code>，它拥有一个入参<code>y</code>，同时捕获了作用域中的<code>x</code>的值，因此调用<code>sum(2)</code>意味着将<code>2</code>（参数<code>y</code>）跟<code>1</code>（<code>x</code>）进行相加，最终返回它们的和：<code>3</code>。</p>
<p>闭包有特点如下： - 可以捕获周围作用域的变量 -
支持作为参数传递给其他函数 - 可以返回闭包作为函数的返回值 -
类型推断：闭包通常通过类型推断来确定参数和返回值类型</p>
<h2 id="闭包的语法">闭包的语法</h2>
<p>闭包的语法非常简单，只需要用<code>|</code>包裹参数列表，用<code>-&gt;</code>指定返回值类型，用<code>&#123;&#125;</code>包裹函数体即可：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = |参数列表| <span class="punctuation">-&gt;</span> 返回值类型 &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>有简单示例如下： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">add_one</span> = |x: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_one</span>(<span class="number">1</span>)); <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure></p>
<p>同时，由于Rust可以推断闭包的参数和返回值类型，因此在很多情况下可以省略类型声明：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">add_one</span> = |x| x + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_one</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="闭包的使用">闭包的使用</h2>
<h3 id="作为函数参数">作为函数参数</h3>
<p>闭包可以作为函数的参数传递，从而实现更灵活的代码结构：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">apply_to_3</span>&lt;F&gt;(f: F) <span class="punctuation">-&gt;</span> <span class="type">i32</span>   <span class="comment">//这里的参数F是一个泛型参数，F是闭包的类型</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>,  <span class="comment">// 约束F是一个函数，且参数是i32，返回值也是i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">double</span> = |x| x * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">apply_to_3</span>(double)); <span class="comment">// 输出：6</span></span><br></pre></td></tr></table></figure></p>
<h3 id="捕获环境变量">捕获环境变量</h3>
<p>闭包可以捕获其周围环境中的变量，例如： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>; </span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y)); <span class="comment">//断言成功，说明equal_to_x捕获了x的值，即使它没有作为参数传入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的例子中，<code>equal_to_x</code>闭包捕获了变量<code>x</code>，因此在调用<code>equal_to_x(y)</code>时，<code>y</code>的值会与<code>x</code>的值进行比较。但如果我们将该闭包换成函数，那么结果会怎么样呢：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//let equal_to_x = |z| z == x;</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">equal_to_x</span>(z: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        z == x     <span class="comment">// 这里z == x，但是x是函数外的变量，因此这里会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>; </span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
显然函数<code>equal_to_x</code>没有捕获变量<code>x</code>。</p>
<p>闭包有三种捕获变量的方式： -
值捕获：闭包通过值捕获其环境中的变量，将环境变量的所有权转移到闭包中 -
引用捕获：闭包通过引用捕获其环境中的变量，闭包在定义时捕获变量的引用，在调用时使用这些引用。
-
可变引用捕获：闭包通过可变引用捕获其环境中的变量，闭包在定义时捕获变量的可变引用，在调用时使用这些可变引用。</p>
<p>让我们来看下面的几个例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 引用捕获</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_num</span> = |x: <span class="type">i32</span>| x + num;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_num</span>(<span class="number">1</span>)); <span class="comment">// 输出：6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变引用捕获</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">change_num</span> = |x: <span class="type">i32</span>| num += x;</span><br><span class="line"><span class="title function_ invoke__">change_num</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure></p>
<h2 id="闭包的类型推导">闭包的类型推导</h2>
<p>Rust
是静态语言，因此所有的变量都具有类型，但是得益于编译器的强大类型推导能力，在很多时候我们并不需要显式地去声明类型，但是显然函数并不在此列，必须手动为函数的所有参数和返回值指定类型。原因在于函数往往会作为
API
提供给你的用户，因此你的用户必须在使用时知道传入参数的类型和返回值类型。</p>
<p>与函数相反，闭包并不会作为 API
对外提供，因此它可以享受编译器的类型推导能力，无需标注参数和返回值的类型。</p>
<p>为了增加代码可读性，有时候我们会显式地给类型进行标注，出于同样的目的，也可以给闭包标注类型：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = |x: <span class="type">i32</span>, y: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
与之相比，不标注类型的闭包声明会更简洁些：<code>let sum = |x, y| x + y</code>，需要注意的是，针对<code>sum</code>闭包，如果你只进行了声明，但是没有使用，编译器会提示你为<code>x, y</code>添加类型标注，因为它缺乏必要的上下文：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sum</span>  = |x, y| x + y;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
这里我们使用了<code>sum</code>，同时把<code>1</code>传给了<code>x</code>，<code>2</code>传给了<code>y</code>，因此编译器才可以推导出<code>x,y</code>的类型为<code>i32</code>。</p>
<p>十分值得我们注意的是，虽然类型推导十分好用，但它不是泛型，<strong>当编译器推导出一种类型后，它就会一直使用该类型：</strong>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>); <span class="comment">// 编译器会报错，因为编译器已经推导出x的类型为String，因此不能将i32类型的5传递给x</span></span><br></pre></td></tr></table></figure>
当运行到<code>let n = example_closure(5);</code>时，编译器会报错，因为编译器已经推导出<code>x</code>的类型为<code>String</code>，因此不能将<code>i32</code>类型的<code>5</code>传递给<code>x</code>。</p>
<h2 id="闭包原理">闭包原理</h2>
<p><strong>自动实现的函数类型：</strong>
<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>是三个自动实现的闭包trait，分别表示按引用捕获、按可变引用捕获和按值捕获。当闭包捕获变量时，编译器会根据捕获变量的方式自动实现对应的trait：
- 所有的闭包都实现了<code>FnOnce</code> -
无需移动捕获变量的闭包实现了<code>FnMut</code> -
无需可变访问捕获变量的闭包实现了<code>Fn</code></p>
<p><strong>生命周期与闭包：</strong>
闭包可以捕获引用，但是需要保证引用的生命周期超过闭包的生命周期：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">clousre</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"><span class="title function_ invoke__">clousre</span>();  <span class="comment">//正常运行，输出：hello</span></span><br></pre></td></tr></table></figure></p>
<h2 id="move关键字">move关键字</h2>
<p>在参数列表前使用<code>move</code>关键字，可以强制闭包获取其使用的环境变量的所有权，这在将闭包传递给新线程以移动数据时非常有用：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x); <span class="comment">// 编译器会报错，因为x的所有权已经被移动到equal_to_x闭包中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));    <span class="comment">//正常运行</span></span><br></pre></td></tr></table></figure></p>
<h2 id="课后习题">课后习题</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题目：</span></span><br><span class="line"><span class="comment">// 假设你正在开发一个博客系统，其中每个用户可以查看不同的文章页面。页面的渲染是一个计算密集型的过程，可能涉及数据库重访、模板渲染等操作。</span></span><br><span class="line"><span class="comment">// 因此，为了优化性能，你决定在服务端实现一个缓存系统。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求：</span></span><br><span class="line"><span class="comment">//     实现 PageCache 结构体。</span></span><br><span class="line"><span class="comment">//  该结构体应缓存根据用户 ID 和文章 ID 渲染的页面。</span></span><br><span class="line"><span class="comment">//     你需要为该结构体实现一个 get_page 方法，该方法接受用户 ID 和文章 ID，并返回渲染后的页面内容。</span></span><br><span class="line"><span class="comment">//     如果相同的用户 ID 和文章 ID 已经渲染过，则 get_page 应直接返回缓存的页面，而不是重新渲染。</span></span><br><span class="line"><span class="comment">// 通用性：</span></span><br><span class="line"><span class="comment">//     PageCache 应支持任意类型的用户 ID（例如，u32 或 String）和文章 ID。</span></span><br><span class="line"><span class="comment">//     缓存的内容应为渲染后的 HTML 页面（String 类型）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::hash::Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PageCache</span>&lt;F, U, A&gt; </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(&amp;U, &amp;A) <span class="punctuation">-&gt;</span> <span class="type">String</span>,    <span class="comment">// 函数指针或闭包类型</span></span><br><span class="line">    U: Hash + <span class="built_in">Eq</span> + <span class="built_in">Clone</span>,</span><br><span class="line">    A: Hash + <span class="built_in">Eq</span> + <span class="built_in">Clone</span>,</span><br><span class="line">&#123;</span><br><span class="line">    render_fn: F,</span><br><span class="line">    cache: HashMap&lt;(U, A), <span class="type">String</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F, U, A&gt; PageCache&lt;F, U, A&gt; </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(&amp;U, &amp;A) <span class="punctuation">-&gt;</span> <span class="type">String</span>,</span><br><span class="line">    U: Hash + <span class="built_in">Eq</span> + <span class="built_in">Clone</span>,</span><br><span class="line">    A: Hash + <span class="built_in">Eq</span> + <span class="built_in">Clone</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现构造器方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(render_fn: F) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageCache &#123;</span><br><span class="line">            render_fn,</span><br><span class="line">            cache: HashMap::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_page</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, user_id: U, article_id: A) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">key</span> = (user_id, article_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(cached_page) = <span class="keyword">self</span>.cache.<span class="title function_ invoke__">get</span>(&amp;key) &#123;</span><br><span class="line">            cached_page.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rendered_page</span> = (<span class="keyword">self</span>.render_fn)(&amp;key.<span class="number">0</span>, &amp;key.<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">self</span>.cache.<span class="title function_ invoke__">insert</span>(key, rendered_page.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">            rendered_page</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">page_cache</span> = PageCache::<span class="title function_ invoke__">new</span>(|user_id: &amp;<span class="type">String</span>, article_id: &amp;<span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Rendering page for user &#123;&#125; and article &#123;&#125;&quot;</span>, user_id, article_id); <span class="comment">//打印渲染日志</span></span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;Rendered HTML content for user &#123;&#125; and article &#123;&#125;&quot;</span>, user_id, article_id)    <span class="comment">//存储渲染后的页面（在HashMap中）</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, page_cache.<span class="title function_ invoke__">get_page</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user1&quot;</span>), <span class="number">42</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, page_cache.<span class="title function_ invoke__">get_page</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user1&quot;</span>), <span class="number">42</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, page_cache.<span class="title function_ invoke__">get_page</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user2&quot;</span>), <span class="number">42</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/31/rust-macros/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/31/rust-macros/" class="post-title-link" itemprop="url">二十一、Rust进阶-宏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-31 18:36:49" itemprop="dateCreated datePublished" datetime="2024-10-31T18:36:49+08:00">2024-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:44:41" itemprop="dateModified" datetime="2024-11-14T07:44:41+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="宏macros">宏Macros</h1>
<p>在Rust中，宏（Macros）是一种强大的工具，用于生成代码。它们在编译时展开，可以执行复杂的文本操作。</p>
<p>实际上我们早就见到过宏，比如<code>println!</code>、<code>vec!</code>等，这些都是Rust内置的宏，宏在Rust中无处不在：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_common_macros</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>&#123;<span class="string">&quot;Hello, World!&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>[<span class="string">&quot;Hello, World!&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，我们可以发现虽然我们平时使用<code>println!</code>时，是<code>println!("Hello, World!")</code>，但是<code>println!</code>也可以使用<code>&#123;&#125;</code>、<code>[]</code>、<code>&#123;&#125;</code>等作为参数。虽然三种使用方式都正确，但是Rust内置的宏有自己默认的使用方式，如<code>assert_eq!()</code>、<code>panic!()</code>等。</p>
<p><strong>宏分为两类：声明宏（Declarative
Macros）和三种过程宏（Procedural Macros）</strong>： -
<code>#[derive]</code>，在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如
Debug 特征 - 类属性宏(Attribute-like macro)，用于为目标添加自定义的属性
- 类函数宏(Function-like macro)，看上去就像是函数调用</p>
<h2 id="宏和函数的区别">宏和函数的区别</h2>
<p>宏和函数的区别并不少，而且对于宏擅长的领域，函数其实是有些无能为力的。</p>
<h3 id="元编程">元编程</h3>
<p>从根本上说，宏是通过一种代码来生成另一种代码，它和元编程有一定的共同点。</p>
<p>例如<code>derive</code>宏，它可以在编译时自动为结构体派生出相应特征的实现代码。例如<code>#[derive(Debug)]</code>，还有熟悉的<code>println!</code>和<code>vec!</code>，所有的这些宏都会展开成相应的代码，且很可能是长得多的代码。</p>
<p>总之，元编程可以帮我们减少所需编写的代码，也可以一定程度上减少维护的成本，虽然函数复用也有类似的作用，但是宏依然拥有自己独特的优势。</p>
<h3 id="可变参数">可变参数</h3>
<p>Rust
的函数签名是固定的：定义了两个参数，就必须传入两个参数，多一个少一个都不行。</p>
<p>而宏就可以拥有可变数量的参数，例如可以调用一个参数的<code>println!("hello")</code>，也可以调用两个参数的<code>println!("hello &#123;&#125;", name)</code>。</p>
<h3 id="宏展开">宏展开</h3>
<p>由于宏会被展开成其它代码，且这个展开过程是发生在编译器对代码进行解释之前。因此，宏可以为指定的类型实现某个特征：先将宏展开成实现特征的代码后，再被编译。</p>
<p>而函数就做不到这一点，因为它直到运行时才能被调用，而特征需要在编译期被实现。</p>
<h3 id="宏的缺点">宏的缺点</h3>
<p>相对函数来说，由于宏是基于代码再展开成代码，因此实现相比函数来说会更加复杂，再加上宏的语法更为复杂，最终导致定义宏的代码相当地难读，也难以理解和维护。</p>
<p><strong>就是十分难写，十分难懂，十分难维护！！</strong></p>
<h2 id="声明宏">声明宏</h2>
<p>在Rust中最广泛使用的宏就是声明宏，声明宏使用<code>macro_rules!</code>来定义，<code>macro_rules!</code>看起来像是一个函数，但是它和函数没有任何关系，它允许你通过模式匹配来生成代码：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明宏</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> say_hello &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    say_hello!();</span><br><span class="line">    say_hello![];</span><br><span class="line">    say_hello!&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其实上面的例子是一个十分十分简单的声明宏，它没有进行任何的匹配，只是打印了一个固定的语句。</p>
<h3 id="实现简化版的vec">实现简化版的vec!</h3>
<p>在之前动态数组的环节中，我们学习了使用<code>vec!</code>宏来创建动态数组:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
最重要的是，通过<code>vec!</code>创建的动态数组支持任何元素类型，也并没有限制数组的长度，如果使用函数，我们是无法做到这一点的。</p>
<p>现在让我们尝试用<code>macro_rules!</code>来自己实现一个简化版的<code>vec!</code>宏:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ($($e:expr),*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.<span class="title function_ invoke__">push</span>($e);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
即使是简化版本的<code>vec!</code>宏，它还是那么难理解，不过没关系，我们慢慢来。</p>
<p>首先<code>#[macro_export]</code>是用来导出宏的，这样宏就可以在当前crate之外使用。</p>
<p>紧接着我们使用<code>macro_rules!</code>是声明宏的语法，<code>vec!</code>是宏的名称，<code>($($e:expr),*)</code>是模式匹配，跟模式相匹配的代码就在<code>=&gt;</code>后面。</p>
<h3 id="模式解析">模式解析</h3>
<p>现在，让我们来简单地解析一下<code>($($e:expr),*)</code>这个模式：</p>
<p>首先，我们使用圆括号<code>()</code>来将整个宏模式包裹其中，随后是<code>$()</code>，在此括号中跟模式相匹配的值(传入的Rust源代码)会被捕获，然后用于代码替换。在这里，模式
<code>$x:expr</code>
会匹配<strong>任何Rust表达式</strong>并给予该模式一个名称：<code>$x</code>。</p>
<p><code>$()</code> 之后的逗号说明在 <code>$()</code>
所匹配的代码的后面会有一个可选的逗号分隔符，紧随逗号之后的
<code>*</code> 说明 <code>*</code>
之前的模式会被匹配零次或任意多次(类似正则表达式)。</p>
<p>当我们使用 vec![1, 2, 3] 来调用该宏时，$x 模式将被匹配三次，分别是
1、2、3。为了帮助大家巩固，我们再来一起过一下：</p>
<ul>
<li><code>$()</code>中包含的是模式<code>$x:expr</code>，该模式中的<code>expr</code>表示会匹配任何Rust表达式，并给予该模式一个名称<code>$x</code></li>
<li>因此<code>$x</code>模式可以跟整数<code>1</code>进行匹配，也可以跟字符串<code>"hello"</code>进行匹配:<code>vec!["hello", "world"]</code></li>
<li><code>$()</code>之后的逗号，意味着<code>1</code>和<code>2</code>之间可以使用逗号进行分割，也意味着<code>3</code>既可以没有逗号，也可以有逗号：<code>vec![1, 2, 3,]</code></li>
<li><code>*</code>说明之前的模式可以出现零次也可以任意次，这里出现了三次.</li>
</ul>
<p>接下来，让我们再看看与模式相关联，在<code>=&gt;</code>之后所写的代码：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    $(</span><br><span class="line">        temp_vec.<span class="title function_ invoke__">push</span>($e);</span><br><span class="line">    )*</span><br><span class="line">    temp_vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里就比较好理解了，<code>$()</code>中的<code>temp_vec.push()</code>将根据模式匹配的次数生成对应的代码，当调用<code>vec![1, 2, 3]</code>时，下面这段生成的代码将替代传入的源代码，也就是替代<code>vec![1, 2, 3]</code>:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    temp_vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
至此，我们已经能够大致理解这个简化版的<code>vec!</code>宏了。它可以接受任意数量和任意类型的参数，并创建一个包含这些参数的向量。</p>
<h2 id="过程宏">过程宏</h2>
<p>第二种常用的宏就是过程宏（Procedural
Macros），从形式上来看，过程宏跟函数较为相像，但过程宏是使用源代码作为输入参数，基于代码进行一系列操作后，再输出一段全新的代码。<strong>注意，过程宏中的
derive
宏输出的代码并不会替换之前的代码，这一点与声明宏有很大的不同！</strong></p>
<p>至于前文提到的过程宏的三种类型(自定义
derive、属性宏、函数宏)，它们的工作方式都是类似的。</p>
<p>当创建过程宏时，它的定义必须要放入一个独立的包中，且包的类型也是特殊的，必须使用<code>#[proc_macro]</code>属性来标注。过程宏需要放入独立包的原因比较复杂，在于它必须先被编译后才能使用，如果过程宏和使用它的代码在一个包，就必须先单独对过程宏的代码进行编译，然后再对我们的代码进行编译，但悲剧的是
Rust 的编译单元是包，因此你无法做到这一点。</p>
<h3 id="派生宏">派生宏</h3>
<h4 id="派生宏的实现">派生宏的实现</h4>
<p>值得注意的是，在大多数情况下，我们在编写代码的过程中不需要自己定义或者实现宏，我们只需要用好Rust内置的宏即可。</p>
<p>这里，我们简单看一下派生宏的实现： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_macro_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span> = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">HelloMacro</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">hello_macro</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Hello, Macro! My name is &#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
同时，我们还需要在<code>Cargo.toml</code>中添加<code>quote</code>和<code>syn</code>的依赖，以及<code>proc-macro</code>的工具：
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">syn</span> = <span class="string">&quot;2.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure> 实现派生宏真的十分复杂，请在有需要的时候自行查阅文档<a
target="_blank" rel="noopener" href="https://course.rs/advance/macro.html">Rust语言圣经</a></p>
<p>那么，Rust当中有那些已经为我们实现的内置宏呢？常用的有： -
<code>#[derive(Debug)]</code><br />
- <code>#[derive(Clone)]</code> - <code>#[derive(Copy)]</code> -
<code>#[derive(Default)]</code> - <code>#[derive(PartialEq)]</code> -
<code>#[derive(Eq)]</code> - <code>#[derive(Hash)]</code> -
<code>#[derive(PartialOrd)]</code> - <code>#[derive(Ord)]</code></p>
<h3 id="类属性宏">类属性宏</h3>
<p>类属性过程宏跟<code>derive</code>宏类似，但是前者允许我们定义自己的属性。除此之外，<code>derive</code>只能用于结构体和枚举，而类属性宏可以用于其它类型项，例如函数。</p>
<p>假设我们在开发一个web框架，当用户通过<code>HTTP GET</code>请求访问<code>/</code>根路径时，使用<code>index</code>函数为其提供服务:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[route(GET, <span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">index</span>() &#123;</span><br></pre></td></tr></table></figure>
如上所示，代码功能非常清晰、简洁，这里的<code>#[route]</code>属性就是一个过程宏，它的定义函数大概如下：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">route</span>(attr: TokenStream, item: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br></pre></td></tr></table></figure>
与<code>derive</code>宏不同，类属性宏的定义函数有两个参数：</p>
<ul>
<li>第一个参数时用于说明属性包含的内容：<code>Get</code>,
<code>/</code>部分</li>
<li>第二个是属性所标注的类型项，在这里是<code>fn index() &#123;...&#125;</code>，注意，函数体也被包含其中</li>
</ul>
<p>除此之外，类属性宏跟<code>derive</code>宏的工作方式并无区别：创建一个包，类型是<code>proc-macro</code>，接着实现一个函数用于生成想要的代码。</p>
<h3 id="类函数宏">类函数宏</h3>
<p>类函数宏可以让我们定义像函数那样调用的宏，从这个角度来看，它跟声明宏<code>macro_rules</code>较为类似。</p>
<p>区别在于，<code>macro_rules</code>的定义形式与<code>match</code>匹配非常相像，而类函数宏的定义形式则类似于之前讲过的两种过程宏：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sql</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br></pre></td></tr></table></figure> 而使用形式则类似于函数调用： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sql</span> = sql!(SELECT * FROM users);</span><br></pre></td></tr></table></figure></p>
<p>Rust内置的类函数宏有： - <code>assert_eq!</code> -
<code>assert!</code> - <code>println!</code> - <code>vec!</code> -
<code>include_str!</code> // 包含字符串 - <code>env!</code> //
获取环境变量 - <code>concat!</code> // 连接字符串 - <code>format!</code>
// 格式化字符串 - <code>todo!</code> // 生成未实现代码</p>
<h2 id="总结">总结</h2>
<ul>
<li><strong>创建声明宏</strong>：使用<code>macro_rules!</code>定义宏，通过模式匹配生成代码</li>
<li><strong>创建过程宏</strong>：使用过程宏函数<code>#[proc_macro]</code>、派生宏<code>#[proc_macro_attribute]</code>和属性宏<code>#[proc_macro_derive]</code>生成代码</li>
</ul>
<p>宏的使用场景： 1.
<strong>减少重复代码</strong>：宏可以减少重复代码，提高代码的复用性 2.
<strong>编译期计算</strong>：宏可以在编译期进行复杂的计算，减少运行时的开销
3.
<strong>DSL（领域特定语言）</strong>：宏可以用于创建领域特定语言，提高代码的表达力和可读性</p>
<h2 id="课后作业">课后作业</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求：</span></span><br><span class="line"><span class="comment">// 通过`macro_rules!`宏实现对应的marco，并通过测试case</span></span><br><span class="line"><span class="comment">// assert_eq!(repeat!(&quot;x&quot;, 3), &quot;xxx&quot;);</span></span><br><span class="line"><span class="comment">// assert_eq!(sum!(1, 2, 3, 4, 5), 15);</span></span><br><span class="line"><span class="comment">// assert_eq!(max_value!(1, 8, 9), 9);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> repeat &#123;</span><br><span class="line">    ($item:expr, $n:expr) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..$n &#123;</span><br><span class="line">                result.<span class="title function_ invoke__">push_str</span>(&amp;$item);</span><br><span class="line">            &#125;</span><br><span class="line">            result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> sum &#123;</span><br><span class="line">    ($($x:expr),*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">            $(</span><br><span class="line">                sum += $x;</span><br><span class="line">            )*</span><br><span class="line">            sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> max_value &#123;</span><br><span class="line">    ($first:expr, $($rest:expr),*) =&gt; &#123; <span class="comment">//需要分别处理第一个值和剩余值，第一个值用于初始化sum</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max</span> = $first; </span><br><span class="line">            $(</span><br><span class="line">                <span class="keyword">if</span> $rest &gt; max &#123;</span><br><span class="line">                    max = $rest;</span><br><span class="line">                &#125;</span><br><span class="line">            )*</span><br><span class="line">            max</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(repeat!(<span class="string">&quot;x&quot;</span>, <span class="number">3</span>), <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum!(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(max_value!(<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>

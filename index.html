<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Wobujiaoxyy3">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Wobujiaoxyy3">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Wobujiaoxyy3</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wobujiaoxyy3</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/27/solana-simple-socialfi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/27/solana-simple-socialfi/" class="post-title-link" itemprop="url">Solana小项目：简易SocialFi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-27 22:36:50 / Modified: 22:55:08" itemprop="dateCreated datePublished" datetime="2024-11-27T22:36:50+00:00">2024-11-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简易SocialFi"><a href="#简易SocialFi" class="headerlink" title="简易SocialFi"></a>简易SocialFi</h1><p>在这里，我们需要完成一个简易的SocialFi项目，其中包含以下功能：</p>
<ul>
<li>初始化用户</li>
<li>关注用户</li>
<li>取消关注</li>
<li>查询关注列表</li>
<li>发帖</li>
<li>查询帖子</li>
</ul>
<p>将功能转化为需要实现的指令：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">SocialInstruction</span> &#123;</span><br><span class="line">    InitializeUser&#123;seed_type: <span class="type">String</span>&#125;,</span><br><span class="line">    FollowUser&#123;user_to_follow: Pubkey&#125;,</span><br><span class="line">    UnfollowUser&#123;user_to_unfollow: Pubkey&#125;,</span><br><span class="line">    QueryFollows,</span><br><span class="line">    PostContent&#123;content: <span class="type">String</span>&#125;,</span><br><span class="line">    QueryPosts,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>接下来，让我们在<code>processor.rs</code>中具体实现每一个指令对应的操作，首先，导入相应的包并定义主函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br><span class="line"><span class="keyword">use</span> solana_program::&#123;</span><br><span class="line">    account_info::&#123;next_account_info, AccountInfo&#125;, address_lookup_table::&#123;instruction, state::ProgramState&#125;, borsh1::try_from_slice_unchecked, entrypoint::ProgramResult, lamports, msg, program::&#123;invoke, invoke_signed&#125;, program_error::ProgramError, pubkey::Pubkey, system_instruction, system_program, sysvar::&#123;rent::Rent, Sysvar&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> spl_associated_token_account::tools::account;</span><br><span class="line"><span class="keyword">use</span> crate::instruction::*;</span><br><span class="line"><span class="keyword">use</span> crate::state::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一些常量</span></span><br><span class="line"><span class="keyword">const</span> PUBKEY_SIZE: <span class="type">usize</span> = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">const</span> U16_SIZE: <span class="type">usize</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> USER_PROFILE_SIZE: <span class="type">usize</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> MAX_FOLLOWER_COUNT: <span class="type">usize</span> = <span class="number">200</span>;  <span class="comment">//最大关注者数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> USER_POST_SIZE: <span class="type">usize</span> = <span class="number">8</span>;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Processor</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    <span class="comment">//定义主函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">process_instruction</span>(</span><br><span class="line">        program_id: &amp;Pubkey,</span><br><span class="line">        accounts: &amp;[AccountInfo],</span><br><span class="line">        instruction_data: &amp;[<span class="type">u8</span>],</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">        <span class="comment">//解序列化指令</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">instruction</span> = SocialInstruction::<span class="title function_ invoke__">try_from_slice</span>(instruction_data)?;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配传入的指令</span></span><br><span class="line">        <span class="keyword">match</span> instruction &#123;</span><br><span class="line">            SocialInstruction::InitializeUser &#123; seed_type &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">Self</span>::<span class="title function_ invoke__">initialize_user</span>(program_id, accounts, seed_type)</span><br><span class="line">            &#125;</span><br><span class="line">            SocialInstruction::FollowUser &#123; user_to_follow &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">Self</span>::<span class="title function_ invoke__">follow_user</span>(accounts, user_to_follow)</span><br><span class="line">            &#125;</span><br><span class="line">            SocialInstruction::QueryFollows =&gt; &#123;</span><br><span class="line">                <span class="keyword">Self</span>::<span class="title function_ invoke__">query_follows</span>(accounts)</span><br><span class="line">            &#125;</span><br><span class="line">            SocialInstruction::UnfollowUser &#123; user_to_unfollow &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">Self</span>::<span class="title function_ invoke__">unfollow_user</span>(accounts, user_to_unfollow)</span><br><span class="line">            &#125;</span><br><span class="line">            SocialInstruction::PostContent &#123; content &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">Self</span>::<span class="title function_ invoke__">post_content</span>(program_id, accounts, content)</span><br><span class="line">            &#125;</span><br><span class="line">            SocialInstruction::QueryPosts =&gt; &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(下面写的比较随意，见谅)</p>
<h3 id="state-rs和一些简单函数"><a href="#state-rs和一些简单函数" class="headerlink" title="state.rs和一些简单函数"></a>state.rs和一些简单函数</h3><p>在实现简易SocialFi的过程中，我们需要一些特定的账户来为我们存储一些数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> solana_program::pubkey::Pubkey;</span><br><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> data_len: <span class="type">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span> follows: <span class="type">Vec</span>&lt;Pubkey&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UserPost</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> post_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> timestamp: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            data_len: <span class="number">0</span>,</span><br><span class="line">            follows: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">follow</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, user_to_follow: Pubkey) &#123;</span><br><span class="line">        <span class="keyword">self</span>.follows.<span class="title function_ invoke__">push</span>(user_to_follow);</span><br><span class="line">        <span class="keyword">self</span>.data_len = <span class="keyword">self</span>.follows.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">u16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unfollow</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, user_to_unfollow: Pubkey) &#123;</span><br><span class="line">        <span class="keyword">self</span>.follows.<span class="title function_ invoke__">retain</span>(|&amp;x| x != user_to_unfollow);</span><br><span class="line">        <span class="keyword">self</span>.data_len = <span class="keyword">self</span>.follows.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">u16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">UserPost</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            post_count: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_post</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.post_count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_count</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.post_count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(content: <span class="type">String</span>, timestamp: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            content,</span><br><span class="line">            timestamp,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，我们还需要一些定义一些简单的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义计算账户占用空间的函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">compute_profile_space</span>(pubkey_count: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> USER_PROFILE_SIZE + pubkey_count * PUBKEY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义将字节转化为u16的函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">bytes_to_u16</span>(bytes: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u16</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> bytes.<span class="title function_ invoke__">len</span>() != <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>; <span class="comment">//确保输入是2个字节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">array</span> = [<span class="number">0u8</span>; <span class="number">2</span>];</span><br><span class="line">    array.<span class="title function_ invoke__">copy_from_slice</span>(bytes);</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">u16</span>::<span class="title function_ invoke__">from_le_bytes</span>(array))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InitializeUser"><a href="#InitializeUser" class="headerlink" title="InitializeUser"></a>InitializeUser</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义initialize_user方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">initialize_user</span>(program_id: &amp;Pubkey, accounts: &amp;[AccountInfo], seed_type: <span class="type">String</span>) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="comment">//获取账户信息</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配传入的seed以创建不同的账户</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">seed</span> = <span class="keyword">match</span> seed_type.<span class="title function_ invoke__">as_str</span>() &#123;</span><br><span class="line">        <span class="string">&quot;profile&quot;</span> =&gt; <span class="string">&quot;profile&quot;</span>, </span><br><span class="line">        <span class="string">&quot;post&quot;</span> =&gt; <span class="string">&quot;post&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ProgramError::InvalidArgument),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;seed: &#123;:?&#125;&quot;</span>, seed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用find_program_address方法，生成PDA账户（bump_seed用于防止生成账户重复）</span></span><br><span class="line">    <span class="keyword">let</span> (pda, bump_seed) = Pubkey::<span class="title function_ invoke__">find_program_address</span>(&amp;[user_account.key.<span class="title function_ invoke__">as_ref</span>(), seed.<span class="title function_ invoke__">as_bytes</span>()], program_id);</span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;pda: &#123;:?&#125;&quot;</span>, pda);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证传入的PDA账户是否与程序中生成的匹配，如果一致，则说明传入的PDA账户正确,否则报错</span></span><br><span class="line">    <span class="keyword">if</span> pda != pda_account.key.<span class="title function_ invoke__">clone</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="title function_ invoke__">Err</span>(ProgramError::InvalidArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前区块链的租金参数（rent是sysvar中的参数）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rent</span>= Rent::<span class="title function_ invoke__">get</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算该账户所需的存储空间大小</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">space</span> = <span class="keyword">match</span> seed_type.<span class="title function_ invoke__">as_str</span>() &#123;</span><br><span class="line">        <span class="string">&quot;profile&quot;</span> =&gt; <span class="title function_ invoke__">compute_profile_space</span>(MAX_FOLLOWER_COUNT),</span><br><span class="line">        <span class="string">&quot;post&quot;</span> =&gt; USER_POST_SIZE, </span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ProgramError::InvalidArgument),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据账户所需的存储空间，计算创建账户的最低租金金额</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lamports</span> = rent.<span class="title function_ invoke__">minimum_balance</span>(space);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建create_account_ix指令</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">create_account_ix</span> = system_instruction::<span class="title function_ invoke__">create_account</span>(</span><br><span class="line">        user_account.key,</span><br><span class="line">        &amp;pda,</span><br><span class="line">        lamports,</span><br><span class="line">        space <span class="keyword">as</span> <span class="type">u64</span>,</span><br><span class="line">        program_id</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用invoke调用函数</span></span><br><span class="line">    <span class="title function_ invoke__">invoke_signed</span>(</span><br><span class="line">        &amp;create_account_ix,</span><br><span class="line">        &amp;[</span><br><span class="line">            user_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            pda_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        ],</span><br><span class="line">        &amp;[&amp;[user_account.key.<span class="title function_ invoke__">as_ref</span>(), seed.<span class="title function_ invoke__">as_bytes</span>(), &amp;[bump_seed]]],     <span class="comment">//需要签名</span></span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续匹配传入的seed以决定对user_profile账户或user_post账户进行初始化</span></span><br><span class="line">     <span class="keyword">match</span> seed_type.<span class="title function_ invoke__">as_str</span>() &#123;</span><br><span class="line">        <span class="string">&quot;profile&quot;</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">user_profile</span> = UserProfile::<span class="title function_ invoke__">new</span>();  <span class="comment">//初始化UserProfile</span></span><br><span class="line">            user_profile.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> *pda_account.<span class="title function_ invoke__">try_borrow_mut_data</span>()?)?;  <span class="comment">//通过serialize方法将UserProfile传入PDA账户中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;post&quot;</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">user_post</span> = UserPost::<span class="title function_ invoke__">new</span>();    <span class="comment">//初始化UserPost</span></span><br><span class="line">            user_post.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> *pda_account.<span class="title function_ invoke__">try_borrow_mut_data</span>()?)?; <span class="comment">//通过serialize方法将UserPost传入PDA账户中</span></span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ProgramError::InvalidArgument),</span><br><span class="line">    &#125;;</span><br><span class="line">    msg!(<span class="string">&quot;User init success&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FollowUser"><a href="#FollowUser" class="headerlink" title="FollowUser"></a>FollowUser</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义follow_user方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">follow_user</span>(accounts: &amp;[AccountInfo], user_to_follow: Pubkey) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算size</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">size</span>: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = &amp;pda_account.data.<span class="title function_ invoke__">borrow</span>();  <span class="comment">//提取存储在PDA账户中data的内容</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = &amp;data[..U16_SIZE];    <span class="comment">//提取UserProfile结构体中的data_len字段（前两个字节）</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pubkey_count</span> = <span class="title function_ invoke__">bytes_to_u16</span>(len).<span class="title function_ invoke__">unwrap</span>();  <span class="comment">//将data_len字段从字节转换为u16类型，获取该PDA账户关注的数量</span></span><br><span class="line">        size = <span class="title function_ invoke__">compute_profile_space</span>(pubkey_count <span class="keyword">as</span> <span class="type">usize</span>);    <span class="comment">//通过关注的数量计算该PDA账户所需的存储字节数</span></span><br><span class="line">        msg!(<span class="string">&quot;size is &#123;:?&#125;&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user_profile</span> = UserProfile::<span class="title function_ invoke__">try_from_slice</span>(&amp;pda_account.data.<span class="title function_ invoke__">borrow</span>()[..size])?;    <span class="comment">//通过之前计算的存储字节数提取链上PDA账户的UserProfile（需要精确计算存储字节数，否则会报错）</span></span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;user_profile is &#123;:?&#125;&quot;</span>, user_profile);</span><br><span class="line"></span><br><span class="line">    user_profile.<span class="title function_ invoke__">follow</span>(user_to_follow);    <span class="comment">//通过一个follow方法对UserProfile进行更新，添加关注者</span></span><br><span class="line"></span><br><span class="line">    user_profile.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> *pda_account.<span class="title function_ invoke__">try_borrow_mut_data</span>()?)?;  <span class="comment">//将更新好的UserProfile重新导入到链上PDA账户的data中</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QueryFollow"><a href="#QueryFollow" class="headerlink" title="QueryFollow"></a>QueryFollow</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义query_follows方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">query_follows</span>(accounts: &amp;[AccountInfo]) <span class="punctuation">-&gt;</span> ProgramResult&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一种比较简便的方法，从PDA账户的data中读取UserProfile</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_profile</span> = try_from_slice_unchecked::&lt;UserProfile&gt;(&amp;pda_account.data.<span class="title function_ invoke__">borrow</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取好UserProfile并打印出来</span></span><br><span class="line">    msg!(<span class="string">&quot;user_profile is &#123;:?&#125;&quot;</span>, user_profile);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UnfollowUser"><a href="#UnfollowUser" class="headerlink" title="UnfollowUser"></a>UnfollowUser</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义unfollow_user方法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unfollow_user</span>(accounts: &amp;[AccountInfo], user_to_unfollow: Pubkey) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不计算size会报错</span></span><br><span class="line">    <span class="comment">//let mut user_profile = UserProfile::try_from_slice(&amp;pda_account.data.borrow())?;</span></span><br><span class="line"></span><br><span class="line">    user_profile.<span class="title function_ invoke__">unfollow</span>(user_to_unfollow);</span><br><span class="line"></span><br><span class="line">    user_profile.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> *pda_account.<span class="title function_ invoke__">try_borrow_mut_data</span>()?)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PostContent"><a href="#PostContent" class="headerlink" title="PostContent"></a>PostContent</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义post_content方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">post_content</span>(program_id: &amp;Pubkey, accounts: &amp;[AccountInfo], content: <span class="type">String</span>) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post_pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(account_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前时间戳</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">clock</span> = Clock::<span class="title function_ invoke__">get</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">timestamp</span> = clock.unix_timestamp <span class="keyword">as</span> <span class="type">u64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取链上账户中的UserPost数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user_post</span> = try_from_slice_unchecked::&lt;UserPost&gt;(&amp;pda_account.data.<span class="title function_ invoke__">borrow</span>())?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等同于id增长</span></span><br><span class="line">    user_post.<span class="title function_ invoke__">add_post</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一种将数据写到链上账户的方法</span></span><br><span class="line">    user_post.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> &amp;<span class="keyword">mut</span> pda_account.data.<span class="title function_ invoke__">borrow_mut</span>())?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最新的post_count</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = user_post.<span class="title function_ invoke__">get_count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成一个新的pda账户，用于存放Post</span></span><br><span class="line">    <span class="keyword">let</span> (pda, bump_seed) = Pubkey::<span class="title function_ invoke__">find_program_address</span>(</span><br><span class="line">        &amp;[</span><br><span class="line">            user_account.key.<span class="title function_ invoke__">as_ref</span>(),</span><br><span class="line">            <span class="string">&quot;post&quot;</span>.<span class="title function_ invoke__">as_bytes</span>(),</span><br><span class="line">            &amp;[count <span class="keyword">as</span> <span class="type">u8</span>],</span><br><span class="line">        ],</span><br><span class="line">        program_id,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据内容和时间戳创建新的post</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post</span> = Post::<span class="title function_ invoke__">new</span>(content, timestamp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rent</span> = Rent::<span class="title function_ invoke__">get</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">space</span> = borsh::<span class="title function_ invoke__">to_vec</span>(&amp;post).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lamports</span> = rent.<span class="title function_ invoke__">minimum_balance</span>(space);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成新账户的指令</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">create_account_ix</span> = &amp;system_instruction::<span class="title function_ invoke__">create_account</span>(</span><br><span class="line">        user_account.key,</span><br><span class="line">        &amp;post_pda_account,</span><br><span class="line">        lamports, </span><br><span class="line">        space <span class="keyword">as</span> <span class="type">u64</span>,</span><br><span class="line">        program_id,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用invoke执行命令</span></span><br><span class="line">    <span class="title function_ invoke__">invoke_signed</span>(</span><br><span class="line">        create_account_ix,</span><br><span class="line">        &amp;[</span><br><span class="line">            user_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            post_pda_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            system_program.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">        ],</span><br><span class="line">        &amp;[&amp;[</span><br><span class="line">            user_account.key.<span class="title function_ invoke__">as_ref</span>(),</span><br><span class="line">            <span class="string">&quot;post&quot;</span>.<span class="title function_ invoke__">as_bytes</span>(),</span><br><span class="line">            &amp;[count <span class="keyword">as</span> <span class="type">u8</span>],</span><br><span class="line">            &amp;[bump_seed],</span><br><span class="line">        ]]</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新的post内容写入新建的post_pda账户中</span></span><br><span class="line">    post.<span class="title function_ invoke__">serialize</span>(&amp;<span class="keyword">mut</span> *post_pda_account.<span class="title function_ invoke__">try_borrow_mut_data</span>()?)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QueryPost"><a href="#QueryPost" class="headerlink" title="QueryPost"></a>QueryPost</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询帖子</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">query_posts</span>(accounts: &amp;[AccountInfo]) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">accounts_into_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_into_iter)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post_pda_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_into_iter)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_post</span> = try_from_slice_unchecked::&lt;UserPost&gt;(&amp;pda_account.data.<span class="title function_ invoke__">borrow</span>())?;</span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;user_post: &#123;:?&#125;&quot;</span>, user_post);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post</span> = try_from_slice_unchecked::&lt;Post&gt;(&amp;post_pda_account.data.<span class="title function_ invoke__">borrow</span>())?;</span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;post: &#123;:?&#125;, at &#123;:?&#125;&quot;</span>, post.content, post.timestamp); </span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/23/solana-SPL-token/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/23/solana-SPL-token/" class="post-title-link" itemprop="url">solana-SPL-token</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-23 10:09:34" itemprop="dateCreated datePublished" datetime="2024-11-23T10:09:34+00:00">2024-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-27 22:36:57" itemprop="dateModified" datetime="2024-11-27T22:36:57+00:00">2024-11-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SPL-Token合约"><a href="#SPL-Token合约" class="headerlink" title="SPL-Token合约"></a>SPL-Token合约</h1><p>为了更加了解如何使用Rust在Solana上部署合约并使用合约，我们完成了一个SPL-token的合约练习，该合约包含了两个内容：<br>    - CreateToken创建代币<br>    - Mint铸造代币</p>
<h2 id="项目文件的基本结构"><a href="#项目文件的基本结构" class="headerlink" title="项目文件的基本结构"></a>项目文件的基本结构</h2><p>我们首先使用<code>cargo new --lib token</code>来创建该项目，此时该项目的<code>src</code>文件夹下只有<code>lib.rs</code>文件。此时，我们需要在继续创建如下文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--lib.rs (创建时就有)</span><br><span class="line">--processor.rs</span><br><span class="line">--instruction.rs</span><br><span class="line">--state.rs</span><br><span class="line">--error.rs</span><br></pre></td></tr></table></figure>
<p>其中：<br>    - <code>lib.rs</code>是项目的入口文件，定义程序的主要逻辑模块。<br>    - <code>processor.rs</code>通过定义<code>process()</code>函数，实现程序的核心逻辑处理。<br>    - <code>instruction.rs</code>用于定义程序可以处理的指令类型。<br>    - <code>state.rs</code>用于定义程序中持久化的账户数据结构和逻辑。<br>    -  <code>error.rs</code>用于自定义程序中的错误类型。</p>
<h2 id="导入基本依赖"><a href="#导入基本依赖" class="headerlink" title="导入基本依赖"></a>导入基本依赖</h2><p>在开始写代码前，我们还需要使用<code>cargo add</code>命令来导入该项目所需的依赖：<code>solana-program</code>、<code>spl-associated-token-account</code>、<code>spl-token</code>。最后，<code>Cargo.toml</code>文件的内容如下所示：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = <span class="string">&quot;token&quot;</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">edition = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">borsh = <span class="string">&quot;1.5.1&quot;</span></span><br><span class="line">solana-program = <span class="string">&quot;=2.0.10&quot;</span></span><br><span class="line">spl-associated-token-account = &#123;version = <span class="string">&quot;5.0.1&quot;</span>, features = [<span class="string">&quot;no-entrypoint&quot;</span>]&#125;</span><br><span class="line">spl-token = &#123;version = <span class="string">&quot;6.0.0&quot;</span>, features = [<span class="string">&quot;no-entrypoint&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">[lib]</span><br><span class="line">crate-type = [<span class="string">&quot;cdylib&quot;</span>, <span class="string">&quot;lib&quot;</span>]</span><br><span class="line"></span><br><span class="line">[features]</span><br><span class="line">no-entrypoint = []</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们为<code>spl-associated-token-account</code>和<code>spl-token</code>赋予了<code>no-entrypoint</code>的特征。这是因为，使用<code>Rust</code>开发<code>Solana</code>程序时，<code>entrypoint</code>是程序的主要入口点，用于接收外部传入的指令和参数。在默认情况下，<code>Solana</code>的框架会期望程序有一个入口点，以便处理事务请求。然而，有些模块（例如<code>spl-associated-token-account</code>或<code>spl-token</code>）并不是一个独立的程序，而是为其他程序提供功能的库，因此它们不需要一个默认的入口点。</p>
<p>正因为此，我们需要为<code>spl-associated-token-account</code>和<code>spl-token</code>赋予了<code>no-entrypoint</code>的特征，用于禁用这些依赖的默认入口点，避免不必要的代码运行。</p>
<p>同时，我们添加了<code>cdylib</code>，这是一种用于生成动态库的目标类型，它是为了与外部的非Rust代码交互设计的。Solana可以使用动态库来部署程序，使其运行在链上。</p>
<h2 id="着手写代码"><a href="#着手写代码" class="headerlink" title="着手写代码"></a>着手写代码</h2><p>在理清了一个Solana项目的基本结构后，我们就可以开始着手写代码了。首先，让我们看一下<code>lib.rs</code>的基本架构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入需要的库</span></span><br><span class="line"><span class="keyword">use</span> solana_program::&#123;</span><br><span class="line">    entrypoint,</span><br><span class="line">    entrypoint::ProgramResult,</span><br><span class="line">    pubkey::Pubkey,</span><br><span class="line">    account_info::AccountInfo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> spl_token::state::Account;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//导入processor.rs 、 instruction.rs</span></span><br><span class="line"><span class="keyword">mod</span> processor; </span><br><span class="line"><span class="keyword">mod</span> instruction;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入Processor类型</span></span><br><span class="line"><span class="keyword">use</span> crate::processor::Processor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义程序的入口点为process_instruction</span></span><br><span class="line">entrypoint!(process_instruction);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义程序的入口函数，符合solana的标准接口</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_instruction</span>(</span><br><span class="line">    program_id: &amp;Pubkey,    <span class="comment">//当前程序的公钥</span></span><br><span class="line">    accounts: &amp;[AccountInfo],   <span class="comment">//调用指令时传递的账户信息数组</span></span><br><span class="line">    instruction_data: &amp;[<span class="type">u8</span>],    <span class="comment">//调用时的输入数据（指令和参数）</span></span><br><span class="line">) <span class="punctuation">-&gt;</span> ProgramResult &#123;    <span class="comment">//返回ProgramResult， 表示程序的执行结果</span></span><br><span class="line">    Processor::<span class="title function_ invoke__">process</span>(program_id, accounts, instruction_data)  <span class="comment">//调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面<code>lib.rs</code>的代码是Solana程序的标准框架。首先，我们引入了一堆需要的库。</p>
<p>其次，使用了<code>mod processor</code>和<code>mod instruction</code>分别声明了<code>processor</code>模块和<code>instruction</code>模块，分别用于负责核心逻辑的实现和定义与程序交互的指令。之后使用<code>use crate::processor::Processor;</code>引入<code>Processor</code>类型，这是在<code>processor</code>模块中定义的核心逻辑处理器。它通常包含一个静态方法<code>process</code>，用于根据传入的指令数据解析并调用对应的逻辑。</p>
<p>随后，使用<code>entrypoint!()</code>宏用于定义程序的入口点为<code>process_instruction</code>。当Solana程序在链上运行时，会从该入口点开始执行，传入<code>program_id</code>、<code>accounts</code>、<code>instruction_data</code>参数。</p>
<p>最后，定义程序的入口函数<code>process_instruction</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">process_instruction</span>(</span><br><span class="line">    program_id: &amp;Pubkey,</span><br><span class="line">    accounts: &amp;[AccountInfo],</span><br><span class="line">    instruction_data: &amp;[<span class="type">u8</span>],</span><br><span class="line">) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    Processor::<span class="title function_ invoke__">process</span>(program_id, accounts, instruction_data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它需要传入三个参数：第一个是当前智能合约的地址；第二个是调用指令时所需要传递的账户信息；第三个是具体的指令和参数。该函数返回一个ProgramResult结果，表示程序的执行结果。该函数内部调用了另一个函数:<code>Processor::process(program_id, accounts, instruction_data)</code>，这个函数具体执行了指令，是整个智能合约的关键。</p>
<h2 id="指令Instruction"><a href="#指令Instruction" class="headerlink" title="指令Instruction"></a>指令Instruction</h2><p>在具体深入<code>Processor::process</code>前，让我们先看看这个合约需要实现的指令：<br>    - CreateToken创建代币<br>    - Mint铸造代币</p>
<p>我们将其写进<code>instruction.rs</code>中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">TokenInstruction</span> &#123;</span><br><span class="line">    CreateToken&#123;decimals: <span class="type">u8</span>&#125;,</span><br><span class="line">    Mint&#123;amount: <span class="type">u64</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面，我们定义了一个<code>TokenInstruction</code>枚举来存储我们的两个指令。该<code>TokenInstruction</code>枚举实现了<code>BorshDeserialize</code>和<code>BorshSerialize</code>。这是因为在区块链中，所有数据（包括指令）都以字节流<code>byte stream</code>的形式在节点之间传输。因此指令需要实现序列化，以将指令转化为字节流，以便在区块链上传播；同时需要实现反序列化，将字节流还原为程序可以识别和操作的结构化数据。</p>
<h2 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h2><p><code>processor.rs</code>中具体实现了<code>process</code>函数，首先导入了必要的库：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> solana_program::&#123;</span><br><span class="line">    account_info::&#123;next_account_info, AccountInfo&#125;, address_lookup_table::instruction, entrypoint::ProgramResult, msg, program::&#123;invoke, invoke_signed&#125;, pubkey::Pubkey, system_instruction, sysvar::&#123;rent::Rent, Sysvar&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> spl_associated_token_account::instruction::create_associated_token_account;</span><br><span class="line"><span class="keyword">use</span> spl_token::&#123;instruction::&#123;initialize_mint, mint_to&#125;, state::Mint&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::instruction::TokenInstruction;</span><br><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br></pre></td></tr></table></figure>

<p>其次，定义了一个空的结构体<code>Processor</code>，用于封装<code>process</code>函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Processor</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">process</span>(</span><br><span class="line">        program_id: &amp;Pubkey,</span><br><span class="line">        accounts: &amp;[AccountInfo],</span><br><span class="line">        instruction_data: &amp;[<span class="type">u8</span>],</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">instruction</span> = TokenInstruction::<span class="title function_ invoke__">try_from_slice</span>(instruction_data)?;</span><br><span class="line">        <span class="keyword">match</span> instruction &#123;</span><br><span class="line">            TokenInstruction::CreateToken &#123; decimals &#125; =&gt; <span class="keyword">Self</span>::<span class="title function_ invoke__">create_token</span>(accounts, decimals),</span><br><span class="line">            TokenInstruction::Mint &#123; amount &#125; =&gt; <span class="keyword">Self</span>::<span class="title function_ invoke__">mint_token</span>(accounts, amount),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的<code>process</code>函数中，首先使用了<code>try_from_slice</code>方法将<code>instruction_data</code>解序列化为实际的指令，随后对指令进行模式匹配，对不同的指令执行不同的操作。接下来，我们需要针对两个不同的指令：<code>CreateToken</code>和<code>Mint</code>，构建不同的函数以实现指令。</p>
<h3 id="CreatToken"><a href="#CreatToken" class="headerlink" title="CreatToken"></a>CreatToken</h3><p>让我们先针对<code>CreateToken</code>指令实现<code>create_token</code>函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">create_token</span>(accounts: &amp;[AccountInfo], decimals: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> ProgramResult &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>首先，该函数接收必须的账号信息<code>accounts</code>和需要创建的token的精度<code>decimal</code>两个参数，并返回一个<code>ProgramResult</code>结果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;   </span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_authority</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rent_sysvar</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br></pre></td></tr></table></figure>
<p>随后，将传入的账号信息数组转化为迭代器，并依次提取出程序所需的账户信息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg!(<span class="string">&quot;Creating mint account...&quot;</span>);</span><br><span class="line">msg!(<span class="string">&quot;Mint account is &#123;&#125;&quot;</span>, mint_account.key);</span><br></pre></td></tr></table></figure>
<p>打印日志，表明正在创建代币的Mint账户。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">create_account_ix</span> = &amp;system_instruction::<span class="title function_ invoke__">create_account</span>(</span><br><span class="line">    payer.key,</span><br><span class="line">    mint_account.key,</span><br><span class="line">    (Rent::<span class="title function_ invoke__">get</span>()?).<span class="title function_ invoke__">minimum_balance</span>(<span class="number">82</span>),</span><br><span class="line">    <span class="number">82</span>,</span><br><span class="line">    token_program.key,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">invoke</span>(</span><br><span class="line">    create_account_ix,</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在这之后，调用了<code>system_instrucion::create_account</code>方法，创建一个<code>create_account_ix</code>指令，该指令是solana系统指令中的创建账户指令。随后，使用<code>invoke()</code>调用该指令（传入必要的账户信息），实现了创建账户这一个操作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">mint_init_ix</span> = <span class="title function_ invoke__">initialize_mint</span>(</span><br><span class="line">    token_program.key,</span><br><span class="line">    mint_account.key,</span><br><span class="line">    mint_authority.key,</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    decimals,</span><br><span class="line">)?;</span><br><span class="line"></span><br><span class="line">msg!(<span class="string">&quot;initialize_mint account...&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">invoke_signed</span>(</span><br><span class="line">    &amp;mint_init_ix,</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        rent_sysvar.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        mint_authority.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ],</span><br><span class="line">    &amp;[],</span><br><span class="line">)?;</span><br></pre></td></tr></table></figure>
<p>之后，我们又调用了<code>system_instrucion::initialize_mint</code>方法，创建一个<code>mint_init_ix</code>指令，该指令是solana系统指令中的初始化Mint账户指令。随后，使用<code>invoke()</code>调用该指令（传入必要的账户信息），将我们刚刚创建的账户初始化为一个Mint账户。<code>Mint Account</code>是一种代币的根账户，控制该代币的生成、销毁和管理。每种代币对应一个<code>Mint Account</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg!(<span class="string">&quot;SPL Token Mint create success&quot;</span>);</span><br><span class="line">         </span><br><span class="line"><span class="title function_ invoke__">Ok</span>(()) </span><br></pre></td></tr></table></figure>
<p>最后，打印日志<code>SPL Token Mint create success</code>表明成功创建了一个SPL Token Mint account，并返回<code>Ok(())</code>。</p>
<h3 id="Mint"><a href="#Mint" class="headerlink" title="Mint"></a>Mint</h3><p>在成功创建完了一个Mint账户之后，让我们来构建<code>mint_token</code>函数来Mint一定数量的代币到指定的账户中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mint_token</span>(accounts: &amp;[AccountInfo], amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> ProgramResult &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该函数需要我们传入相关账户信息以及需要mint的代币数量，并返回一个<code>ProgramResult</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">associated_token_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rent_sysvar</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">associated_token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;</span><br><span class="line"></span><br><span class="line">msg!(<span class="string">&quot;ATA is &#123;:?&#125;&quot;</span>, associated_token_account);</span><br></pre></td></tr></table></figure>
<p>同上一个函数一样，从传入的账户信息中匹配相对应的账户地址，并打印日志。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> associated_token_account.<span class="title function_ invoke__">lamports</span>() == <span class="number">0</span> &#123;</span><br><span class="line">    msg!(<span class="string">&quot;Creating associated token account ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">create_ata_ix</span> = &amp;spl_associated_token_account::instruction::<span class="title function_ invoke__">create_associated_token_account</span>(</span><br><span class="line">        payer.key, </span><br><span class="line">        payer.key, </span><br><span class="line">        mint_account.key, </span><br><span class="line">        token_program.key,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">invoke</span>(</span><br><span class="line">        create_ata_ix,</span><br><span class="line">        &amp;[</span><br><span class="line">            payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            associated_token_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            rent_sysvar.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            associated_token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        ]</span><br><span class="line">    )?;</span><br></pre></td></tr></table></figure>
<p>首先，确认传入的地址中是否存在余额，如果没有余额，则表明该账户尚未被创建过，可以继续进行下面的操作将其初始化为一个ata账户。接下来，创建一个<code>create_associated_token_account</code>的指令，并使用<code>invoke()</code>函数调用它，生成一个ata账户。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">mint_ix</span> = &amp;<span class="title function_ invoke__">mint_to</span>(</span><br><span class="line">    token_program.key,</span><br><span class="line">    mint_account.key,</span><br><span class="line">    associated_token_account.key,</span><br><span class="line">    payer.key,</span><br><span class="line">    &amp;[payer.key],</span><br><span class="line">    amount</span><br><span class="line">)?;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">invoke</span>(</span><br><span class="line">    mint_ix,</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        associated_token_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">msg!(<span class="string">&quot;Tokens minted to ata&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>之后，再创建一个<code>mint_to</code>指令，表示需要将一定数量的代币mint出来并转账至给定的ata账户中，并使用<code>invoke()</code>函数调用它，完成该指令。</p>
<p>至此，我们就成功构建了两个指令的具体操作函数，完成了这一份智能合约。</p>
<h2 id="CLI调用"><a href="#CLI调用" class="headerlink" title="CLI调用"></a>CLI调用</h2><p>接下来，我们构建一个cli来调用我们刚刚创建好的SPL-Token智能合约:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> borsh::&#123;BorshDeserialize, BorshSerialize&#125;;</span><br><span class="line"><span class="keyword">use</span> solana_client::rpc_client::&#123;<span class="keyword">self</span>, RpcClient&#125;;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::account::Account;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::address_lookup_table::instruction;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::instruction::&#123;AccountMeta, Instruction&#125;;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::signature::read_keypair_file;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::pubkey::Pubkey;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::signer::keypair::Keypair;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::transaction::Transaction;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::signer::Signer;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::sysvar;</span><br><span class="line"><span class="keyword">use</span> spl_associated_token_account_client::address::get_associated_token_address;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(BorshDeserialize, BorshSerialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">TokenInstruction</span> &#123;</span><br><span class="line">    CreateToken&#123;decimals: <span class="type">u8</span>&#125;,</span><br><span class="line">    Mint&#123;amount: <span class="type">u64</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们导入必要的库，以及需要调用的指令。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_fn</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rpc_client</span> = RpcClient::<span class="title function_ invoke__">new</span>(<span class="string">&quot;http://127.0.0.1:8899&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">read_keypair_file</span>(<span class="string">&quot;/Users/wbjxyy/.config/solana/id.json&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">program_id</span> = Pubkey::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;6SorUwdvqsn2LUsZp7zKHiQSVkWydBpStBgGyn7MBBwD&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mint_account</span> = Keypair::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;mint_account is : &#123;&#125;&quot;</span>, mint_account.<span class="title function_ invoke__">pubkey</span>().<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    _ = <span class="title function_ invoke__">create_token</span>(&amp;rpc_client, &amp;program_id, &amp;payer, &amp;mint_account, &amp;payer.<span class="title function_ invoke__">pubkey</span>(), <span class="number">6</span>);</span><br><span class="line">    _ = <span class="title function_ invoke__">mint</span>(&amp;rpc_client, &amp;program_id, &amp;payer, &amp;mint_account, <span class="number">100_000_000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后我们构建一个测试函数：</p>
<ul>
<li>首先，使用<code>RpcClient</code>方法，创建了一个连接到本地Solana节点的客户端（<code>http://127.0.0.1:8899</code>是本地Solana节点的RPC地址，默认端口为8899），该方法返回了一个<code>RpcClient</code>对象，后续可以使用该对象调用链上方法。</li>
<li>其次，我们使用<code>read_keypair_file</code>方法从文件中读取出一个密钥对(<code>KeyPair</code>)，作为交易签名者，并支付相应的交易费用。</li>
<li>这之后，通过<code>Pubkey::from_str</code>读取我们先前就部署好的SPL-Token合约。</li>
<li>再通过<code>Keypair::new()</code>创建一个全新的账户，用于后续将其初始化为Mint账户</li>
<li>最后，分别调用<code>create_token</code>和<code>mint</code>两个函数（不是合约里的两个）。</li>
</ul>
<h3 id="CLI中的create-token函数"><a href="#CLI中的create-token函数" class="headerlink" title="CLI中的create_token函数"></a>CLI中的<code>create_token</code>函数</h3><p>之后，我们再创建一个<code>create_token</code>函数，用于模仿在实际操作中调用SPL-Token合约中的<code>CreateToken</code>指令：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">create_token</span>(</span><br><span class="line">    rpc_client: &amp;RpcClient,</span><br><span class="line">    program_id: &amp;Pubkey,</span><br><span class="line">    payer: &amp;Keypair,</span><br><span class="line">    mint_account: &amp;Keypair, </span><br><span class="line">    mint_authority: &amp;Pubkey,    <span class="comment">//铸造权限地址，这个地址有权铸造代币</span></span><br><span class="line">    decimals: <span class="type">u8</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>首先，该函数接收如上六个参数，其中一个是<code>&amp;RpcClient</code>客户端，一个是<code>decimals</code>代表Token的精度，剩下四个均是账户信息，对应合约中需要传入的<code>&amp;[AccountInfo]</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">instruction_data</span> = borsh::<span class="title function_ invoke__">to_vec</span>(&amp;TokenInstruction::CreateToken &#123; decimals &#125;).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>
<p>先指定要调用的指令为<code>CreateToken</code>并将其序列化。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new</span>(mint_account.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(*mint_authority, <span class="literal">false</span>),</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(payer.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">false</span>),</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(sysvar::rent::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(solana_sdk::system_program::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_token::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>将传入该函数的账户信息参数转化为合约中<code>create_token</code>函数所需的账户信息参数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">token_instruction</span> = Instruction&#123;</span><br><span class="line">    program_id: *program_id,</span><br><span class="line">    accounts,</span><br><span class="line">    data: instruction_data,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将需要调用的合约地址，对应的账户信息以及指令打包成一个指令。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">latest_blockhash</span> = rpc_client.<span class="title function_ invoke__">get_latest_blockhash</span>()?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">tx</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">    &amp;[token_instruction],</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>()),      <span class="comment">//交易费用支付者的公钥</span></span><br><span class="line">    &amp;[payer, mint_account],     <span class="comment">//用于签署交易的签名者数组</span></span><br><span class="line">    latest_blockhash</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>获取最新的blockhash, 并创建一个包含上面指令的交易。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送交易并等待确认</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = rpc_client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;tx)?;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;create token successfully&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">Ok</span>(())</span><br></pre></td></tr></table></figure>
<p>发送交易并等待确认。</p>
<h3 id="CLI中的mint函数"><a href="#CLI中的mint函数" class="headerlink" title="CLI中的mint函数"></a>CLI中的<code>mint</code>函数</h3><p><code>mint</code>函数的逻辑与<code>create_token</code>函数基本一致，这里只展示代码，不再过多赘述：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mint</span>(</span><br><span class="line">    rpc_client: &amp;RpcClient,</span><br><span class="line">    program_id: &amp;Pubkey,</span><br><span class="line">    payer: &amp;Keypair,</span><br><span class="line">    mint_account: &amp;Keypair, </span><br><span class="line">    amount: <span class="type">u64</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据payer的公钥和mint_account的公钥创建一个ata账户</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ata</span> = <span class="title function_ invoke__">get_associated_token_address</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>(), &amp;mint_account.<span class="title function_ invoke__">pubkey</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ata is &#123;&#125;&quot;</span>, ata.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">instruction_data</span> = borsh::<span class="title function_ invoke__">to_vec</span>(&amp;TokenInstruction::Mint &#123; amount &#125;).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">accounts</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new</span>(mint_account.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new</span>(ata, <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(sysvar::rent::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new</span>(payer.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(solana_sdk::system_program::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_token::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_associated_token_account::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),</span><br><span class="line"></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">token_instruction</span> = Instruction&#123;</span><br><span class="line">        program_id: *program_id,</span><br><span class="line">        accounts,</span><br><span class="line">        data: instruction_data,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">latest_blockhash</span> = rpc_client.<span class="title function_ invoke__">get_latest_blockhash</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">        &amp;[token_instruction],</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>()),</span><br><span class="line">        &amp;[payer, mint_account],</span><br><span class="line">        latest_blockhash</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送交易并等待确认</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = rpc_client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;tx)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;mint token successfully&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/02/rust-concurrency2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/02/rust-concurrency2/" class="post-title-link" itemprop="url">Rust进阶-并发2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-02 12:36:24" itemprop="dateCreated datePublished" datetime="2024-11-02T12:36:24+00:00">2024-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-13 23:43:16" itemprop="dateModified" datetime="2024-11-13T23:43:16+00:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>在上一节课中，我们学习了消息传递并发模型，消息传递并发模型通过通道（channel）在多个线程之间传递消息，从而实现并发。而实际上我们还可以通过<strong>共享内存</strong>的方式来实现并发。 </p>
<p>在通过通道进行通信时，我们实际上是在通过消息传递的方式进行通信，这种方式类似于<strong>所有权</strong>，一旦我们将值的所有权转移至Channel中，我们就无法再使用该值。而共享内存并发则类似于多所有权，多个线程可以同时读写同一块内存。</p>
<h2 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h2><p>互斥锁<code>Mutex</code>是Rust标准库提供的用于共享内存的并发原语。它是<code>multipule exlusion</code>的缩写，意为<strong>多线程互斥</strong>。<code>Mutex</code>让多个线程并发的访问同一个值变成了排队访问：同一时间，只允许一个线程<code>A</code>访问该值，其他线程<code>B</code>则需要等待线程<code>A</code>访问结束。</p>
<p>如果想要访问数据：</p>
<ul>
<li>线程<code>A</code>需要先获取<code>Mutex</code>的锁(<code>lock</code>)，只有获取到锁，才能访问数据。</li>
<li>lock数据结构是<code>Mutex</code>的一部分，它能跟踪谁对数据拥有独占访问权</li>
<li><code>mutex</code>通常被描述为：通过锁定系统来保护它所持有的数据</li>
</ul>
<h2 id="Mutex-的两条规则"><a href="#Mutex-的两条规则" class="headerlink" title="Mutex 的两条规则"></a>Mutex 的两条规则</h2><ul>
<li>在使用数据之前，必须尝试获取锁（<code>lock</code>）</li>
<li>在使用完<code>mutex</code>所保护的数据后，必须释放锁（<code>unlock</code>），以便其他的线程可以获取锁</li>
</ul>
<h2 id="使用-Mutex"><a href="#使用-Mutex" class="headerlink" title="使用 Mutex"></a>使用 Mutex</h2><h3 id="单线程中使用Mutex"><a href="#单线程中使用Mutex" class="headerlink" title="单线程中使用Mutex"></a>单线程中使用Mutex</h3><p>让我们通过一个例子来看看单线程中如何使用<code>Mutex</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个Mutex智能指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// lock返回的是Result类型</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">// 离开作用域时，自动释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;&#125;&quot;</span>, m);  <span class="comment">// 打印结果为：m = Mutex &#123; data: 6 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码示例中，我们使用<code>Mutex::new(5)</code>创建了一个<code>Mutex</code>智能指针，并将其初始值设置为5。接着，我们使用了<code>m.lock()</code>方法来为<code>m</code>申请一个<strong>锁</strong>，并将其赋值给<code>num</code>。该方法会阻塞当前线程，直到获取到锁。因此当多个线程同时访问该数据时，只有一个线程能获取到锁，其它线程只能阻塞着等待，这样就保证了数据能被安全的修改！</p>
<p><code>m.lock()</code>方法也有可能返回一个错误，例如当前正在持有锁的线程<code>panic</code>了。在这种情况下，其它线程不可能再获得锁，因此<code>lock</code>方法会返回一个错误。</p>
<p>实际上，<code>lock</code>方法返回的是一个<code>MutexGuard</code>类型的智能指针，它实现了<code>Deref</code>特征，因此我们可以像解引用一个常规的指针一样，直接访问<code>Mutex</code>中的数据。同时，它还实现了<code>Drop</code>特征，当<code>MutexGuard</code>离开作用域时，会自动释放锁，因此不需要我们手动调用<code>unlock</code>方法。</p>
<h3 id="多线程中使用-Mutex"><a href="#多线程中使用-Mutex" class="headerlink" title="多线程中使用 Mutex"></a>多线程中使用 Mutex</h3><p>让我们先来看下面一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个Mutex智能指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建10个线程，每个线程将计数器加1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的的代码中，我们试图创建一个被<code>Mutex</code>保护的计数器，并创建了10个线程，每个线程将计数器加<code>1</code>。最后，打印出计数器的值。但很遗憾的是，这段代码并不能正常工作。原因在于<code>counter</code>变量已经被<code>move</code>移动到了线程中，主线程无法再访问该变量。</p>
<p>那么，我们之前学过<code>Rc&lt;T&gt;</code>智能指针，它允许我们在多个地方共享所有权。那么，我们是否可以用<code>Rc&lt;Mutex&lt;T&gt;&gt;</code>来解决这个问题呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 通过`Rc`实现`Mutex`的多所有权</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="comment">// 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有子线程完成</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终的计数结果</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，由于子线程需要通过<code>move</code>拿走锁的所有权，因此我们需要使用多所有权来保证每个线程都拿到数据的独立所有权，从而避免主线程无法访问<code>counter</code>变量。但是，遗憾又来了，当我们运行该程序时，会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">                // `Rc`无法在线程中安全的传输</span><br><span class="line">   --&gt; src/main.rs:11:22</span><br><span class="line">    |</span><br><span class="line">13  |           let handle = thread::spawn(move || &#123;</span><br><span class="line">    |  ______________________^^^^^^^^^^^^^_-</span><br><span class="line">    | |                      |</span><br><span class="line">    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">14  | |             let mut num = counter.lock().unwrap();</span><br><span class="line">15  | |</span><br><span class="line">16  | |             *num += 1;</span><br><span class="line">17  | |         &#125;);</span><br><span class="line">    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`</span><br><span class="line">    |</span><br><span class="line">    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`</span><br><span class="line">     // `Rc`没有实现`Send`特征</span><br><span class="line">    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`</span><br></pre></td></tr></table></figure>
<p>上面的错误信息告诉我们，<code>Rc</code>没有实现<code>Send</code>特征，因此无法在线程间安全的传输。这听起来有点难理解，<code>Rc</code>不是线程安全的吗？单线程中，<code>Rc</code>确实可以安全的进行使用，但是当<code>Rc</code>被用在多线程中时，就会变得不安全。原因在于<code>Rc</code>本身是不可变的，它无法自动更新引用计数，因此当多个线程同时修改引用计数时，就会导致数据不一致的问题。想象一下，如果一个线程正在修改引用计数，而另一个线程正在读取引用计数，那么就会导致数据不一致的问题。</p>
<h4 id="多线程安全的Arc"><a href="#多线程安全的Arc" class="headerlink" title="多线程安全的Arc&lt;T&gt;"></a>多线程安全的<code>Arc&lt;T&gt;</code></h4><p><code>Arc&lt;T&gt;</code>是<code>Rc&lt;T&gt;</code>的多线程版本，它通过<code>Atomic</code>原子操作实现了线程安全的引用计数。因此，我们可以使用<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>来替代<code>Rc&lt;Mutex&lt;T&gt;&gt;</code>，从而解决多线程中<code>Mutex</code>的问题。值得注意的是，<code>Arc</code>与<code>Rc</code>的API基本一致，因此我们可以直接将<code>Rc</code>替换为<code>Arc</code>。</p>
<p>那么就引出了一个问题，为什么所有的基础类型都不是原子的，为什么标准库类型不默认使用<code>Arc</code>呢？原因在于实现原子性需要额外的性能开销。</p>
<p>接下来，让我们使用<code>Arc&lt;T&gt;</code>来实现多线程中<code>Mutex</code>的访问：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以顺利运行，打印结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result: 10</span><br></pre></td></tr></table></figure>

<h3 id="Rc-RefCell-Versus-Arc-Mutex"><a href="#Rc-RefCell-Versus-Arc-Mutex" class="headerlink" title="Rc&lt;T&gt;&#x2F;RefCell&lt;T&gt; Versus Arc&lt;T&gt;&#x2F;Mutex&lt;T&gt;"></a><code>Rc&lt;T&gt;</code>&#x2F;<code>RefCell&lt;T&gt;</code> Versus <code>Arc&lt;T&gt;</code>&#x2F;<code>Mutex&lt;T&gt;</code></h3><ul>
<li><code>Mutex&lt;T&gt;</code>也提供了内部可变性，和<code>RefCell&lt;T&gt;</code>类似，但是<code>Mutex&lt;T&gt;</code>需要在访问数据之前先获取锁，因此性能上不如<code>RefCell&lt;T&gt;</code>。</li>
<li>我们使用<code>RefCell&lt;T&gt;</code>来改变<code>Rc&lt;T&gt;</code>里面的内容。</li>
<li>我们使用<code>Mutex&lt;T&gt;</code>来改变<code>Arc&lt;T&gt;</code>里面的内容。</li>
<li><code>Mutex&lt;T&gt;</code>有死锁的风险。</li>
</ul>
<h2 id="Send和Sync特征"><a href="#Send和Sync特征" class="headerlink" title="Send和Sync特征"></a><code>Send</code>和<code>Sync</code>特征</h2><ul>
<li><code>Send</code>特征：允许在线程间安全的传输数据</li>
<li><code>Sync</code>特征：允许在线程间安全的共享数据</li>
</ul>
<p>Rust语言中，所有基本类型都实现了<code>Send</code>和<code>Sync</code>特征，因此它们在线程间可以安全的传输和共享。但是，这并不是Rust语言本身的特性，而是来自标准库。 </p>
<h3 id="Send：允许在线程间安全的转移所有权"><a href="#Send：允许在线程间安全的转移所有权" class="headerlink" title="Send：允许在线程间安全的转移所有权"></a>Send：允许在线程间安全的转移所有权</h3><p><code>Send</code>特征允许在线程间安全的转移所有权。如果一个类型实现了<code>Send</code>特征，那么它就可以被安全的移动到另一个线程中。Rust中几乎所有的类型都实现了<code>Send</code>特征，除了<code>Rc&lt;T&gt;</code>。</p>
<p>任何完全由<code>Send</code>类型组成的类型也是<code>Send</code>类型。<br>除了原始指针（<code>*T</code>）之外，所有指针都实现了<code>Send</code>特征。</p>
<h3 id="Sync：允许在线程间安全的共享数据"><a href="#Sync：允许在线程间安全的共享数据" class="headerlink" title="Sync：允许在线程间安全的共享数据"></a>Sync：允许在线程间安全的共享数据</h3><p><code>Sync</code>特征允许在线程间安全的共享数据，也即多线程访问。如果一个类型实现了<code>Sync</code>特征，那么它就可以安全的被多个线程引用。也就是说：</p>
<ul>
<li>如果<code>T</code>实现了<code>Sync</code>，那么<code>&amp;T</code>就是<code>Send</code>。</li>
<li>所有<code>Send</code>类型都实现了<code>Sync</code>。</li>
<li>基础类型都实现了<code>Sync</code>，因此任何完全由<code>Sync</code>类型组成的类型也实现了<code>Sync</code>。</li>
<li><code>Rc&lt;T&gt;</code>没有实现<code>Sync</code>，<code>RefCell&lt;T&gt;</code>和<code>Cell&lt;T&gt;</code>也没有实现<code>Sync</code>。</li>
<li>而<code>Mutex&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>都实现了<code>Sync</code>。</li>
</ul>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务描述</span></span><br><span class="line"><span class="comment">// 你需要缩写一个简单的多线程任务调度器，它能够接收多个任务，并将这些任务分发到多个工作线程中执行。调度器使用 Channel 进行任务的分发和结果的收集。你需要使用 Rust 的 Send 和 Sync 特性来确保任务调度器在多线程环境中的安全性。</span></span><br><span class="line"><span class="comment">// 具体要求</span></span><br><span class="line"><span class="comment">// 任务结构：</span></span><br><span class="line"><span class="comment">// 定义一个 Task 结构体，表示需要执行的任务。任务包含一个唯一的 id 和一个用于执行的闭包。</span></span><br><span class="line"><span class="comment">// 调度器结构：</span></span><br><span class="line"><span class="comment">// 创建一个 Scheduler 结构体，包含一个任务队列和一个线程池。调度器应当使用 channel 来分发任务到不同的工作线程。</span></span><br><span class="line"><span class="comment">// 功能实现：</span></span><br><span class="line"><span class="comment">// 调度器应当具有以下功能:</span></span><br><span class="line"><span class="comment">// 添加任务：向调度器添加一个任务。</span></span><br><span class="line"><span class="comment">// 启动调度器：启动多个线程，开始从任务队列中获取任务并执行。</span></span><br><span class="line"><span class="comment">// 获取结果：在所有任务完成后，收集并打印每个任务的执行结果。</span></span><br><span class="line"><span class="comment">// 多线程安全：</span></span><br><span class="line"><span class="comment">// 通过使用 Arc 和 Mutex 确保任务队列在多个线程之间的安全访问。</span></span><br><span class="line"><span class="comment">// 确保任务的结果能够正确地在线程之间传递和收集。</span></span><br><span class="line"><span class="comment">// 问题提示：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列：</span></span><br><span class="line"><span class="comment">// 使用 Mutex 来保护任务队列，确保多个线程不会同时修改队列中的数据。</span></span><br><span class="line"><span class="comment">// 使用 Arc 来共享任务队列的所有权，使得多个线程能够访问同一个任务队列。</span></span><br><span class="line"><span class="comment">// 任务分发：</span></span><br><span class="line"><span class="comment">// 使用 channel 来将任务的完成状态发送回主线程，从而可以在主线程中收集和打印任务完成的结果。</span></span><br><span class="line"><span class="comment">// 线程池：</span></span><br><span class="line"><span class="comment">// 通过循环创建多个工作线程，每个线程从任务队列中取出任务并执行。线程池的大小可以通过 Scheduler 的构造函数来指定</span></span><br><span class="line"><span class="comment">// 任务执行：</span></span><br><span class="line"><span class="comment">// 每个任务都应该是一个闭包，使用 Box&lt;dyn FnOnce()&gt;将其存储在 Task 结构体中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;mpsc, Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    task_id: <span class="type">usize</span>,</span><br><span class="line">    job: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;,    <span class="comment">// 任务闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>&lt;F&gt;(task_id: <span class="type">usize</span>, job: F) <span class="punctuation">-&gt;</span> Task </span><br><span class="line">    <span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        Task &#123;</span><br><span class="line">            task_id,</span><br><span class="line">            job: <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(job),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">    tasks: Arc&lt;Mutex&lt;VecDeque&lt;Task&gt;&gt;&gt;,    <span class="comment">// 任务队列，VecDeque是双端队列</span></span><br><span class="line">    num_workers: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(num_workers: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Scheduler &#123;</span><br><span class="line">            tasks: Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(VecDeque::<span class="title function_ invoke__">new</span>())),</span><br><span class="line">            num_workers,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_task</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, task_id: <span class="type">usize</span>, job: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tasks</span> = <span class="keyword">self</span>.tasks.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        tasks.<span class="title function_ invoke__">push_back</span>(Task::<span class="title function_ invoke__">new</span>(task_id, job));   <span class="comment">// 将任务添加到任务队列的末尾</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">activate</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">worker_id</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="keyword">self</span>.num_workers &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tasks</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.tasks);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tx</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">            thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">task_opt</span> = &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tasks</span> = tasks.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    tasks.<span class="title function_ invoke__">pop_front</span>()</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = task_opt &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; is executing task &#123;&#125;&quot;</span>, worker_id, task.task_id);</span><br><span class="line">                    (task.job)();</span><br><span class="line">                    tx.<span class="title function_ invoke__">send</span>(task.task_id).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(task_id) = rx.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Task &#123;&#125; completed&quot;</span>, task_id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;All tasks are completed.&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建调度器，指定线程池大小为 4</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scheduler</span> = Scheduler::<span class="title function_ invoke__">new</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到调度器</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        scheduler.<span class="title function_ invoke__">add_task</span>(i, <span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Executing task &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>)); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动调度器，开始执行任务</span></span><br><span class="line">    scheduler.<span class="title function_ invoke__">activate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;All tasks have been processed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/02/rust-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/02/rust-concurrency/" class="post-title-link" itemprop="url">二十五、Rust进阶-并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-02 01:03:11" itemprop="dateCreated datePublished" datetime="2024-11-02T01:03:11+00:00">2024-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-13 23:43:02" itemprop="dateModified" datetime="2024-11-13T23:43:02+00:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="并发-Concurrency"><a href="#并发-Concurrency" class="headerlink" title="并发 Concurrency"></a>并发 Concurrency</h1><p>安全和高效的处理并发是Rust语言的主要目标之一。随着现代处理器的核心数不断增加，并发和并行已经成为日常编程不可或缺的一部分，甚至于Go语言已经将并发简化到一个<code>go</code>关键字就可以。</p>
<p>可惜的是，在Rust中由于语言设计理念、安全、性能的多方面考虑，并没有采用Go语言大道至简的方式，而是选择了多线程与<code>async/await</code>相结合，优点是可控性更强、性能更高，缺点是复杂度并不低，当然这也是系统级语言的应有选择：使用复杂度换取可控性和性能。</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发（Concurrency）和并行（Parallelism）是两个非常相似的概念，虽然我们平时统称并发与并行为并发，但它们之间存在一些细微的差别。</p>
<p>并发是指系统能够同时处理多个任务的能力，这些任务可能处于不同的状态，但它们共享同一个处理器。并发通常涉及任务的切换和调度，使得多个任务虽然在时间上交替执行，但是看起来就像是同时运行的。</p>
<p>并行则是指系统能够同时执行多个任务的能力，这些任务在不同的处理器上运行，每个任务都占用一个独立的处理器。并行通常涉及任务的分配和执行，使得多个任务看起来是同时运行的。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>在大多数的操作系统OS中，代码运行在进程（process）中，OS同时管理里面的多个进程。</p>
<p>在我们的程序中，各独立部分可以同时运行，运行这些独立部分的就是线程（thread）。</p>
<h3 id="多线程运行"><a href="#多线程运行" class="headerlink" title="多线程运行"></a>多线程运行</h3><p>多线程运行可以提升程序的性能表现，但是也会增加复杂度，无法保障各线程的执行顺序，同时带来安全问题：</p>
<ul>
<li>竞态条件（Race Condition）：多个线程以非一致性的顺序同时访问数据资源，导致数据不一致。</li>
<li>死锁（Deadlock）：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。</li>
<li>活锁（Livelock）：多个线程不断尝试解决冲突，但始终无法成功，导致所有线程都无法继续执行。</li>
<li>一些因为多线程导致的很隐晦的BUG，难以复现并解决。</li>
</ul>
<h2 id="实现线程的方式"><a href="#实现线程的方式" class="headerlink" title="实现线程的方式"></a>实现线程的方式</h2><p>不同语言对于线程的实现大相径庭：</p>
<ul>
<li>由于操作系统提供了创建线程的API，因此部分语言会直接调用该 API 来创建线程，因此最终程序内的线程数和该程序占用的操作系统线程数相等，一般称之为<strong>1:1线程模型</strong>，例如 Rust。这种设计的优点是运行时（runtime）较小。<br>-还有些语言在内部实现了自己的线程模型（绿色线程、协程），程序内部的 M 个线程最后会以某种映射方式使用 N 个操作系统线程去运行，因此称之为<strong>M:N线程模型</strong>，其中 M 和 N 并没有特定的彼此限制关系。一个典型的代表就是 Go 语言。这种设计则需要较大的运行时。<br>-还有些语言使用了 Actor 模型，基于消息传递进行并发，例如 Erlang 语言。</li>
</ul>
<h2 id="在Rust中创建线程"><a href="#在Rust中创建线程" class="headerlink" title="在Rust中创建线程"></a>在Rust中创建线程</h2><p>在Rust中，我们可以使用<code>thread::spawn</code>函数来创建线程：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123; <span class="comment">// 子线程，主线程结束时，子线程也会结束</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123; <span class="comment">// 主线程，在i=4时，主线程结束</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几点值得注意：</p>
<ul>
<li>线程内部的代码使用闭包来执行。</li>
<li><code>main</code>线程一旦结束，程序就立刻结束，因此需要保持它的存活，直到其它子线程完成自己的任务。在上面的代码中，主线程在<code>i=4</code>时，子线程还在运行，因此会输出<code>hi number 5 from the spawned thread!</code>，但是之后主线程结束，子线程也会结束。</li>
<li><code>thread::sleep</code>会让当前线程休眠指定的时间，随后其它线程会被调度运行，因此就算你的电脑只有一个 CPU 核心，该程序也会表现的如同多 CPU 核心一般，这就是并发！</li>
</ul>
<p>让我们来看一下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 4 from the main thread!</span><br><span class="line">hi number 5 from the spawned thread!</span><br></pre></td></tr></table></figure>
<p>如果多运行几次，你会发现好像每次输出会不太一样，因为：虽说线程往往是轮流执行的，但是这一点无法被保证！线程调度的方式往往取决于你使用的操作系统。总之，<strong>千万不要依赖线程的执行顺序</strong>。</p>
<h3 id="等待子线程结束"><a href="#等待子线程结束" class="headerlink" title="等待子线程结束"></a>等待子线程结束</h3><p>在上面的代码中，我们发现了一个问题，就是当主线程结束时，子线程也将随之立刻结束。那如果我们想要让上面的子线程从1顺序打印到9，该怎么做呢？</p>
<p>此时我们可以通过<code>join</code>方法来等待子线程结束。<code>thread::spawn</code>的返回值是一个<code>JoinHandle</code>，它是一个智能指针，可以让我们等待线程的结束。<code>JoinHandle</code>持有值的所有权，调用其<code>join</code>方法时，会阻塞当前线程，直到对应的线程结束。</p>
<p><code>join</code>方法：调用<code>handle.join()</code>会阻塞当前线程的运行，直到<code>handle</code>对应的线程终结。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>hanle.join</code>返回的是<code>Option</code>类型的值，因此我们需要使用<code>unwrap</code>来解包。在上面的代码中，我们在子线程后添加了<code>handle.join().unwrap()</code>，此时<code>main</code>线程会被阻塞，直到子线程结束之后才会自己输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 4 from the main thread!</span><br></pre></td></tr></table></figure>
<p>以上输出清晰的展示了线程阻塞的作用。</p>
<h3 id="在线程闭包中使用move"><a href="#在线程闭包中使用move" class="headerlink" title="在线程闭包中使用move"></a>在线程闭包中使用move</h3><p>在先前的闭包章节中，我们有讲过<code>move</code>关键字在闭包中的使用可以让该闭包拿走环境中某个值的所有权，同样地，你可以使用<code>move</code>来将值的所有权从一个线程转移到另外一个线程。</p>
<p>首先，来看看在一个线程中直接使用另一个线程中的数据会如何：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，子线程中的闭包捕获了主线程中的变量<code>v</code>，让我们来看一下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function</span><br><span class="line"> --&gt; src/main.rs:6:32</span><br><span class="line">  |</span><br><span class="line">6 |     let handle = thread::spawn(|| &#123;</span><br><span class="line">  |                                ^^ may outlive borrowed value `v`</span><br><span class="line">7 |         println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">  |                                           - `v` is borrowed here</span><br><span class="line">  |</span><br><span class="line">note: function requires argument type to outlive `&#x27;static`</span><br><span class="line"> --&gt; src/main.rs:6:18</span><br><span class="line">  |</span><br><span class="line">6 |       let handle = thread::spawn(|| &#123;</span><br><span class="line">  |  __________________^</span><br><span class="line">7 | |         println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">8 | |     &#125;);</span><br><span class="line">  | |______^</span><br><span class="line">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword</span><br><span class="line">  |</span><br><span class="line">6 |     let handle = thread::spawn(move || &#123;</span><br><span class="line">  |                                ++++</span><br></pre></td></tr></table></figure>
<p>其实上述代码本身并没有问题，问题在于 Rust 无法确定新的线程会活多久（多个线程的结束顺序并不是固定的），所以也无法确定新线程所引用的<code>v</code> 是否在使用过程中一直合法。</p>
<p>因此，我们需要使用<code>move</code>关键字来将<code>v</code>的所有权转移到子线程中，这样子线程就可以随意使用<code>v</code>了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要记住，线程的启动时间点和结束时间点是不确定的，如果我们不添加<code>move</code>关键字，那么主线程中的<code>v</code>可能会在子线程结束之前被释放，导致子线程无法正常使用。</p>
<h1 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h1><p>在多线程间有多种方式可以共享、传递数据。</p>
<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>一种很流行且能保证安全并发的技术就是：<strong>消息传递</strong>。线程(<code>Actor</code>)通过彼此发送消息（数据）来进行通信。</p>
<p>在Go语言中有一句很经典的话：<strong>Don’t communicate by sharing memory, share memory by communicating</strong>。</p>
<p>与Go语言内置的<code>chan</code>不同，Rust 是在标准库里提供了消息通道(<code>channel</code>)。</p>
<h3 id="消息通道Channel"><a href="#消息通道Channel" class="headerlink" title="消息通道Channel"></a>消息通道Channel</h3><p>消息通道(<code>channel</code>)是Rust标准库提供的一种线程间通信机制，它可以让多个线程之间安全地传递数据，它由两部分组成：发送端(<code>Sender</code>)和接收端(<code>Receiver</code>)。</p>
<p>调用<code>channel</code>的<code>send</code>方法可以发送消息，调用<code>Receiver</code>的<code>recv</code>方法可以检查和接收到达的消息。</p>
<p>如果发送端或者接收端中的任意一端被丢弃了，那么<code>channel</code>就会被关闭，此时<code>recv</code>方法会返回一个错误。</p>
<p>显而易见的是，一个通道应该支持多个发送者和接收者。但是，在实际使用通道的过程中，我们需要使用不同的通道类型来满足诸如：</p>
<ul>
<li>单个发送者和单个接收者</li>
<li>多个发送者和单个接收者</li>
<li>单个发送者和多个接收者</li>
<li>多个发送者和多个接收者<br>的多个应用场景。让我们先从<strong>多发送者，单接收者</strong>的场景开始讲起：</li>
</ul>
<h3 id="多发送者，单接收者"><a href="#多发送者，单接收者" class="headerlink" title="多发送者，单接收者"></a>多发送者，单接收者</h3><p>标准库提供了通道<code>std::sync::mpsc</code>，其中<code>mpsc</code>是<code>multiple producer, single consumer</code>的缩写，代表了该通道支持多个发送者，但是只支持唯一的接收者。<br>需要注意的是，支持了多个发送者，自然也就支持了单个发送者。</p>
<p>我们可以使用<code>mspc::channel</code>函数来创建一个通道，这个函数会返回一个元组，元组中第一个元素是发送端，第二个元素是接收端：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个消息通道, 返回一个元组：(发送者，接收者)</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程，并发送消息</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// 发送一个数字1, send方法返回Result&lt;T,E&gt;，通过unwrap进行快速错误处理</span></span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option&lt;i32&gt;类型将产生不匹配错误</span></span><br><span class="line">        <span class="comment">// tx.send(Some(1)).unwrap()</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中接收子线程发送的消息并输出</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们再来解读下上面的代码：</p>
<ul>
<li><code>tx</code>,<code>rx</code>对应发送者和接收者，它们的类型由编译器自动推导: <code>tx.send(1)</code>发送了整数，因此它们分别是<code>mpsc::Sender&lt;i32&gt;</code>和<code>mpsc::Receiver&lt;i32&gt;</code>类型，需要注意，由于内部是泛型实现，一旦类型被推导确定，该通道就只能传递对应类型的值, 例如此例中非<code>i32</code>类型的值将导致编译错误。</li>
<li><code>send</code>方法发送想要发送的数据，并返回<code>Result&lt;T,E&gt;</code>，如果发送失败，则返回<code>Err</code>，成功则返回<code>Ok</code>。</li>
<li><code>recv</code>方法会阻止当前线程的执行，直到它从通道中接收到消息，就会返回<code>Result&lt;T,E&gt;</code>，如果接收失败，则返回<code>Err</code>，成功则返回<code>Ok</code>。</li>
</ul>
<h3 id="不阻塞的try-recv方法"><a href="#不阻塞的try-recv方法" class="headerlink" title="不阻塞的try_recv方法"></a>不阻塞的<code>try_recv</code>方法</h3><p>在上面的代码中，我们使用了<code>recv</code>方法，该方法会阻塞当前线程，直到接收到消息。如果我们不希望阻塞当前线程，可以使用<code>try_recv</code>方法，该方法不会阻塞当前线程，而是立即返回<code>Result&lt;T,E&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;:?&#125;&quot;</span>, rx.<span class="title function_ invoke__">try_recv</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于子线程的创建需要时间，因此<code>println!</code>和<code>try_recv</code>方法会先执行，而此时子线程的消息还未被发出。<code>try_recv</code>会尝试立即读取一次消息，因为消息没有发出，此次读取最终会报错，且主线程运行结束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receive Err(Empty)</span><br></pre></td></tr></table></figure>
<p>如上，<code>try_recv</code>返回了一个错误，错误内容是Empty，代表通道并没有消息。如果你尝试把<code>println!</code>复制一些行，就会发现一个有趣的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">receive Err(Empty)</span><br><span class="line">receive Ok(1)</span><br><span class="line">receive Err(Disconnected)</span><br></pre></td></tr></table></figure>
<p>如上，当子线程创建成功且发送消息后，主线程会接收到<code>Ok(1)</code>的消息内容，紧接着子线程结束，发送者也随着被<code>drop</code>，此时接收者又会报错，但是这次错误原因有所不同：<code>Disconnected</code>代表发送者已经被关闭。</p>
<p>从上面的例子中，我们可以得出一个启示：通常需要使用循环调用来检查<code>try_recv</code>的结果。</p>
<h3 id="mspc-sender-clone"><a href="#mspc-sender-clone" class="headerlink" title="mspc::sender::clone"></a><code>mspc::sender::clone</code></h3><p>在上面的例子中，我们始终使用了单发送者，单接受者的通道。如果我们需要多个发送者，该怎么做呢？</p>
<p>标准库为我们提供了<code>clone</code>方法，可以克隆发送者：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx1</span> = mpsc::Sender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx2</span> = mpsc::Sender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line"></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    tx1.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx2.<span class="title function_ invoke__">send</span>(<span class="number">2</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;:?&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;:?&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 课后习题1：实现多线程文件处理器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// •任务描述</span></span><br><span class="line"><span class="comment">// 	•你需要编写一个多线程文件处理器。它从一个通道（channel）中接收文件路径，并在线程池中处理这些文件。文件处理的具体任务可以是读取文件内容并打印到控制台。你需要使用 Rust 的带缓冲区的 channel 来控制并发线程的数量，从而限制同时处理的文件数量。</span></span><br><span class="line"><span class="comment">// •具体要求</span></span><br><span class="line"><span class="comment">// 	•文件处理任务：</span></span><br><span class="line"><span class="comment">// 	•定义一个函数 process_file，该函数接受一个文件路径，读取文件内容，并将内容打印到控制台。</span></span><br><span class="line"><span class="comment">// •多线程控制：</span></span><br><span class="line"><span class="comment">// 	•创建一个带缓冲区的 channel，用于在主线程和工作线程之间传递文件路径。</span></span><br><span class="line"><span class="comment">// 	•使用多线程来实现文件处理的并发性，限制线程的并发数量（例如，最多同时处理 4 个文件）。</span></span><br><span class="line"><span class="comment">// •主线程作为生产者：</span></span><br><span class="line"><span class="comment">// 	•主线程负责向通道发送文件路径。假设我们有 10 个文件路径要处理。</span></span><br><span class="line"><span class="comment">// •工作线程作为消费者：</span></span><br><span class="line"><span class="comment">// 	•创建多个工作线程，每个线程从通道中接收文件路径，并调用 process_file 函数来处理文件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;   </span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex; </span><br><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_test_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dir_path</span> = <span class="string">&quot;test_files&quot;</span>;</span><br><span class="line">    fs::<span class="title function_ invoke__">create_dir_all</span>(dir_path)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file_path</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;/file_&#123;&#125;.txt&quot;</span>, dir_path, i);</span><br><span class="line">        fs::<span class="title function_ invoke__">write</span>(file_path, <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, i, i, i))?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_file</span>(file_path: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    <span class="keyword">match</span> fs::<span class="title function_ invoke__">read_to_string</span>(&amp;file_path) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(content) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;处理文件: &#123;&#125;&quot;</span>, file_path);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;读取文件 &#123;&#125; 时发生错误: &#123;&#125;&quot;</span>, file_path, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="title function_ invoke__">create_test_file</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;创建测试文件时发生错误: &#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rx</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(rx));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rx</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;rx);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;工作线程 &#123;&#125; 已启动&quot;</span>, id);</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="comment">// 获取锁并立即释放，只在接收消息时短暂持有锁</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">try_recv</span>();</span><br><span class="line">                <span class="keyword">match</span> received &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(file_path) =&gt; &#123;</span><br><span class="line">                        <span class="title function_ invoke__">process_file</span>(file_path);</span><br><span class="line">                        thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(mpsc::TryRecvError::Empty) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// 通道为空，短暂等待后重试</span></span><br><span class="line">                        thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(mpsc::TryRecvError::Disconnected) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// 通道已关闭，退出循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;工作线程 &#123;&#125; 已结束&quot;</span>, id);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">path</span> = <span class="built_in">format!</span>(<span class="string">&quot;test_files/file_&#123;&#125;.txt&quot;</span>, i);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;已发送文件路径: file_&#123;&#125;.txt&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 课后习题2：使用Channel实现程序的优雅停止</span></span><br><span class="line"><span class="comment">// • 任务描述</span></span><br><span class="line"><span class="comment">//     。在这道练习中，你需要编写一个多线程程序，该程序会创建多个工作线程，持续处理任务。在接收到停止信号时，所有工作线程应该优雅地停止工作，并确保所有未完成的任务都被处理完毕。</span></span><br><span class="line"><span class="comment">//     你将使用Rust的channel来实现任务的调度和优雅停止机制。</span></span><br><span class="line"><span class="comment">// • 具体要求</span></span><br><span class="line"><span class="comment">//     • 工作线程：</span></span><br><span class="line"><span class="comment">//         创建一个工作线程池，工作线程从通道接收任务并处理。</span></span><br><span class="line"><span class="comment">//         工作线程应能够响应停止信号，并在完成当前任务后优雅地退出。</span></span><br><span class="line"><span class="comment">//     • 任务结构：</span></span><br><span class="line"><span class="comment">//         任务可以是简单的打印操作，模拟一些耗时工作，例如打印任务ID并暂停一段时间。</span></span><br><span class="line"><span class="comment">//     • 优雅停止：</span></span><br><span class="line"><span class="comment">//         通过发送一个特殊的停止信号，通知所有工作线程停止接收新的任务，并在完成当前任务后退出。</span></span><br><span class="line"><span class="comment">//         确保所有已接收的任务都被处理完毕。</span></span><br><span class="line"><span class="comment">//     • 主线程控制：</span></span><br><span class="line"><span class="comment">//         主线程应当能够发送任务，也能够在适当的时候发送停止信号，触发工作线程的优雅停止。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;mpsc, Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">NewTask</span>(<span class="type">u32</span>),</span><br><span class="line">    Stop,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: <span class="type">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">message</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> message &#123;</span><br><span class="line">                Message::<span class="title function_ invoke__">NewTask</span>(task_id) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;工作线程&#123;&#125;正在处理任务&#123;&#125;&quot;</span>, id, task_id);</span><br><span class="line">                    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;工作线程&#123;&#125;完成任务&#123;&#125;&quot;</span>, id, task_id);</span><br><span class="line">                &#125;</span><br><span class="line">                Message::Stop =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;工作线程&#123;&#125;收到停止信号&quot;</span>, id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123; id, thread: <span class="title function_ invoke__">Some</span>(thread) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rx</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(rx));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">worker_id</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">worker</span> = Worker::<span class="title function_ invoke__">new</span>(worker_id, Arc::<span class="title function_ invoke__">clone</span>(&amp;rx));</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(worker);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">10</span> &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(Message::<span class="title function_ invoke__">NewTask</span>(i)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;主线程发送任务 &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..handles.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(Message::Stop).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.thread.<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;所有任务完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/01/rust-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/01/rust-test/" class="post-title-link" itemprop="url">二十四、Rust测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-01 16:44:06" itemprop="dateCreated datePublished" datetime="2024-11-01T16:44:06+00:00">2024-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-02 01:02:00" itemprop="dateModified" datetime="2024-11-02T01:02:00+00:00">2024-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>Rust在工程化方面完美的支持了各种测试配置，包括<code>Unit Test</code>单元测试、<code>Integration Test</code>集成测试、<code>Doc Test</code>文档测试、<code>Bench Test</code>基准测试、<code>Example Test</code>示例测试等。</p>
<h2 id="单元测试-Unit-Test"><a href="#单元测试-Unit-Test" class="headerlink" title="单元测试 Unit Test"></a>单元测试 Unit Test</h2><p>单元测试目标是测试某一个代码单元(一般都是函数)，验证该单元是否能按照预期进行工作，例如测试一个<code>add</code>函数，验证当给予两个输入时，最终返回的和是否符合预期。</p>
<p>我们首先使用<code>cargo new --lib rust-lib</code>创建一个库项目，此时打开<code>lib.rs</code>文件，可以看到如下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">usize</span>, right: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;   <span class="comment">// 使用super::*来访问父模块中的所有公共项</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这串代码就是一个单元测试的模块。在上面的示例代码中，我们首先使用<code>#[cfg(test)]</code>属性来标记测试模块<code>mod tests</code>，然后使用<code>#[test]</code>属性来标记测试函数<code>it_works</code>。  </p>
<h3 id="条件编译-cfg-test"><a href="#条件编译-cfg-test" class="headerlink" title="条件编译#[cfg(test)]"></a>条件编译<code>#[cfg(test)]</code></h3><p>上面代码中的<code>#[cfg(test)]</code>标注可以告诉Rust只有在<code>cargo test</code>时才编译和运行模块<code>tests</code>，其它时候当这段代码是空气即可，例如在<code>cargo build</code>时。这么做有几个好处：</p>
<ul>
<li>节省构建代码时的编译时间</li>
<li>减小编译出的可执行文件的体积</li>
</ul>
<h3 id="使用assert-宏"><a href="#使用assert-宏" class="headerlink" title="使用assert!宏"></a>使用<code>assert!</code>宏</h3><p>在上面的测试模块中，我们使用<code>assert_eq!</code>宏来断言<code>add</code>函数的返回值是否等于<code>4</code>。<code>assert!</code>宏是<code>assert_eq!</code>宏的简化版，它用于断言一个条件为真。如果条件为假，<code>assert!</code>宏会立即终止程序，并输出错误信息。</p>
<p>在上面的代码中<code>assert_eq!(result, 4);</code>显然是成功的，因此该语句返回了一个单元类型<code>()</code>。但如果断言失败，<code>assert!</code>宏会输出错误信息，并返回一个<code>panic!</code>，使得测试失败。</p>
<p>但如上面所说， <code>assert!</code>宏自己抛出的错误信息只会告诉我们错误发生的地方，并没有提供更多的信息，在有些时候会让人一头雾水。因此，我们可以为<code>assert!</code>宏提供一个可选的错误信息，这样可以帮助我们更好的定位错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert!</span>(result == <span class="number">4</span>, <span class="string">&quot;计算错误，result为&#123;&#125;，不等于4&quot;</span>, result);</span><br></pre></td></tr></table></figure>
<p>这段代码跟之前并无不同，只是为<code>assert!</code>新增了几个格式化参数，这种使用方式与<code>format!</code>并无区别，但是，我们可以得到更加精确的报错信息。</p>
<h3 id="使用Result"><a href="#使用Result" class="headerlink" title="使用Result&lt;T, E&gt;"></a>使用<code>Result&lt;T, E&gt;</code></h3><p>我们也可以使用在单元测试中让函数返回一个<code>Result&lt;(), E&gt;</code>，这样可以帮助我们更好的处理错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">feature_test</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;2 + 2 != 5&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数返回<code>Ok(())</code>，则测试通过;但若测试失败，则返回<code>Err(String)</code>，并输出错误信息。</p>
<h3 id="使用should-panic"><a href="#使用should-panic" class="headerlink" title="使用should_panic"></a>使用<code>should_panic</code></h3><p>想象一下，如果一个函数在某些情况下会抛出错误，那么我们如何测试这种情况呢？为此，Rust为我们提供了<code>should_panic</code>属性：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_todo</span>() &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用<code>should_panic</code>属性时，如果测试函数成功抛出错误，则测试成果，但如果没有抛出错误，则测试失败。</p>
<h4 id="使用expected"><a href="#使用expected" class="headerlink" title="使用expected"></a>使用<code>expected</code></h4><p>在上面我们提到可以使用<code>should_panic</code>属性来测试函数是否抛出错误，但有时候我们希望测试函数抛出的错误信息与我们预期的一致，这时我们就可以使用<code>expected</code>属性：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic(expected = <span class="string">&quot;计算错误&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_todo</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;计算错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>expected</code>属性用于指定我们期望测试函数抛出的错误信息，如果测试函数抛出的错误信息与期望的不一致，则测试失败。</p>
<h3 id="使用ignore"><a href="#使用ignore" class="headerlink" title="使用ignore"></a>使用<code>ignore</code></h3><p>在有些时候，我们希望跳过某个测试，这时我们可以使用<code>ignore</code>属性：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_ignore</span>() &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在执行<code>cargo test</code>时，<code>test_ignore</code>函数将被跳过。</p>
<h3 id="使用cargo-test-test-test-name"><a href="#使用cargo-test-test-test-name" class="headerlink" title="使用cargo test --test test_name"></a>使用<code>cargo test --test test_name</code></h3><p>在有些时候，我们希望只运行某一个测试，这时我们可以使用<code>cargo test --test test_name</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> --<span class="built_in">test</span> test_name</span><br></pre></td></tr></table></figure>
<p>此时，只有函数名为<code>test_name</code>的测试会被运行。</p>
<h2 id="集成测试-Integration-Test"><a href="#集成测试-Integration-Test" class="headerlink" title="集成测试 Integration Test"></a>集成测试 Integration Test</h2><p>在单元测试中，我们可以直接在<code>lib.rs</code>文件中编写测试代码，但这样会使得测试代码与业务代码耦合在一起，不便于管理。为此，Rust为我们提供了集成测试。</p>
<p>我们可以在与<code>src</code>目录平级的<code>tests</code>目录中编写集成测试代码，Rust会自动将<code>tests</code>目录中的所有<code>.rs</code>文件识别为集成测试文件。</p>
<p>集成测试与单元测试还有一点不同：单元测试是对代码单元进行测试，而集成测试就是对某一个功能或者接口进行测试。因此单元测试的通过，并不代表集成测试就会通过：局部上反映不出的问题，在全局上很可能会暴露出来。</p>
<p>让我们在<code>tests</code>目录中创建一个<code>integration.rs</code>文件，并编写如下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rust_lib::add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_add</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先与单元测试不同的是，我们并没有使用<code>mod</code>创建测试模块，也没有使用<code>#[cfg(test)]</code>标注。这是因为集成测试本身就在<code>tests</code>目录中，说明了它的特殊用途，因此无需额外标注。其次，我们使用了<code>use</code>关键字导入了<code>add</code>函数，这是因为集成测试与单元测试不同，它不在<code>lib.rs</code>文件中，因此需要手动导入后才能进行测试。</p>
<p>如果此时我们直接运行<code>cargo test</code>，会输出如下信息：</p>
<figure class="highlight plaintext"><figcaption><span>cargo test</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     Running unittests (target/debug/deps/adder-8a400aa2b5212836)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests/integration_test.rs (target/debug/deps/integration_test-2d3aeee6f15d1f20)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test it_adds_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure>
<p>可以看到在上述输出中，测试的内容共有3个部分：单元测试、集成测试和文档测试。</p>
<p>但如果此时我们只希望进行集成测试，就可以使用<code>cargo test --test integration</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> --<span class="built_in">test</span> integration</span><br></pre></td></tr></table></figure>
<p>这与单元测试中的<code>cargo test --test test_name</code>命令类似，只不过将<code>test_name</code>替换为<code>integration</code>即可。</p>
<h3 id="共享模块"><a href="#共享模块" class="headerlink" title="共享模块"></a>共享模块</h3><p>在集成测试的<code>tests</code>目录下，每一个文件都是一个独立的包，这种组织方式可以很好的帮助我们理清测试代码的关系，但是如果大家想要在多个文件中共享同一个功能该怎么做？例如函数<code>setup</code>可以用于状态初始化，然后多个测试包都需要使用该函数进行状态的初始化。</p>
<p>也许你会想要创建一个<code>tests/common.rs</code>文件，然后将<code>setup</code>函数放入其中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">setup</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化一些测试状态</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是当我们运行<code>cargo test</code>后，会发现<strong>该函数被当作集成测试函数运行了</strong>，即使它并没有包含任何测试功能，也没有被其它测试文件所调用:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span></span><br><span class="line">     Running tests/common.rs (target/debug/deps/common-5c21f4f2c87696fb)</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.00s</span><br></pre></td></tr></table></figure>
<p>显然，这个结果并不是我们想要的。为了避免这种输出，我们不能创建<code>tests/common.rs</code>，而是要创建<code>tests/common/mod.rs</code>，此时再运行<code>cargo test</code>就不会再看到相应的输出。 原因是通过这种文件组织和命名方式，Rust不再将<code>common</code>模块看作是集成测试文件。</p>
<p>总结来说，<code>tests</code>目录下的子目录中的文件不会被当作独立的包，也不会有测试输出。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> common;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    common::<span class="title function_ invoke__">setup</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，就可以在测试中调用<code>common</code>中的共享函数了，不过还有一点值得注意，为了使用<code>common</code>，这里使用了<code>mod common</code>的方式来声明该模块。</p>
<h2 id="文档测试-Doc-Test"><a href="#文档测试-Doc-Test" class="headerlink" title="文档测试 Doc Test"></a>文档测试 Doc Test</h2><p>在上面我们运行<code>cargo test</code>时，会发现终端输出的测试信息包括了单元测试、集成测试和文档测试。在前面我们已经提到了单元测试和集成测试，接下来让我们来看一下文档测试。</p>
<p>文档测试分为两部分，一部分是针对模块的测试，而另一部分则是针对函数的测试。</p>
<p>我们可以通过<code>///</code>来进行书写文档测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Add to number</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">/// ``` rust</span></span><br><span class="line"><span class="comment">/// assert_eq!(rust_lib::add(2, 2), 4);</span></span><br><span class="line"><span class="comment">/// ``` </span></span><br></pre></td></tr></table></figure>
<p>以上代码有几点需要注意：</p>
<ul>
<li>文档注释需要位于<code>lib</code>类型的包中，例如<code>src/lib.rs</code>中</li>
<li>文档注释可以使用markdown语法！例如<code># Examples</code>的标题，以及代码块高亮</li>
<li>被注释的对象需要使用<code>pub</code>对外可见，记住：文档注释是给用户看的，内部实现细节不应该被暴露出去</li>
</ul>
<p>我们可以通过<code>cargo test --doc</code>来运行文档测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> --doc</span><br></pre></td></tr></table></figure>

<p>同时，我们也可以使用<code>//!</code>来为模块进行测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! A library for adding numbers</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! # utils</span></span><br><span class="line"><span class="comment">//! ```rust</span></span><br><span class="line"><span class="comment">//! assert_eq!(rust_lib::utils::add(2, 2), 4);</span></span><br><span class="line"><span class="comment">//! ```</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">usize</span>, right: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        left + right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基准测试-Bench-Test"><a href="#基准测试-Bench-Test" class="headerlink" title="基准测试 Bench Test"></a>基准测试 Bench Test</h2><p>几乎所有开发都知道，如果要测量程序的性能，就需要性能测试。</p>
<p>性能测试包含了两种：压力测试和基准测试。前者是针对接口 API，模拟大量用户去访问接口然后生成接口级别的性能数据；而后者是针对代码，可以用来测试某一段代码的运行速度，例如一个排序算法。</p>
<p>Rust中提供了<code>#[bench]</code>属性来标记基准测试，并使用<code>criterion</code>库来生成性能数据。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(test)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> test::Bencher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[bench]</span>    <span class="comment">// 使用#[bench]属性来标记基准测试</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">bench_add_two</span>(b: &amp;<span class="keyword">mut</span> Bencher) &#123;</span><br><span class="line">        b.<span class="title function_ invoke__">iter</span>(|| <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="目录结构规范"><a href="#目录结构规范" class="headerlink" title="目录结构规范"></a>目录结构规范</h2><p>最后，让我们来回顾一下整个项目的目录规范；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── src/</span><br><span class="line">│   ├── lib.rs        <span class="comment"># 库代码</span></span><br><span class="line">│   ├── main.rs       <span class="comment"># 二进制代码</span></span><br><span class="line">│   ├── bin/          <span class="comment"># 额外的二进制文件</span></span><br><span class="line">│   │   └── demo.rs</span><br><span class="line">│   └── utils/        <span class="comment"># 内部模块</span></span><br><span class="line">│       ├── mod.rs</span><br><span class="line">│       └── math.rs</span><br><span class="line">├── tests/            <span class="comment"># 集成测试目录</span></span><br><span class="line">│   ├── common/       <span class="comment"># 测试公共模块</span></span><br><span class="line">│   │   └── mod.rs</span><br><span class="line">│   └── integration_test.rs</span><br><span class="line">├── benches/          <span class="comment"># 基准测试目录</span></span><br><span class="line">│   └── bench.rs</span><br><span class="line">├── examples/         <span class="comment"># 示例代码</span></span><br><span class="line">│   └── demo.rs</span><br><span class="line">└── docs/            <span class="comment"># 文档</span></span><br><span class="line">    └── api.md</span><br></pre></td></tr></table></figure>

<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/01/rust-iterator-associated-types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/01/rust-iterator-associated-types/" class="post-title-link" itemprop="url">二十三、Rust进阶-迭代器与关联类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-01 10:43:59" itemprop="dateCreated datePublished" datetime="2024-11-01T10:43:59+00:00">2024-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-13 23:43:58" itemprop="dateModified" datetime="2024-11-13T23:43:58+00:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h1><p>迭代器（Iterator）是Rust标准库中提供的一种数据类型，用于遍历集合中的元素。迭代器可以用于遍历数组、向量、哈希表等数据结构。在此过程中，我们只需关心集合中的元素如何处理，而无需关心如何开始、如何结束以及需要按照什么样的索引去访问等问题。</p>
<p>迭代器会负责遍历集合中的每个元素，并确定遍历何时完成。</p>
<h2 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h2><p>Rust的迭代器是懒惰的，除非我们调用消费迭代器的方法，否则迭代器本身没有任何效果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里虽然创建了迭代器，但是在不使用时并不会遍历，因为Rust的迭代器是懒惰的</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当for循环使用迭代器时，迭代器才会开始遍历</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> v1_iter &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种惰性初始化的方式确保了创建迭代器不会有任何额外的性能损耗，其中的元素也不会被消耗，只有使用到该迭代器的时候，一切才开始。</p>
<h2 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h2><p>迭代器是一个能够注意生成元素的对象。它提供了一个统一的接口，用于遍历容器中的元素，同时保重了类型安全和内存安全。</p>
<p>在Rust中，迭代器是基于trait实现的。这个trait被称为<code>Iterator</code>，它定义了迭代器的基本行为。在该trait中，定义了<code>next</code>方法，该方法会返回迭代器中的下一个值，当迭代器结束时，返回<code>None</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>type Item</code>和<code>Self::Item</code>定义了与该trait关联的类型，用于指定迭代器生成的元素的类型。</p>
<p>实现<code>Iterator</code>trait需要你定义一个<code>item</code>类型，并且使用<code>Self::Item</code>来指定，它用于<code>next</code>方法返回的值的类型。</p>
<h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><p>上面我们所提到的就是关联类型。关联类型是trait中的类型占位符，它可以用于trait的方法签名中，trait的实现者需要为它指定具体的类型。它可以定义出包含某些类型的trait，而无需在实现前就知道这些类型是什么。</p>
<h3 id="泛型与关联类型的区别"><a href="#泛型与关联类型的区别" class="headerlink" title="泛型与关联类型的区别"></a>泛型与关联类型的区别</h3><p><strong>泛型</strong>：<br>-泛型需要在每次实现trait时标注类型<br>-可以为一个泛型多次实现某个trait（不同的泛型参数）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyIterator</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">MyIterator</span> &#123;  <span class="comment">// 为泛型T指定String类型并实现next方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">MyIterator</span> &#123;  <span class="comment">// 为泛型T指定i32类型并实现next方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关联类型</strong>：<br>-关联类型无需在实现trait时标注类型<br>-不能为单个关联类型多次实现某个trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator2</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyIterator</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator2</span> <span class="keyword">for</span> <span class="title class_">MyIterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator2</span> <span class="keyword">for</span> <span class="title class_">MyIterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">i32</span>;    <span class="comment">// 此时会报错，因为关联类型不能被多次实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单迭代器"><a href="#简单迭代器" class="headerlink" title="简单迭代器"></a>简单迭代器</h2><p>下面让我们来实现一个简单的迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个迭代器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">numbers_iter</span> = numbers.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用while循环遍历迭代器中的元素</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(num) = numbers_iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们首先使用<code>numbers.iter()</code>创建了一个迭代器，然后使用<code>while let</code>循环遍历了迭代器中的元素，<code>iter.next()</code>方法会返回迭代器中的下一个元素，当迭代器结束时，返回<code>None</code>。</p>
<p>同时，我们可以发现，上面的代码中我们使用了<code>let mut</code>来声明迭代器，这是因为<code>next</code>方法会修改迭代器的状态，所以需要使用<code>mut</code>关键字。但是之前在使用<code>for</code>循环时，我们并没有使用<code>mut</code>关键字，这是因为<code>for</code>循环会自动将迭代器声明为<code>mut</code>，所以不需要我们手动声明。</p>
<h2 id="几个迭代的方法"><a href="#几个迭代的方法" class="headerlink" title="几个迭代的方法"></a>几个迭代的方法</h2><p>我们有几个不同的方法来创建迭代器：</p>
<ul>
<li><code>iter()</code>：在不可变引用上创建一个不可变的迭代器</li>
<li><code>iter_mut()</code>：在可变引用上创建一个可变的迭代器</li>
<li><code>into_iter()</code>：创建一个拥有所有权的迭代器</li>
</ul>
<p>让我们来看一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">values</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">v</span> <span class="keyword">in</span> values.<span class="title function_ invoke__">into_iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的代码将报错，因为 values 的所有权在上面 `for` 循环中已经被转移走</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,values);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">values</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_values_iter</span> = values.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不会报错，因为 values_iter 只是借用了 values 中的元素</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, values);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">values</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 对 values 中的元素进行可变借用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">values_iter_mut</span> = values.<span class="title function_ invoke__">iter_mut</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出第一个元素，并修改为0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = values_iter_mut.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        *v = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出[0, 2, 3]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，以后很多含有<code>into_</code>的方法都会拿走所有权，而<code>_mut</code>方法会创建一个可变引用，剩下的都是不可变借用。</p>
<h2 id="消耗迭代器的方法"><a href="#消耗迭代器的方法" class="headerlink" title="消耗迭代器的方法"></a>消耗迭代器的方法</h2><p>消费者是迭代器上的方法，它会消费掉迭代器中的元素，然后返回其类型的值，这些消费者都有一个共同的特点：在它们的定义中，都依赖<code>next</code>方法来消费元素，因此这也是为什么迭代器要实现<code>Iterator</code>特征，而该特征必须要实现<code>next</code>方法的原因。</p>
<h3 id="消费者适配器"><a href="#消费者适配器" class="headerlink" title="消费者适配器"></a>消费者适配器</h3><p>只要迭代器上的某个方法<code>A</code>在其内部调用了<code>next</code>方法，那么<code>A</code>就被称为消费性适配器：因为<code>next</code>方法会消耗掉迭代器上的元素，所以方法<code>A</code>的调用也会消耗掉迭代器上的元素。</p>
<p>其中一个例子是<code>sum</code>方法，它会拿走迭代器的所有权，然后通过不断调用<code>next</code>方法遍历所有元素并进行求和：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = v1_iter.<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v1_iter 是借用了 v1，因此 v1 可以照常使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下代码会报错，因为 `sum` 拿到了迭代器 `v1_iter` 的所有权</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,v1_iter);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码注释中所说明的：在使用<code>sum</code>方法后，我们将无法再使用<code>v1_iter</code>，因为<code>sum</code>拿走了该迭代器的所有权：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>&lt;S&gt;(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> S</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">        S: Sum&lt;<span class="keyword">Self</span>::Item&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        Sum::<span class="title function_ invoke__">sum</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从<code>sum</code>源码中也可以清晰看出，<code>self</code>类型的方法参数拿走了所有权。</p>
<h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><p>定义在<code>Iterator</code>trait中的另一些方法被称为迭代器适配器，它们不会消耗掉迭代器中的元素，相反，它们会返回一个新的迭代器。这是实现链式方法调用的关键：<code>v.iter().map().filter()...</code>。</p>
<p>与消费者适配器不同，迭代器适配器是惰性的，这意味着你需要一个消费者适配器来触发它们的执行，最终将迭代器转换成一个具体的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这里的<code>map</code>方法就是一个迭代器适配器，允许我们对迭代器中的每个元素应用一个函数，并返回一个新的迭代器。在上面的代码示例中，<code>map</code>将一个闭包<code>|x| x + 1</code>应用到迭代器中的每个元素，并返回一个新的迭代器。</p>
<p>运行后输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">warning: unused `Map` that must be used</span><br><span class="line"> --&gt; src/main.rs:4:5</span><br><span class="line">  |</span><br><span class="line">4 |     v1.iter().map(|x| x + 1);</span><br><span class="line">  |     ^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_must_use)]` on by default</span><br><span class="line">  = note: iterators are lazy and do nothing unless consumed // 迭代器`map`是惰性的，这里不产生任何效果</span><br></pre></td></tr></table></figure>
<p>如上述中文注释所说，这里的<code>map</code>方法是一个迭代者适配器，它是惰性的，不产生任何行为，因此我们还需要一个消费者适配器进行收尾：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p>在上面代码中，我们使用了<code>collect</code>方法，它就是一个消费者适配器，它接受一个迭代器，并将其转换为一个集合类型，如<code>Vec</code>、<code>HashMap</code>等。这里我们为<code>v2</code>标注了<code>Vec&lt;_&gt;</code>类型，就是为了告诉<code>collect</code>：将迭代器中的元素收集到一个<code>Vec</code>中。</p>
<p>再来看看如何使用<code>collect</code>收集成<code>HashMap</code>集合：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">names</span> = [<span class="string">&quot;sunface&quot;</span>, <span class="string">&quot;sunfei&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ages</span> = [<span class="number">18</span>, <span class="number">18</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">folks</span>: HashMap&lt;_, _&gt; = names.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">zip</span>(ages.<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,folks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>zip</code>是一个迭代器适配器，它的作用就是将两个迭代器的内容压缩到一起，形成<code>Iterator&lt;Item=(ValueFromA, ValueFromB)&gt;</code>这样的新的迭代器，在此处就是形如<code>[(name1, age1), (name2, age2)]</code>的迭代器。</p>
<p>然后再通过<code>collect</code>将新迭代器中<code>(K, V)</code>形式的值收集成<code>HashMap&lt;K, V&gt;</code>，同样的，这里必须显式声明类型，然后<code>HashMap</code>内部的<code>KV</code>类型可以交给编译器去推导，最终编译器会推导出<code>HashMap&lt;&amp;str, i32&gt;</code>，完全正确！</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code>方法用于过滤迭代器中的元素，它接受一个闭包作为参数，该闭包会返回一个布尔值，<code>filter</code>方法会根据这个布尔值来决定是否保留该元素:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shoe</span> &#123;</span><br><span class="line">    size: <span class="type">u32</span>,</span><br><span class="line">    style: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shoes_in_size</span>(shoes: <span class="type">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|s| s.size == shoe_size).<span class="title function_ invoke__">collect</span>() <span class="comment">// 使用filter过滤出size等于shoe_size的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>filter</code>是迭代器适配器，用于对迭代器中的每个值进行过滤。 它使用闭包作为参数，该闭包的参数<code>s</code>是来自迭代器中的值，然后使用<code>s</code>跟外部环境中的<code>shoe_size</code>进行比较，若相等，则在迭代器中保留<code>s</code>值，若不相等，则从迭代器中剔除<code>s</code>值，最终通过<code>collect</code>收集为<code>Vec&lt;Shoe&gt;</code>类型。</p>
<h2 id="实现Iteratortrait"><a href="#实现Iteratortrait" class="headerlink" title="实现Iteratortrait"></a>实现<code>Iterator</code>trait</h2><p>之前的内容我们都是使用Rust标准库中已经实现好的迭代器，那么如果我们想要实现自己的迭代器，就需要实现<code>Iterator</code>trait。在这里，我们必须要实现<code>next</code>方法，因为该方法定义了迭代器如何产生下一个元素。</p>
<p>让我们来自己实现一个吧！</p>
<p>首先，创建一个计数器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为计数器<code>Counter</code>实现了一个关联函数<code>new</code>，用于创建新的计数器实例。下面我们继续为计数器实现<code>Iterator</code>特征：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)   </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，将该特征的关联类型设置为<code>u32</code>，由于我们的计数器保存的<code>count</code>字段就是<code>u32</code>类型， 因此在<code>next</code>方法中，最后返回的是实际上是<code>Option&lt;u32&gt;</code>类型。</p>
<p>每次调用<code>next</code>方法，都会让计数器的值加一，然后返回最新的计数值，一旦计数大于<code>5</code>，就返回<code>None</code>。</p>
<p>最后，使用我们新建的<code>Counter</code>进行迭代：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    a: <span class="type">u32</span>,</span><br><span class="line">    b: <span class="type">u32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Fibonacci &#123; a: <span class="number">0</span>, b: <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">take</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, n: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">            result.<span class="title function_ invoke__">push</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Iterator trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">next_value</span> = <span class="keyword">self</span>.a + <span class="keyword">self</span>.b;</span><br><span class="line">        <span class="keyword">self</span>.a = <span class="keyword">self</span>.b;</span><br><span class="line">        <span class="keyword">self</span>.b = next_value;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fib</span> = Fibonacci::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> fib.<span class="title function_ invoke__">take</span>(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/31/rust-closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/31/rust-closure/" class="post-title-link" itemprop="url">二十二、Rust进阶-闭包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-31 23:42:39" itemprop="dateCreated datePublished" datetime="2024-10-31T23:42:39+00:00">2024-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-13 23:41:57" itemprop="dateModified" datetime="2024-11-13T23:41:57+00:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="闭包Closure"><a href="#闭包Closure" class="headerlink" title="闭包Closure"></a>闭包Closure</h1><p>Rust在程序设计中收到了很多语言的影响，其中就包括函数式编程语言。函数式编程有特点如下：</p>
<ul>
<li>函数是一等公民，它既可以存储在变量中，也可以作为参数传递给其他函数，还可以作为返回值返回。</li>
</ul>
<p>闭包是函数式编程语言中非常重要的概念，Rust也引入了闭包的概念。</p>
<h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = |y: <span class="type">i32</span>| x + y;</span><br></pre></td></tr></table></figure>
<p>上面的代码展示了非常简单的闭包<code>sum</code>，它拥有一个入参<code>y</code>，同时捕获了作用域中的<code>x</code>的值，因此调用<code>sum(2)</code>意味着将<code>2</code>（参数<code>y</code>）跟<code>1</code>（<code>x</code>）进行相加，最终返回它们的和：<code>3</code>。</p>
<p>闭包有特点如下：</p>
<ul>
<li>可以捕获周围作用域的变量</li>
<li>支持作为参数传递给其他函数</li>
<li>可以返回闭包作为函数的返回值</li>
<li>类型推断：闭包通常通过类型推断来确定参数和返回值类型</li>
</ul>
<h2 id="闭包的语法"><a href="#闭包的语法" class="headerlink" title="闭包的语法"></a>闭包的语法</h2><p>闭包的语法非常简单，只需要用<code>|</code>包裹参数列表，用<code>-&gt;</code>指定返回值类型，用<code>&#123;&#125;</code>包裹函数体即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = |参数列表| <span class="punctuation">-&gt;</span> 返回值类型 &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有简单示例如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">add_one</span> = |x: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_one</span>(<span class="number">1</span>)); <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure>

<p>同时，由于Rust可以推断闭包的参数和返回值类型，因此在很多情况下可以省略类型声明：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">add_one</span> = |x| x + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_one</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h2 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h2><h3 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h3><p>闭包可以作为函数的参数传递，从而实现更灵活的代码结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">apply_to_3</span>&lt;F&gt;(f: F) <span class="punctuation">-&gt;</span> <span class="type">i32</span>   <span class="comment">//这里的参数F是一个泛型参数，F是闭包的类型</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>,  <span class="comment">// 约束F是一个函数，且参数是i32，返回值也是i32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">double</span> = |x| x * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">apply_to_3</span>(double)); <span class="comment">// 输出：6</span></span><br></pre></td></tr></table></figure>

<h3 id="捕获环境变量"><a href="#捕获环境变量" class="headerlink" title="捕获环境变量"></a>捕获环境变量</h3><p>闭包可以捕获其周围环境中的变量，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>; </span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y)); <span class="comment">//断言成功，说明equal_to_x捕获了x的值，即使它没有作为参数传入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>equal_to_x</code>闭包捕获了变量<code>x</code>，因此在调用<code>equal_to_x(y)</code>时，<code>y</code>的值会与<code>x</code>的值进行比较。但如果我们将该闭包换成函数，那么结果会怎么样呢：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//let equal_to_x = |z| z == x;</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">equal_to_x</span>(z: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        z == x     <span class="comment">// 这里z == x，但是x是函数外的变量，因此这里会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>; </span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然函数<code>equal_to_x</code>没有捕获变量<code>x</code>。</p>
<p>闭包有三种捕获变量的方式：</p>
<ul>
<li>值捕获：闭包通过值捕获其环境中的变量，将环境变量的所有权转移到闭包中</li>
<li>引用捕获：闭包通过引用捕获其环境中的变量，闭包在定义时捕获变量的引用，在调用时使用这些引用。</li>
<li>可变引用捕获：闭包通过可变引用捕获其环境中的变量，闭包在定义时捕获变量的可变引用，在调用时使用这些可变引用。</li>
</ul>
<p>让我们来看下面的几个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 引用捕获</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_num</span> = |x: <span class="type">i32</span>| x + num;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_num</span>(<span class="number">1</span>)); <span class="comment">// 输出：6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变引用捕获</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">change_num</span> = |x: <span class="type">i32</span>| num += x;</span><br><span class="line"><span class="title function_ invoke__">change_num</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure>

<h2 id="闭包的类型推导"><a href="#闭包的类型推导" class="headerlink" title="闭包的类型推导"></a>闭包的类型推导</h2><p>Rust 是静态语言，因此所有的变量都具有类型，但是得益于编译器的强大类型推导能力，在很多时候我们并不需要显式地去声明类型，但是显然函数并不在此列，必须手动为函数的所有参数和返回值指定类型。原因在于函数往往会作为 API 提供给你的用户，因此你的用户必须在使用时知道传入参数的类型和返回值类型。</p>
<p>与函数相反，闭包并不会作为 API 对外提供，因此它可以享受编译器的类型推导能力，无需标注参数和返回值的类型。</p>
<p>为了增加代码可读性，有时候我们会显式地给类型进行标注，出于同样的目的，也可以给闭包标注类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = |x: <span class="type">i32</span>, y: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与之相比，不标注类型的闭包声明会更简洁些：<code>let sum = |x, y| x + y</code>，需要注意的是，针对<code>sum</code>闭包，如果你只进行了声明，但是没有使用，编译器会提示你为<code>x, y</code>添加类型标注，因为它缺乏必要的上下文：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sum</span>  = |x, y| x + y;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这里我们使用了<code>sum</code>，同时把<code>1</code>传给了<code>x</code>，<code>2</code>传给了<code>y</code>，因此编译器才可以推导出<code>x,y</code>的类型为<code>i32</code>。</p>
<p>十分值得我们注意的是，虽然类型推导十分好用，但它不是泛型，<strong>当编译器推导出一种类型后，它就会一直使用该类型：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>); <span class="comment">// 编译器会报错，因为编译器已经推导出x的类型为String，因此不能将i32类型的5传递给x</span></span><br></pre></td></tr></table></figure>
<p>当运行到<code>let n = example_closure(5);</code>时，编译器会报错，因为编译器已经推导出<code>x</code>的类型为<code>String</code>，因此不能将<code>i32</code>类型的<code>5</code>传递给<code>x</code>。</p>
<h2 id="闭包原理"><a href="#闭包原理" class="headerlink" title="闭包原理"></a>闭包原理</h2><p><strong>自动实现的函数类型：</strong><br><code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>是三个自动实现的闭包trait，分别表示按引用捕获、按可变引用捕获和按值捕获。当闭包捕获变量时，编译器会根据捕获变量的方式自动实现对应的trait：</p>
<ul>
<li>所有的闭包都实现了<code>FnOnce</code></li>
<li>无需移动捕获变量的闭包实现了<code>FnMut</code></li>
<li>无需可变访问捕获变量的闭包实现了<code>Fn</code></li>
</ul>
<p><strong>生命周期与闭包：</strong><br>闭包可以捕获引用，但是需要保证引用的生命周期超过闭包的生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">clousre</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"><span class="title function_ invoke__">clousre</span>();  <span class="comment">//正常运行，输出：hello</span></span><br></pre></td></tr></table></figure>

<h2 id="move关键字"><a href="#move关键字" class="headerlink" title="move关键字"></a>move关键字</h2><p>在参数列表前使用<code>move</code>关键字，可以强制闭包获取其使用的环境变量的所有权，这在将闭包传递给新线程以移动数据时非常有用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x); <span class="comment">// 编译器会报错，因为x的所有权已经被移动到equal_to_x闭包中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));    <span class="comment">//正常运行</span></span><br></pre></td></tr></table></figure>

<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题目：</span></span><br><span class="line"><span class="comment">// 假设你正在开发一个博客系统，其中每个用户可以查看不同的文章页面。页面的渲染是一个计算密集型的过程，可能涉及数据库重访、模板渲染等操作。</span></span><br><span class="line"><span class="comment">// 因此，为了优化性能，你决定在服务端实现一个缓存系统。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求：</span></span><br><span class="line"><span class="comment">//     实现 PageCache 结构体。</span></span><br><span class="line"><span class="comment">//  该结构体应缓存根据用户 ID 和文章 ID 渲染的页面。</span></span><br><span class="line"><span class="comment">//     你需要为该结构体实现一个 get_page 方法，该方法接受用户 ID 和文章 ID，并返回渲染后的页面内容。</span></span><br><span class="line"><span class="comment">//     如果相同的用户 ID 和文章 ID 已经渲染过，则 get_page 应直接返回缓存的页面，而不是重新渲染。</span></span><br><span class="line"><span class="comment">// 通用性：</span></span><br><span class="line"><span class="comment">//     PageCache 应支持任意类型的用户 ID（例如，u32 或 String）和文章 ID。</span></span><br><span class="line"><span class="comment">//     缓存的内容应为渲染后的 HTML 页面（String 类型）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::hash::Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PageCache</span>&lt;F, U, A&gt; </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(&amp;U, &amp;A) <span class="punctuation">-&gt;</span> <span class="type">String</span>,    <span class="comment">// 函数指针或闭包类型</span></span><br><span class="line">    U: Hash + <span class="built_in">Eq</span> + <span class="built_in">Clone</span>,</span><br><span class="line">    A: Hash + <span class="built_in">Eq</span> + <span class="built_in">Clone</span>,</span><br><span class="line">&#123;</span><br><span class="line">    render_fn: F,</span><br><span class="line">    cache: HashMap&lt;(U, A), <span class="type">String</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F, U, A&gt; PageCache&lt;F, U, A&gt; </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(&amp;U, &amp;A) <span class="punctuation">-&gt;</span> <span class="type">String</span>,</span><br><span class="line">    U: Hash + <span class="built_in">Eq</span> + <span class="built_in">Clone</span>,</span><br><span class="line">    A: Hash + <span class="built_in">Eq</span> + <span class="built_in">Clone</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现构造器方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(render_fn: F) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageCache &#123;</span><br><span class="line">            render_fn,</span><br><span class="line">            cache: HashMap::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_page</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, user_id: U, article_id: A) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">key</span> = (user_id, article_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(cached_page) = <span class="keyword">self</span>.cache.<span class="title function_ invoke__">get</span>(&amp;key) &#123;</span><br><span class="line">            cached_page.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rendered_page</span> = (<span class="keyword">self</span>.render_fn)(&amp;key.<span class="number">0</span>, &amp;key.<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">self</span>.cache.<span class="title function_ invoke__">insert</span>(key, rendered_page.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">            rendered_page</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">page_cache</span> = PageCache::<span class="title function_ invoke__">new</span>(|user_id: &amp;<span class="type">String</span>, article_id: &amp;<span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Rendering page for user &#123;&#125; and article &#123;&#125;&quot;</span>, user_id, article_id); <span class="comment">//打印渲染日志</span></span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;Rendered HTML content for user &#123;&#125; and article &#123;&#125;&quot;</span>, user_id, article_id)    <span class="comment">//存储渲染后的页面（在HashMap中）</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, page_cache.<span class="title function_ invoke__">get_page</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user1&quot;</span>), <span class="number">42</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, page_cache.<span class="title function_ invoke__">get_page</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user1&quot;</span>), <span class="number">42</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, page_cache.<span class="title function_ invoke__">get_page</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user2&quot;</span>), <span class="number">42</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/31/rust-macros/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/31/rust-macros/" class="post-title-link" itemprop="url">二十一、Rust进阶-宏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-31 18:36:49" itemprop="dateCreated datePublished" datetime="2024-10-31T18:36:49+00:00">2024-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-13 23:44:41" itemprop="dateModified" datetime="2024-11-13T23:44:41+00:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="宏Macros"><a href="#宏Macros" class="headerlink" title="宏Macros"></a>宏Macros</h1><p>在Rust中，宏（Macros）是一种强大的工具，用于生成代码。它们在编译时展开，可以执行复杂的文本操作。</p>
<p>实际上我们早就见到过宏，比如<code>println!</code>、<code>vec!</code>等，这些都是Rust内置的宏，宏在Rust中无处不在：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_common_macros</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>&#123;<span class="string">&quot;Hello, World!&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>[<span class="string">&quot;Hello, World!&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们可以发现虽然我们平时使用<code>println!</code>时，是<code>println!(&quot;Hello, World!&quot;)</code>，但是<code>println!</code>也可以使用<code>&#123;&#125;</code>、<code>[]</code>、<code>&#123;&#125;</code>等作为参数。虽然三种使用方式都正确，但是Rust内置的宏有自己默认的使用方式，如<code>assert_eq!()</code>、<code>panic!()</code>等。</p>
<p><strong>宏分为两类：声明宏（Declarative Macros）和三种过程宏（Procedural Macros）</strong>：</p>
<ul>
<li><code>#[derive]</code>，在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如 Debug 特征</li>
<li>类属性宏(Attribute-like macro)，用于为目标添加自定义的属性</li>
<li>类函数宏(Function-like macro)，看上去就像是函数调用</li>
</ul>
<h2 id="宏和函数的区别"><a href="#宏和函数的区别" class="headerlink" title="宏和函数的区别"></a>宏和函数的区别</h2><p>宏和函数的区别并不少，而且对于宏擅长的领域，函数其实是有些无能为力的。</p>
<h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><p>从根本上说，宏是通过一种代码来生成另一种代码，它和元编程有一定的共同点。</p>
<p>例如<code>derive</code>宏，它可以在编译时自动为结构体派生出相应特征的实现代码。例如<code>#[derive(Debug)]</code>，还有熟悉的<code>println!</code>和<code>vec!</code>，所有的这些宏都会展开成相应的代码，且很可能是长得多的代码。</p>
<p>总之，元编程可以帮我们减少所需编写的代码，也可以一定程度上减少维护的成本，虽然函数复用也有类似的作用，但是宏依然拥有自己独特的优势。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>Rust 的函数签名是固定的：定义了两个参数，就必须传入两个参数，多一个少一个都不行。</p>
<p>而宏就可以拥有可变数量的参数，例如可以调用一个参数的<code>println!(&quot;hello&quot;)</code>，也可以调用两个参数的<code>println!(&quot;hello &#123;&#125;&quot;, name)</code>。</p>
<h3 id="宏展开"><a href="#宏展开" class="headerlink" title="宏展开"></a>宏展开</h3><p>由于宏会被展开成其它代码，且这个展开过程是发生在编译器对代码进行解释之前。因此，宏可以为指定的类型实现某个特征：先将宏展开成实现特征的代码后，再被编译。</p>
<p>而函数就做不到这一点，因为它直到运行时才能被调用，而特征需要在编译期被实现。</p>
<h3 id="宏的缺点"><a href="#宏的缺点" class="headerlink" title="宏的缺点"></a>宏的缺点</h3><p>相对函数来说，由于宏是基于代码再展开成代码，因此实现相比函数来说会更加复杂，再加上宏的语法更为复杂，最终导致定义宏的代码相当地难读，也难以理解和维护。</p>
<p><strong>就是十分难写，十分难懂，十分难维护！！</strong></p>
<h2 id="声明宏"><a href="#声明宏" class="headerlink" title="声明宏"></a>声明宏</h2><p>在Rust中最广泛使用的宏就是声明宏，声明宏使用<code>macro_rules!</code>来定义，<code>macro_rules!</code>看起来像是一个函数，但是它和函数没有任何关系，它允许你通过模式匹配来生成代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明宏</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> say_hello &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    say_hello!();</span><br><span class="line">    say_hello![];</span><br><span class="line">    say_hello!&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实上面的例子是一个十分十分简单的声明宏，它没有进行任何的匹配，只是打印了一个固定的语句。</p>
<h3 id="实现简化版的vec"><a href="#实现简化版的vec" class="headerlink" title="实现简化版的vec!"></a>实现简化版的vec!</h3><p>在之前动态数组的环节中，我们学习了使用<code>vec!</code>宏来创建动态数组:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>最重要的是，通过<code>vec!</code>创建的动态数组支持任何元素类型，也并没有限制数组的长度，如果使用函数，我们是无法做到这一点的。</p>
<p>现在让我们尝试用<code>macro_rules!</code>来自己实现一个简化版的<code>vec!</code>宏:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ($($e:expr),*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.<span class="title function_ invoke__">push</span>($e);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使是简化版本的<code>vec!</code>宏，它还是那么难理解，不过没关系，我们慢慢来。</p>
<p>首先<code>#[macro_export]</code>是用来导出宏的，这样宏就可以在当前crate之外使用。</p>
<p>紧接着我们使用<code>macro_rules!</code>是声明宏的语法，<code>vec!</code>是宏的名称，<code>($($e:expr),*)</code>是模式匹配，跟模式相匹配的代码就在<code>=&gt;</code>后面。</p>
<h3 id="模式解析"><a href="#模式解析" class="headerlink" title="模式解析"></a>模式解析</h3><p>现在，让我们来简单地解析一下<code>($($e:expr),*)</code>这个模式：</p>
<p>首先，我们使用圆括号<code>()</code>来将整个宏模式包裹其中，随后是<code>$()</code>，在此括号中跟模式相匹配的值(传入的Rust源代码)会被捕获，然后用于代码替换。在这里，模式 <code>$x:expr</code> 会匹配<strong>任何Rust表达式</strong>并给予该模式一个名称：<code>$x</code>。</p>
<p><code>$()</code> 之后的逗号说明在 <code>$()</code> 所匹配的代码的后面会有一个可选的逗号分隔符，紧随逗号之后的 <code>*</code> 说明 <code>*</code> 之前的模式会被匹配零次或任意多次(类似正则表达式)。</p>
<p>当我们使用 vec![1, 2, 3] 来调用该宏时，$x 模式将被匹配三次，分别是 1、2、3。为了帮助大家巩固，我们再来一起过一下：</p>
<ul>
<li><code>$()</code>中包含的是模式<code>$x:expr</code>，该模式中的<code>expr</code>表示会匹配任何Rust表达式，并给予该模式一个名称<code>$x</code></li>
<li>因此<code>$x</code>模式可以跟整数<code>1</code>进行匹配，也可以跟字符串<code>&quot;hello&quot;</code>进行匹配:<code>vec![&quot;hello&quot;, &quot;world&quot;]</code></li>
<li><code>$()</code>之后的逗号，意味着<code>1</code>和<code>2</code>之间可以使用逗号进行分割，也意味着<code>3</code>既可以没有逗号，也可以有逗号：<code>vec![1, 2, 3,]</code></li>
<li><code>*</code>说明之前的模式可以出现零次也可以任意次，这里出现了三次.</li>
</ul>
<p>接下来，让我们再看看与模式相关联，在<code>=&gt;</code>之后所写的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    $(</span><br><span class="line">        temp_vec.<span class="title function_ invoke__">push</span>($e);</span><br><span class="line">    )*</span><br><span class="line">    temp_vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就比较好理解了，<code>$()</code>中的<code>temp_vec.push()</code>将根据模式匹配的次数生成对应的代码，当调用<code>vec![1, 2, 3]</code>时，下面这段生成的代码将替代传入的源代码，也就是替代<code>vec![1, 2, 3]</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    temp_vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们已经能够大致理解这个简化版的<code>vec!</code>宏了。它可以接受任意数量和任意类型的参数，并创建一个包含这些参数的向量。</p>
<h2 id="过程宏"><a href="#过程宏" class="headerlink" title="过程宏"></a>过程宏</h2><p>第二种常用的宏就是过程宏（Procedural Macros），从形式上来看，过程宏跟函数较为相像，但过程宏是使用源代码作为输入参数，基于代码进行一系列操作后，再输出一段全新的代码。<strong>注意，过程宏中的 derive 宏输出的代码并不会替换之前的代码，这一点与声明宏有很大的不同！</strong></p>
<p>至于前文提到的过程宏的三种类型(自定义 derive、属性宏、函数宏)，它们的工作方式都是类似的。</p>
<p>当创建过程宏时，它的定义必须要放入一个独立的包中，且包的类型也是特殊的，必须使用<code>#[proc_macro]</code>属性来标注。过程宏需要放入独立包的原因比较复杂，在于它必须先被编译后才能使用，如果过程宏和使用它的代码在一个包，就必须先单独对过程宏的代码进行编译，然后再对我们的代码进行编译，但悲剧的是 Rust 的编译单元是包，因此你无法做到这一点。</p>
<h3 id="派生宏"><a href="#派生宏" class="headerlink" title="派生宏"></a>派生宏</h3><h4 id="派生宏的实现"><a href="#派生宏的实现" class="headerlink" title="派生宏的实现"></a>派生宏的实现</h4><p>值得注意的是，在大多数情况下，我们在编写代码的过程中不需要自己定义或者实现宏，我们只需要用好Rust内置的宏即可。</p>
<p>这里，我们简单看一下派生宏的实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_macro_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span> = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">HelloMacro</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">hello_macro</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Hello, Macro! My name is &#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，我们还需要在<code>Cargo.toml</code>中添加<code>quote</code>和<code>syn</code>的依赖，以及<code>proc-macro</code>的工具：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">syn</span> = <span class="string">&quot;2.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>实现派生宏真的十分复杂，请在有需要的时候自行查阅文档<a target="_blank" rel="noopener" href="https://course.rs/advance/macro.html">Rust语言圣经</a> </p>
<p>那么，Rust当中有那些已经为我们实现的内置宏呢？常用的有：</p>
<ul>
<li><code>#[derive(Debug)]</code>  </li>
<li><code>#[derive(Clone)]</code></li>
<li><code>#[derive(Copy)]</code></li>
<li><code>#[derive(Default)]</code> </li>
<li><code>#[derive(PartialEq)]</code></li>
<li><code>#[derive(Eq)]</code></li>
<li><code>#[derive(Hash)]</code></li>
<li><code>#[derive(PartialOrd)]</code></li>
<li><code>#[derive(Ord)]</code></li>
</ul>
<h3 id="类属性宏"><a href="#类属性宏" class="headerlink" title="类属性宏"></a>类属性宏</h3><p>类属性过程宏跟<code>derive</code>宏类似，但是前者允许我们定义自己的属性。除此之外，<code>derive</code>只能用于结构体和枚举，而类属性宏可以用于其它类型项，例如函数。</p>
<p>假设我们在开发一个web框架，当用户通过<code>HTTP GET</code>请求访问<code>/</code>根路径时，使用<code>index</code>函数为其提供服务:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[route(GET, <span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">index</span>() &#123;</span><br></pre></td></tr></table></figure>
<p>如上所示，代码功能非常清晰、简洁，这里的<code>#[route]</code>属性就是一个过程宏，它的定义函数大概如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">route</span>(attr: TokenStream, item: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br></pre></td></tr></table></figure>
<p>与<code>derive</code>宏不同，类属性宏的定义函数有两个参数：</p>
<ul>
<li>第一个参数时用于说明属性包含的内容：<code>Get</code>, <code>/</code>部分</li>
<li>第二个是属性所标注的类型项，在这里是<code>fn index() &#123;...&#125;</code>，注意，函数体也被包含其中</li>
</ul>
<p>除此之外，类属性宏跟<code>derive</code>宏的工作方式并无区别：创建一个包，类型是<code>proc-macro</code>，接着实现一个函数用于生成想要的代码。</p>
<h3 id="类函数宏"><a href="#类函数宏" class="headerlink" title="类函数宏"></a>类函数宏</h3><p>类函数宏可以让我们定义像函数那样调用的宏，从这个角度来看，它跟声明宏<code>macro_rules</code>较为类似。</p>
<p>区别在于，<code>macro_rules</code>的定义形式与<code>match</code>匹配非常相像，而类函数宏的定义形式则类似于之前讲过的两种过程宏：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sql</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br></pre></td></tr></table></figure>
<p>而使用形式则类似于函数调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sql</span> = sql!(SELECT * FROM users);</span><br></pre></td></tr></table></figure>

<p>Rust内置的类函数宏有：</p>
<ul>
<li><code>assert_eq!</code></li>
<li><code>assert!</code></li>
<li><code>println!</code></li>
<li><code>vec!</code></li>
<li><code>include_str!</code> &#x2F;&#x2F; 包含字符串</li>
<li><code>env!</code> &#x2F;&#x2F; 获取环境变量</li>
<li><code>concat!</code> &#x2F;&#x2F; 连接字符串</li>
<li><code>format!</code> &#x2F;&#x2F; 格式化字符串</li>
<li><code>todo!</code> &#x2F;&#x2F; 生成未实现代码</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>创建声明宏</strong>：使用<code>macro_rules!</code>定义宏，通过模式匹配生成代码</li>
<li><strong>创建过程宏</strong>：使用过程宏函数<code>#[proc_macro]</code>、派生宏<code>#[proc_macro_attribute]</code>和属性宏<code>#[proc_macro_derive]</code>生成代码</li>
</ul>
<p>宏的使用场景：</p>
<ol>
<li><strong>减少重复代码</strong>：宏可以减少重复代码，提高代码的复用性</li>
<li><strong>编译期计算</strong>：宏可以在编译期进行复杂的计算，减少运行时的开销</li>
<li><strong>DSL（领域特定语言）</strong>：宏可以用于创建领域特定语言，提高代码的表达力和可读性</li>
</ol>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求：</span></span><br><span class="line"><span class="comment">// 通过`macro_rules!`宏实现对应的marco，并通过测试case</span></span><br><span class="line"><span class="comment">// assert_eq!(repeat!(&quot;x&quot;, 3), &quot;xxx&quot;);</span></span><br><span class="line"><span class="comment">// assert_eq!(sum!(1, 2, 3, 4, 5), 15);</span></span><br><span class="line"><span class="comment">// assert_eq!(max_value!(1, 8, 9), 9);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> repeat &#123;</span><br><span class="line">    ($item:expr, $n:expr) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..$n &#123;</span><br><span class="line">                result.<span class="title function_ invoke__">push_str</span>(&amp;$item);</span><br><span class="line">            &#125;</span><br><span class="line">            result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> sum &#123;</span><br><span class="line">    ($($x:expr),*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">            $(</span><br><span class="line">                sum += $x;</span><br><span class="line">            )*</span><br><span class="line">            sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> max_value &#123;</span><br><span class="line">    ($first:expr, $($rest:expr),*) =&gt; &#123; <span class="comment">//需要分别处理第一个值和剩余值，第一个值用于初始化sum</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max</span> = $first; </span><br><span class="line">            $(</span><br><span class="line">                <span class="keyword">if</span> $rest &gt; max &#123;</span><br><span class="line">                    max = $rest;</span><br><span class="line">                &#125;</span><br><span class="line">            )*</span><br><span class="line">            max</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(repeat!(<span class="string">&quot;x&quot;</span>, <span class="number">3</span>), <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum!(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(max_value!(<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/28/rust-lifetime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/28/rust-lifetime/" class="post-title-link" itemprop="url">十九、Rust进阶-生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-28 20:09:43" itemprop="dateCreated datePublished" datetime="2024-10-28T20:09:43+00:00">2024-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-13 23:40:46" itemprop="dateModified" datetime="2024-11-13T23:40:46+00:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>在这个章节中，我们将介绍Rust中十分困难的概念：<strong>生命周期</strong>。生命周期，简而言之就是引用的有效作用域，在大部分情况下，我们无需手动的声明生命周期，因为编译器可以自动进行推导；但在一些特殊情况下，在多种类型存在时，如果编译器无法推导出某个引用的生命周期，就需要我们手动标明生命周期。</p>
<h2 id="悬垂指针与生命周期"><a href="#悬垂指针与生命周期" class="headerlink" title="悬垂指针与生命周期"></a>悬垂指针与生命周期</h2><p>让我们来看下面一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">        r = &amp;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码有几点值得注意:<br>·<code>let r</code>; 的声明方式貌似存在使用<code>null</code>的风险，实际上，当我们不初始化它就使用时，编译器会给予报错<br>·<code>r</code>引用了内部花括号中的<code>x</code>变量，但是<code>x</code>会在内部花括号<code>&#125;</code>处被释放，因此回到外部花括号后，<code>r</code>会引用一个无效的<code>x</code><br>·此处<code>r</code>就是一个悬垂指针，它引用了提前被释放的变量<code>x</code>，可以预料到，这段代码会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `x` does not live long enough // `x` 活得不够久</span><br><span class="line">  --&gt; src/main.rs:7:17</span><br><span class="line">   |</span><br><span class="line">7  |             r = &amp;x;</span><br><span class="line">   |                 ^^ borrowed value does not live long enough // 被借用的 `x` 活得不够久</span><br><span class="line">8  |         &#125;</span><br><span class="line">   |         - `x` dropped here while still borrowed // `x` 在这里被丢弃，但是它依然还在被借用</span><br><span class="line">9  |</span><br><span class="line">10 |         println!(&quot;r: &#123;&#125;&quot;, r);</span><br><span class="line">   |                           - borrow later used here // 对 `x` 的借用在此处被使用</span><br></pre></td></tr></table></figure>
<p>在这里<code>r</code>拥有更大的作用域，或者说活得更久。如果<code>Rust</code>不阻止该悬垂引用的发生，那么当<code>x</code>被释放后，<code>r</code>所引用的值就不再是合法的，会导致我们程序发生异常行为，且该异常行为有时候会很难被发现。</p>
<h2 id="借用检查"><a href="#借用检查" class="headerlink" title="借用检查"></a>借用检查</h2><p>为了保证Rust的所有权和借用的正确性，Rust使用了一个借用检查器(Borrow checker)，来检查我们程序的借用正确性：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;                <span class="comment">// ---------+-- &#x27;a</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    &#123;                     <span class="comment">//          |</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;        <span class="comment">// -+-- &#x27;b  |</span></span><br><span class="line">        r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">    &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//          |</span></span><br><span class="line">&#125;                         <span class="comment">// ---------+</span></span><br></pre></td></tr></table></figure>
<p>这段代码和之前的一模一样，唯一的区别在于增加了对变量生命周期的注释。这里，<code>r</code>变量被赋予了生命周期 <code>&#39;a</code>，<code>x</code>被赋予了生命周期<code>&#39;b</code>，从图示上可以明显看出生命周期<code>&#39;b</code>比<code>&#39;a</code>小很多。</p>
<p>在编译期，<code>Rust</code>会比较两个变量的生命周期，结果发现<code>r</code>明明拥有生命周期<code>&#39;a</code>，但是却引用了一个小得多的生命周期<code>&#39;b</code>，在这种情况下，编译器会认为我们的程序存在风险，因此拒绝运行。</p>
<p>如果想要编译通过，也很简单，只要<code>&#39;b</code>比<code>&#39;a</code>大就好。总之，<code>x</code>变量只要比<code>r</code>活得久，那么<code>r</code>就能随意引用<code>x</code>且不会存在危险：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;            <span class="comment">// ----------+-- &#x27;b</span></span><br><span class="line">                          <span class="comment">//           |</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;x;           <span class="comment">// --+-- &#x27;a  |</span></span><br><span class="line">                          <span class="comment">//   |       |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//   |       |</span></span><br><span class="line">                          <span class="comment">// --+       |</span></span><br><span class="line">&#125;                         <span class="comment">// ----------+</span></span><br></pre></td></tr></table></figure>
<p>根据之前的结论，我们重新实现了代码，现在<code>x</code>的生命周期<code>&#39;b</code>大于<code>r</code>的生命周期<code>&#39;a</code>，因此<code>r</code>对<code>x</code>的引用是安全的。</p>
<h2 id="函数中的生命周期"><a href="#函数中的生命周期" class="headerlink" title="函数中的生命周期"></a>函数中的生命周期</h2><p>有代码示例如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>longest</code>函数接受两个字符串切片参数，并返回其中一个更长的字符串切片，看起来是一个十分正常且合理的实现方式，但实际上，编译器会发生报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:9:33</span><br><span class="line">  |</span><br><span class="line">9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">  |               ----     ----     ^ expected named lifetime parameter // 参数需要一个生命周期</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is</span><br><span class="line">  borrowed from `x` or `y`</span><br><span class="line">  = 帮助： 该函数的返回值是一个引用类型，但是函数签名无法说明，该引用是借用自 `x` 还是 `y`</span><br><span class="line">help: consider introducing a named lifetime parameter // 考虑引入一个生命周期</span><br><span class="line">  |</span><br><span class="line">9 | fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">  |           ^^^^    ^^^^^^^     ^^^^^^^     ^^^</span><br></pre></td></tr></table></figure>
<p>在如上的报错中，我们可以发现，主要是编译器无法知道该函数的返回值到底引用<code>x</code>还是<code>y</code>，因为编译器需要知道这些，来确保函数调用后的引用生命周期分析。</p>
<p>但实际上，我们自己也不知道调用该函数时会返回<code>x</code>还是<code>y</code>。自然，编译器也无法推导出返回的引用值的生命周期。因此，正如开头所说，当编译器无法自动推导生命周期时，就需要我们去进行手动标注。</p>
<h2 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a>生命周期标注语法</h2><p>在Rust中，生命周期主要通过生命周期注解来创建和使用。生命周期注解是一种显式声明引用有效时间的方式，通常用<code>&#39;a</code>、<code>&#39;b</code>这样的符号表示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 一个引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 具有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 具有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>
<p>一个生命周期标注，它自身并不具有什么意义，<strong>它并不会改变任何引用的实际作用域</strong>，因为生命周期的作用就是告诉编译器多个引用之间的关系。例如，有一个函数，它的第一个参数<code>first</code>是一个指向<code>i32</code>类型的引用，具有生命周期<code>&#39;a</code>，该函数还有另一个参数<code>second</code>，它也是指向<code>i32</code>类型的引用，并且同样具有生命周期<code>&#39;a</code>。此处生命周期标注仅仅说明，这两个参数<code>first</code>和<code>second</code>至少活得和<code>&#39;a</code>一样久，至于到底活多久或者哪个活得更久，抱歉我们都无法得知：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">useless</span>&lt;<span class="symbol">&#x27;a</span>&gt;(first: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, second: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数签名中的生命周期标注"><a href="#函数签名中的生命周期标注" class="headerlink" title="函数签名中的生命周期标注"></a>函数签名中的生命周期标注</h3><p>让我们回到之前<code>longest</code>函数的例子中，下面展示了正确的声明周期注解：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的点如下：<br>· 和泛型一样，使用生命周期参数，需要先声明<code>&lt;&#39;a&gt;</code>     (随便举一个泛型的例子：<code>fn longest&lt;T&gt;(x: T, y: T) -&gt; T &#123;&#125;</code>)<br>· <code>x</code>、<code>y</code>和返回值<strong>至少</strong>活得和<code>&#39;a</code>一样久（因为返回值要么是<code>x</code>，要么是<code>y</code>）</p>
<p>让我们再具体分析一下上面的例子，我们先声明了生命周期参数<code>&lt;&#39;a&gt;</code>，随后为函数的两个传入参数<code>x</code>和<code>y</code>以及函数的返回值都标注了生命周期参数<code>&#39;a</code>。实际上，这意味着<strong>返回值的生命周期与参数生命周期中的较小值一致</strong>：虽然两个参数的生命周期都是标注了<code>&#39;a</code>，但是实际上这两个参数的真实生命周期可能是不一样的（生命周期<code>&#39;a</code>不代表生命周期等于<code>&#39;a</code>，而是大于等于<code>&#39;a</code>）。</p>
<p>当把具体的引用传给<code>longest</code>时，那生命周期<code>&#39;a</code>的大小就是<code>x</code>和<code>y</code>的作用域的重合部分，换句话说，<code>&#39;a</code>的大小将等于<code>x</code>和<code>y</code>中较小的那个。由于返回值的生命周期也被标记为<code>&#39;a</code>，因此返回值的生命周期也是<code>x</code>和<code>y</code>中作用域较小的那个。</p>
<p>让我们再来看一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上例中，<code>string1</code>的作用域直到<code>main</code>函数的结束，而<code>string2</code>的作用域到内部花括号的结束<code>&#125;</code>，那么根据之前的理论，<code>&#39;a</code>是两者中作用域较小的那个，也就是<code>&#39;a</code>的生命周期等于<code>string2</code>的生命周期，同理，由于函数返回的生命周期也是<code>&#39;a</code>，可以得出函数返回的生命周期也等于<code>string2</code>的生命周期。</p>
<p>现在来验证下上面的结论：result 的生命周期等于参数中生命周期最小的，因此要等于 string2 的生命周期，也就是说，result 要活得和 string2 一样久，观察下代码的实现，可以发现这个结论是正确的！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，按照我们上面的结论，自然而然地编译器报错了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `string2` does not live long enough</span><br><span class="line"> --&gt; src/main.rs:6:44</span><br><span class="line">  |</span><br><span class="line">6 |         result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">  |                                            ^^^^^^^ borrowed value does not live long enough</span><br><span class="line">7 |     &#125;</span><br><span class="line">  |     - `string2` dropped here while still borrowed</span><br><span class="line">8 |     println!(&quot;The longest string is &#123;&#125;&quot;, result);</span><br><span class="line">  |                                          ------ borrow later used here</span><br></pre></td></tr></table></figure>
<p>该代码成功打印出<code>result</code>的前提是它的生命周期能够达到<code>println!()</code>这一行。但<code>result</code>的生命周期为<code>&#39;a</code>，是<code>string1</code>和<code>string2</code>两个传入参数的生命周期的最小值。这说明，只有<code>string2</code>的生命周期能够达到<code>println!()</code>，<code>result</code>才能成功打印，但很可惜的是<code>string2</code>只能活到内部语句块的花括号<code>&#125;</code>处，因而编译出错。</p>
<h2 id="结构体和枚举中的生命周期"><a href="#结构体和枚举中的生命周期" class="headerlink" title="结构体和枚举中的生命周期"></a>结构体和枚举中的生命周期</h2><p>不仅仅函数具有生命周期，在结构体和枚举enum中都有这个概念。在之前我们对结构体的使用中都尽量规避了没有所有权的引用类型，因而不需要加上生命周期标注。但如果我们想要在结构体或者是枚举中使用引用，那我们就需要为其中的每一个引用标注上生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ImportantExcerpt</code>结构体中有一个引用类型的字段<code>part</code>，因此需要为它标注上生命周期。结构体的生命周期标注语法跟泛型参数语法很像，需要对生命周期参数进行声明<code>&lt;&#39;a&gt;</code>。该生命周期标注说明，结构体 <code>ImportantExcerpt</code>所引用的字符串<code>str</code>生命周期需要大于等于该结构体的生命周期。</p>
<p>从<code>main</code>函数实现来看，<code>ImportantExcerpt</code>的生命周期从第<code>4</code>行开始，到<code>main</code>函数末尾结束，而该结构体引用的字符串从第一行开始，也是到<code>main</code>函数末尾结束，可以得出结论结构体引用的字符串生命周期大于等于结构体，这符合了编译器对生命周期的要求，因此编译通过。</p>
<p>与之相反，下面的代码就无法通过编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">        i = ImportantExcerpt &#123;</span><br><span class="line">            part: first_sentence,</span><br><span class="line">        &#125;;  <span class="comment">// first_sentence生命周期结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,i);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>我们观察代码可以发现，该结构体中的引用字段的生命周期在内部花括号处生命周期就结束了。但是后续该结构体<code>i</code>又被使用了，因此会导致无效的引用，编译报错。</p>
<p>如果我们想要在结构体或<code>enum</code>中使用多个具有不同生命周期的引用，就需要为每一个引用进行生命周期标注：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">StringOption</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>((&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>)),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法中的生命周期"><a href="#方法中的生命周期" class="headerlink" title="方法中的生命周期"></a>方法中的生命周期</h2><p>既然在枚举和结构体中可以使用生命周期标注的引用，那么，我们自然也西药为具有生命周期的结构体实现方法。在实现时，我们使用的语法也与泛型参数的语法相似：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们需要在<code>impl</code>后加上<code>&lt;&#39;a&gt;</code>来声明该方法的实现需要用到生命周期。其次，<code>impl</code>中必须使用结构体的完整名称，包括<code>&lt;&#39;a&gt;</code>，因为生命周期标注也是结构体类型的一部分！</p>
<p>如果有多种参数，示例如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">StringOption</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>((&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>)),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; StringOption&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期消除（Lifetime-Elision）"><a href="#生命周期消除（Lifetime-Elision）" class="headerlink" title="生命周期消除（Lifetime Elision）"></a>生命周期消除（Lifetime Elision）</h2><p>对于编译器来说，每一个引用类型都存在一个与之对应的生命周期，但我们在实际的使用过程中，很多时候我们并不需要标注生命周期，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该该函数的参数和返回值都是引用类型，尽管我们没有显式的为其标注生命周期，编译依然可以通过。</p>
<p>这是因为，Rust为我们提供了<strong>三条生命周期的消除规则</strong>：</p>
<p><strong>编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期</strong>。其中第一条规则应用在输入生命周期上，第二、三条应用在输出生命周期上。若编译器发现三条规则都不适用时，就会报错，提示你需要手动标注生命周期。</p>
<ol>
<li><p>每个引用参数都有自己的生命周期参数。</p>
</li>
<li><p>如果只有一个输入引用参数，那么它的生命周期会被赋予所有输出引用。</p>
</li>
<li><p>如果有多个输入生命周期参数，但其中一个是<code>&amp;self</code>或<code>&amp;mut self</code>，那么<code>self</code>的生命周期会被赋予所有输出引用。</p>
</li>
</ol>
<p>三条规则实际上都很好理解，但是当实际情况与规则发生一定的冲突时，我们应该怎么办呢？如第三条规则，若一个方法，它的返回值的生命周期就是跟参数<code>&amp;self</code>的不一样怎么办？这时候我们就需要<strong>手动标注生命周期</strong>，因为这些规则只是<strong>编译器发现你没有标注生命周期时默认去使用的</strong>，当你标注生命周期后，编译器自然会乖乖听你的话。</p>
<p>让我们再举一些例子，带入编译器的视角理解引用这些规则：</p>
<h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123; </span><br></pre></td></tr></table></figure>
<p>有代码如上，编译器会首先应用第一条规则，为每个参数标注一个生命周期:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123; <span class="comment">// 编译器自动为参数添加生命周期</span></span><br></pre></td></tr></table></figure>
<p>此时，第二条规则就可以进行应用，因为函数只有一个输入生命周期，因此该生命周期会被赋予所有的输出生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123; <span class="comment">// 编译器自动为返回值添加生命周期</span></span><br></pre></td></tr></table></figure>
<p>此时，编译器为函数签名中的所有引用都自动添加了具体的生命周期，因此编译通过，且用户无需手动去标注生命周期，只要按照<code>fn first_word(s: &amp;str) -&gt; &amp;str &#123;</code>的形式写代码即可。</p>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123; </span><br></pre></td></tr></table></figure>
<p>首先，编译器会应用第一条规则，为每个参数都标注生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>
<p>但是此时，第二条规则却无法被使用，因为输入生命周期有两个，第三条规则也不符合，因为它是函数，不是方法，因此没有<code>&amp;self</code>参数。在套用所有规则后，编译器依然无法为返回值标注合适的生命周期，因此，编译器就会报错，提示我们需要手动标注生命周期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:1:47</span><br><span class="line">  |</span><br><span class="line">1 | fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;str &#123;</span><br><span class="line">  |                       -------     -------     ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span><br><span class="line">note: these named lifetimes are available to use</span><br><span class="line"> --&gt; src/main.rs:1:12</span><br><span class="line">  |</span><br><span class="line">1 | fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;str &#123;</span><br><span class="line">  |            ^^  ^^</span><br><span class="line">help: consider using one of the available lifetimes here</span><br><span class="line">  |</span><br><span class="line">1 | fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;lifetime str &#123;</span><br><span class="line">  |                                                +++++++++</span><br></pre></td></tr></table></figure>

<h2 id="静态生命周期标注"><a href="#静态生命周期标注" class="headerlink" title="静态生命周期标注"></a>静态生命周期标注</h2><p>在 Rust 中有一个非常特殊的生命周期，那就是<code>&#39;static</code>，它表示整个程序运行期间都有效的生命周期。这通常用于全局变量或字符串字面量。</p>
<p>在之前我们学过字符串字面量，提到过它是被硬编码进Rust的二进制文件中，因此这些字符串变量全部具有<code>&#39;static</code>的生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;我没啥优点，就是活得久，嘿嘿&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>还有如下常量的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SOME_COORDINATE: (<span class="type">i32</span>, <span class="type">i32</span>) = (<span class="number">7</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">static_reference</span>: &amp;<span class="symbol">&#x27;static</span>(<span class="type">i32</span>, <span class="type">i32</span>) = &amp;SOME_COORDINATE;</span><br></pre></td></tr></table></figure>

<h2 id="特殊生命周期标注"><a href="#特殊生命周期标注" class="headerlink" title="特殊生命周期标注"></a>特殊生命周期标注</h2><p>当我们在为带有生命周期的结构体或者枚举实现方法或函数时，如果我们不关心生命周期本身，那么我们就可以应用占位符<code>_</code>替换生命周期标注：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    counter: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span>&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">increment</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        *<span class="keyword">self</span>.counter += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期约束"><a href="#生命周期约束" class="headerlink" title="生命周期约束"></a>生命周期约束</h2><p>让我们来看下面这个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，我们可以发现，该函数<code>announce_and_return_part</code>存在两个生命周期标注<code>&#39;a</code>和<code>&#39;b</code>，但是在该函数中，并不满足我们之前提到的三条规则，因而编译器无法知道<code>&#39;a</code>和<code>&#39;b</code>的关系。在该函数中，返回的<code>&amp;&#39;b str</code>实际上是<code>self.part</code>，因此我们实际上显然需要生命周期<code>&#39;a</code>比<code>&#39;b</code>大，因此，我们需要进行生命周期的约束：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;b</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码示例中：<br>· <code>&#39;a: &#39;b</code>，是生命周期约束语法，跟泛型约束非常相似，用于说明<code>&#39;a</code>必须比<code>&#39;b</code>活得久<br>· 可以把<code>&#39;a</code>和<code>&#39;b</code>都在同一个地方声明（如上），或者分开声明但通过<code>where &#39;a: &#39;b</code>约束生命周期关系，如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期子类型和协变"><a href="#生命周期子类型和协变" class="headerlink" title="生命周期子类型和协变"></a>生命周期子类型和协变</h2><p>生命周期可以有子类型关系，较短的生命周期可以被视为较长的生命周期的子类型。这在协变（covariance）中尤为重要‼️</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">example</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y:&amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> </span><br><span class="line"><span class="keyword">where</span> <span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>,</span><br><span class="line">&#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>下面是一段十分有问题的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_mut</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>) &#123;</span><br><span class="line">        my_vec.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span> = <span class="built_in">vec!</span>[&amp;x];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my vec: &#123;my_vec:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，最大的问题便是我们使用了不同的生命周期标注<code>&#39;a</code>和<code>&#39;b</code>。对于<code>&amp;y</code>，编译器在没有明确指示的情况下默认它在执行完<code>insert_value(&amp;mut my_vec, &amp;y);</code>语句后就已经自动<code>drop</code><br>掉了。因此在后续打印时出现了无效的引用。因此，我们需要通过生命周期约束告诉编译器<code>&amp;y</code>的生命周期<code>&#39;b</code>需要大于等于<code>&#39;a</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_mut</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>) &#123;</span><br><span class="line">        my_vec.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span> = <span class="built_in">vec!</span>[&amp;x];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my vec: &#123;my_vec:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，我们也可以简单的使用<code>fn insert_value&lt;&#39;a&gt;(my_vec: &amp;mut Vec&lt;&amp;&#39;a i32&gt;, value: &amp;&#39;a i32) &#123;</code>来告诉编译器两个生命周期相同，编译器就不再会报错。</p>
<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_multiple</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>) &#123; <span class="comment">// 使用&#x27;a和&#x27;b两个生命周期参数,</span></span><br><span class="line">        my_vec.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val1</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val2</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = &amp;<span class="keyword">mut</span> my_vec;</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(a, &amp;val1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a is &#123;:?&#125;&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = &amp;<span class="keyword">mut</span> my_vec;</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(b, &amp;val2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b is &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, my_vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/26/rust-trait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/26/rust-trait/" class="post-title-link" itemprop="url">十八、Rust进阶-特征</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-26 16:19:45" itemprop="dateCreated datePublished" datetime="2024-10-26T16:19:45+01:00">2024-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-13 23:46:46" itemprop="dateModified" datetime="2024-11-13T23:46:46+00:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="特征-Trait"><a href="#特征-Trait" class="headerlink" title="特征 Trait"></a>特征 Trait</h1><p>trait定义了某个特定类型拥有可能与其他类型共享的功能。（有点类似于其他语言中的接口（interfaces），虽然存在些许不同）</p>
<h2 id="定义的特征与实现"><a href="#定义的特征与实现" class="headerlink" title="定义的特征与实现"></a>定义的特征与实现</h2><p>让我们来看下面一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们使用<code>trait</code>关键字来声明一个特征，其中<code>Summary</code>是特征名，在大括号中定义了该特征的所有方法。</p>
<p>特征只定义行为看起来是什么样的，而不定义行为具体是怎么样的。因此，我们只定义特征方法的签名，而不进行实现，此时方法签名结尾是 ;，而不是一个 {}。</p>
<p>接下来，每一个实现这个特征的类型都需要具体实现该特征的相应方法，编译器也会确保任何实现<code>Summary</code>特征的类型<strong>都</strong>拥有与这个签名的定义完全一致的<code>summarize</code>方法。</p>
<h2 id="为类型实现特征"><a href="#为类型实现特征" class="headerlink" title="为类型实现特征"></a>为类型实现特征</h2><p>接下来，我们为每一个类型都实现具体的特征：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>, <span class="comment">// 标题</span></span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>, <span class="comment">// 作者</span></span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>, <span class="comment">// 内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;</span>, <span class="keyword">self</span>.title, <span class="keyword">self</span>.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;发表了微博&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现特征的语法与为结构体、枚举实现方法很像：<code>impl Summary for Post</code>，读作“为<code>Post</code>类型实现<code>Summary</code>特征”，然后在<code>impl</code>的花括号中实现该特征的具体方法。</p>
<p>既然已经为类型实现了特征，接下来我们就可以在类型上调用特征的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post</span> = Post&#123;title: <span class="string">&quot;Rust语言简介&quot;</span>.<span class="title function_ invoke__">to_string</span>(),author: <span class="string">&quot;Sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(), content: <span class="string">&quot;Rust棒极了!&quot;</span>.<span class="title function_ invoke__">to_string</span>()&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">weibo</span> = Weibo&#123;username: <span class="string">&quot;sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(),content: <span class="string">&quot;好像微博没Tweet好用&quot;</span>.<span class="title function_ invoke__">to_string</span>()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,post.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,weibo.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码后，会输出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文章 Rust 语言简介, 作者是Sunface</span><br><span class="line">sunface发表了微博好像微博没Tweet好用</span><br></pre></td></tr></table></figure>

<h3 id="孤儿规则——特征定义和实现的位置"><a href="#孤儿规则——特征定义和实现的位置" class="headerlink" title="孤儿规则——特征定义和实现的位置"></a>孤儿规则——特征定义和实现的位置</h3><p>上面我们将<code>Summary</code>定义成了<code>pub</code>公开的。这样，如果他人想要使用我们的<code>Summary</code>特征，则可以引入到他们的包中，然后再进行实现。</p>
<p>关于特征实现与定义的位置，有一条非常重要的原则：如果你想要为<strong>类型<code>A</code>实现特征<code>T</code>，那么<code>A</code>或者<code>T</code>至少有一个是在当前作用域中定义的！</strong> 例如我们可以为上面的<code>Post</code>类型实现标准库中的<code>Display</code>特征，这是因为<code>Post</code>类型定义在当前的作用域中。同时，我们也可以在当前包中为<code>String</code>类型实现<code>Summary</code>特征，因为<code>Summary</code>定义在当前作用域中。</p>
<p>但是你无法在当前作用域中，为<code>String</code>类型实现<code>Display</code>特征，因为它们俩都定义在标准库中，其定义所在的位置都不在当前作用域。</p>
<p>该规则被称为<strong>孤儿规则</strong>，可以确保其它人编写的代码不会破坏你的代码，也确保了你不会莫名其妙就破坏了风马牛不相及的代码。</p>
<h3 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h3><p>实际上，我们可以在特征中定义具有<code>默认实现</code>的方法，这样其他类型就无需再次实现该方法，或者我们也可以选择重载该方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们为特征<code>Summary</code>定义了一个默认实现，下面继续：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Post</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;发表了微博&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,post.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,weibo.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Post</code>选择了默认实现，而<code>Weibo</code>重载了该方法，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Read more...)</span><br><span class="line">sunface发表了微博好像微博没Tweet好用</span><br></pre></td></tr></table></figure>

<p>同时，<strong>默认实现允许调用相同特征中的其他方法，哪怕这些方法没有默认实现</strong>。如此，特征可以提供很多有用的功能而只需要实现指定的一小部分内容。例如，我们可以定义<code>Summary</code>特征，使其具有一个需要实现的<code>summarize_author</code>方法，然后定义一个<code>summarize</code>方法，此方法的默认实现调用<code>summarize_author</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用<code>Summary</code>，只需要实现<code>summarize_author</code>方法即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;1 new weibo: &#123;&#125;&quot;</span>, weibo.<span class="title function_ invoke__">summarize</span>());</span><br></pre></td></tr></table></figure>
<p>此时，<code>weibo.summarize()</code>会先调用<code>Summary</code>特征默认实现的<code>summarize</code>方法，通过该方法进而调用<code>Weibo</code>为<code>Summary</code>实现的<code>summarize_author</code>方法，最终输出：<code>1 new weibo: (Read more from @horse_ebooks...)</code>。</p>
<h2 id="带泛型的trait"><a href="#带泛型的trait" class="headerlink" title="带泛型的trait"></a>带泛型的trait</h2><p>如果我们需要在特征trait中使用泛型参数<code>T</code>，则需要在定义时使用尖括号注明。同时，我们可以针对不同的参数类型，为特征实现具体的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Converter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyInt</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span>&lt;<span class="type">f32</span>&gt; <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span> <span class="keyword">as</span> <span class="type">f32</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_int</span> = <span class="title function_ invoke__">MyInt</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span>: <span class="type">String</span> = my_int.<span class="title function_ invoke__">convert</span>();  <span class="comment">//需要显式标出output的类型</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;output is: &#123;&#125;&quot;</span>, output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span>: <span class="type">f32</span> = my_int.<span class="title function_ invoke__">convert</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;output is: &#123;&#125;&quot;</span>, output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在这里是带泛型的trait，而在上一节中我们实现过带泛型的方法，其语法是：<code>impl&lt;T&gt; Struct&lt;T&gt; &#123;&#125;</code>，这里我们需要注意区分。</p>
<h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><p>关联类型是trait定义中的类型占位符。定义的时候，并不定义它的具体类型是什么。当我们使用<code>impl</code>实现该trait的时候，才为这个关联类型赋予了确定的类型。同时，关联类型的方式只允许对目标类型实现一次。</p>
<p>让我们来看如下的代码示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Converter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyInt</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span> <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;   <span class="comment">//赋予具体的String类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span> <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">f32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>::Output &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span> <span class="keyword">as</span> <span class="type">f32</span></span><br><span class="line">    &#125;       <span class="comment">//无法实现，因为关联类型的方式只允许对目标类型实现一次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认泛型类型参数"><a href="#默认泛型类型参数" class="headerlink" title="默认泛型类型参数"></a>默认泛型类型参数</h2><p>让我们回顾上一节泛型的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">2i8</span>, <span class="number">3i8</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">1.23</span>, <span class="number">1.23</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码示例中，实际上传入该函数的参数有限制：<code>add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;</code>。即该泛型<code>T</code>需要实现Add这个特征：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;Rhs = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span>: Output;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Rhs) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实现<code>Add</code>trait时如果我们不指定<code>Rhs</code>的具体类型，<code>Rhs</code>的类型将是默认的<code>Self</code>类型，也就是在其上实现<code>Add</code>的类型。实际上，<code>Rhs</code>就是一个泛型类型参数，代表了<code>Add</code>trait中的<strong>右操作数类型</strong>（Right-hand side type）。</p>
<p>有如下的代码示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>;</span><br><span class="line">    y: <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = <span class="title function_ invoke__">add</span>(Point&#123;x:<span class="number">1</span>, y:<span class="number">0</span>&#125;, <span class="title function_ invoke__">Point</span>(x:<span class="number">2</span>, y:<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;p3.x&#125;, y: &#123;p3.y&#125;&quot;</span>);   <span class="comment">//x: 3, y: 3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码示例中，我们在实现<code>Add</code>trait的方法时并没有指定<code>Rhs</code>的类型，因此，<code>Rhs</code>的类型就是默认的<code>Self</code>类型，即<code>Point</code>。</p>
<p>自定义<code>Rhs</code>类型而不是使用默认类型的例子如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meters&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Meters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> + (other.<span class="number">0</span> * <span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在上面的代码示例中，我们通过<code>impl Add&lt;Meters&gt; for Millimeters &#123;&#125;</code>来指定了<code>Rhs</code>类型为新的类型<code>Meters</code>，从而实现了两个不同类型<code>Millimeters</code>和<code>Meters</code>之间的相加。</p>
<h2 id="使用特征作为函数参数"><a href="#使用特征作为函数参数" class="headerlink" title="使用特征作为函数参数"></a>使用特征作为函数参数</h2><p>特征不仅仅可以用来实现方法，它还可以作为函数参数的特征使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>impl Summary</code>来表示：<strong>实现了<code>Summary</code>特征</strong>的<code>item</code>参数。</p>
<p>此时，我们可以使用任何实现了<code>Summary</code>特征的类型作为该函数的参数，同时在函数体内，还可以调用该特征的方法。例如<code>summarize</code>方法。具体的说，可以传递<code>Post</code>或<code>Weibo</code>的实例来作为参数，而其它类如 <code>String</code>或者<code>i32</code>的类型则不能用做该函数的参数，因为它们没有实现<code>Summary</code>特征。</p>
<h2 id="特征约束（trait-bound）"><a href="#特征约束（trait-bound）" class="headerlink" title="特征约束（trait bound）"></a>特征约束（trait bound）</h2><p>虽然上面的<code>impl trait</code>这种语法十分好理解，但是它实际上只是一个语法糖：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的完整书写形式如上所述。而上面形如<code>T: Summary</code>的表达被称为<strong>特征约束</strong>。</p>
<p>在简单的场景下<code>impl Trait</code>这种语法糖就足够使用，但是对于复杂的场景，特征约束可以让我们拥有更大的灵活性和语法表现能力，例如一个函数接受两个<code>impl Summary</code>的参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item1: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数两个参数是不同的类型，那么上面的方法很好，只要这两个类型都实现了<code>Summary</code>特征即可。但是如果我们想要强制函数的两个参数是同一类型呢？上面的语法就无法做到这种限制，此时我们只能使特征约束来实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>泛型类型<code>T</code>说明了<code>item1</code>和<code>item2</code>必须拥有同样的类型，同时<code>T: Summary</code>说明了<code>T</code>必须实现<code>Summary</code>特征。</p>
<h3 id="多重约束"><a href="#多重约束" class="headerlink" title="多重约束"></a>多重约束</h3><p>除了单个约束条件，我们还可以指定多个约束条件，例如除了让参数实现<code>Summary</code>特征外，还可以让参数实现<code>Display</code>特征以控制它的格式化输出：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>除了上述的语法糖形式，还能使用特征约束的形式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>通过这两个特征，就可以使用<code>item.summarize</code>方法，以及通过<code>println!(&quot;&#123;&#125;&quot;, item)</code>来格式化输出<code>item</code>。</p>
<h3 id="Where约束"><a href="#Where约束" class="headerlink" title="Where约束"></a>Where约束</h3><p>当特征约束变得很多时，函数的签名将变得很复杂：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>严格来说，上面的例子还是不够复杂，但是我们还是能对其做一些形式上的改进，通过<code>where</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用特征约束有条件地实现方法或特征"><a href="#使用特征约束有条件地实现方法或特征" class="headerlink" title="使用特征约束有条件地实现方法或特征"></a>使用特征约束有条件地实现方法或特征</h3><p>特征约束，可以让我们在指定类型 + 指定特征的条件下去实现方法，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;   <span class="comment">//为所有Pair&lt;T实现了new方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;     <span class="comment">//仅为满足T：Display + PartialOrd的Pair&lt;T实现了cmd_display方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们可以发现，<code>cmp_display</code>方法，并不是所有的<code>Pair&lt;T&gt;</code>结构体对象都可以拥有，只有<code>T</code>同时实现了<code>Display + PartialOrd</code>的<code>Pair&lt;T&gt;</code>才可以拥有此方法。该函数可读性会更好，因为泛型参数、参数、返回值都在一起，可以快速的阅读，同时每个泛型参数的特征也在新的代码行中通过特征约束进行了约束。</p>
<p>也可以有条件地实现特征，例如，标准库为任何实现了<code>Display</code>特征的类型实现了<code>ToString</code>特征：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以对任何实现了<code>Display</code>特征的类型调用由<code>ToString</code>定义的<code>to_string</code>方法。例如，可以将整型转换为对应的<code>String</code>值，因为整型实现了<code>Display</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="number">3</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>

<h2 id="函数返回中的impl-Trait"><a href="#函数返回中的impl-Trait" class="headerlink" title="函数返回中的impl Trait"></a>函数返回中的impl Trait</h2><p>在上面我们讲述了trait在函数入参中的使用。实际上我们还可以通过<code>impl Trait</code> 来说明一个函数返回了实现了某个特征的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Weibo &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sunface&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">&quot;m2 air也不错&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>Weibo</code>实现了<code>Summary</code>，因此这里可以用它来作为返回值。要注意的是，虽然我们知道这里是一个<code>Weibo</code>类型，但是对于<code>returns_summarizable</code>的调用者而言，他只知道返回了一个实现了<code>Summary</code>特征的对象，但是并不知道返回了一个<code>Weibo</code>类型。</p>
<p>这种<code>impl Trait</code>形式的返回值，在一种场景下非常非常有用，那就是返回的真实类型非常复杂，你不知道该怎么声明时（毕竟<code>Rust</code>要求你必须标出所有的类型），此时就可以用<code>impl Trait</code>的方式简单返回。例如，闭包和迭代器就是很复杂，只有编译器才知道那玩意的真实类型，如果让你写出来它们的具体类型，估计内心有一万只草泥马奔腾，好在你可以用<code>impl Iterator</code>来告诉调用者，返回了一个迭代器，因为所有迭代器都会实现<code>Iterator</code>特征。</p>
<p>但是这种返回值方式有一个很大的限制：只能有一个具体的类型，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        Post &#123;</span><br><span class="line">            title: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">            author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;The Pittsburgh Penguins once again are the best \</span></span><br><span class="line"><span class="string">                 hockey team in the NHL.&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Weibo &#123;</span><br><span class="line">            username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码就无法通过编译，因为它返回了两个不同的类型<code>Post</code>和<code>Weibo</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`if` and `else` have incompatible types</span><br><span class="line">expected struct `Post`, found struct `Weibo`</span><br></pre></td></tr></table></figure>
<p>报错提示我们<code>if</code>和<code>else</code>返回了不同的类型。如果想要实现返回不同的类型，需要<strong>特征对象</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Summary&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">       <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Post &#123;</span><br><span class="line">            title: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">            author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;The Pittsburgh Penguins once again are the best \</span></span><br><span class="line"><span class="string">                 hockey team in the NHL.&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Weibo &#123;</span><br><span class="line">            username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过dereive派生特征"><a href="#通过dereive派生特征" class="headerlink" title="通过dereive派生特征"></a>通过<code>dereive</code>派生特征</h2><p>在先前的Rust学习过程中，形如<code>#[derive(Debug)]</code>的代码已经出现了很多次，这种是一种特征派生语法，被<code>derive</code>标记的对象会自动实现对应的默认特征代码，继承相应的功能。</p>
<p>例如<code>Debug</code>trait，它用于开启格式化字符串中的调试格式，其通过在<code>&#123;&#125;</code>占位符中增加<code>:?</code>表明。<code>Debug</code>trait允许以调试目的来打印一个类型的实例，所以使用该类型的程序员可以在程序执行的特定时间点观察其实力。例如，在使用<code>assert_eq!</code>宏的时候，<code>Debug</code>trait是必须的，如果等式断言失败，这个宏就需要把给定实例的值作为参数打印出来，如此程序员可以看到两个实例为什么不相等。</p>
<p>还有<code>Default</code>trait，它可以使你创建一个类型的默认值。派生<code>Default</code>实现了<code>default</code>函数。<code>default</code>函数的派生实现调用了类型每部分的<code>default</code>函数，这意味着只有类型中所有的字段或值实现了<code>Dafault</code>时，才能够为该类型派生<code>Default</code>。<br><code>Default::default</code>函数通常结合结构体更新语法一起使用，可以自定义一个结构体的小部分字段而剩余字段则使用<code>..Default::default()</code>设置为默认值。</p>
<p>再如<code>Copy</code>特征，它也有一套自动实现的默认代码，当标记到一个类型上时，可以让这个类型自动实现<code>Copy</code>特征，进而可以调用<code>copy</code>方法，进行自我复制。</p>
<p>总之，<code>derive</code>派生出来的是Rust默认给我们提供的特征，在开发过程中极大的简化了自己手动实现相应特征的需求，当然，如果你有特殊的需求，还可以自己手动重载该实现。</p>
<p>详细的<code>derive</code>列表参见附录-<a href="">派生特征</a>。</p>
<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要更改Item的定义</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Item</span>&lt;T = <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>: Display;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apple结构的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;   <span class="comment">// 需要指定Output为String类型，否则会报错</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Weibo结构的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;   <span class="comment">// 需要指定Output为String类型，否则会报错   </span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;:&#123;&#125;&quot;</span>, <span class="keyword">self</span>.author, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    items: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Item&lt;Output = <span class="type">String</span>&gt;&gt;&gt;,  <span class="comment">// 将原先的Vec&lt;Item&gt;改为Vec&lt;Box&lt;dyn Item&lt;Output = String&gt;&gt;&gt;，因为Rust不支持直接在向量中存储动态大小的类型DST</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iterator</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> <span class="keyword">self</span>.items.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">apple</span> = Apple &#123;</span><br><span class="line">        name: <span class="string">&quot;Apple&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = Weibo &#123;</span><br><span class="line">        author: <span class="string">&quot;Weibo&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">container</span> = Container &#123;</span><br><span class="line">        items: <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(apple), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(w)], <span class="comment">// 将原先的vec![apple, w]改为vec![Box::new(apple), Box::new(w)]，因为Rust不支持直接在向量中存储动态大小的类型DST</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    container.<span class="title function_ invoke__">iterator</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>









      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

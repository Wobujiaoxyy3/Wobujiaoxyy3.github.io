<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Wobujiaoxyy3">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Wobujiaoxyy3">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Wobujiaoxyy3</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wobujiaoxyy3</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/26/rust-generics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/26/rust-generics/" class="post-title-link" itemprop="url">十七、Rust进阶-泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-26 21:08:57 / Modified: 23:16:25" itemprop="dateCreated datePublished" datetime="2024-10-26T21:08:57+08:00">2024-10-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="泛型Generics"><a href="#泛型Generics" class="headerlink" title="泛型Generics"></a>泛型Generics</h1><p>在Rust中，泛型和特征是Rust中最最重要的抽象类型。</p>
<p>我们在编程中，经常有这样的需求：用同一功能的函数处理不同类型的数据，例如两个数的加法，无论是整数还是浮点数，甚至是自定义类型，都能进行支持。在不支持泛型的编程语言中，通常需要为每一种类型编写一个函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_i8</span>(a:<span class="type">i8</span>, b:<span class="type">i8</span>) <span class="punctuation">-&gt;</span> <span class="type">i8</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_i32</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_f64</span>(a:<span class="type">f64</span>, b:<span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_i8</span>(<span class="number">2i8</span>, <span class="number">3i8</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_i32</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_f64</span>(<span class="number">1.23</span>, <span class="number">1.23</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的代码可以正常运行，但是十分啰嗦。但当我们有了<strong>泛型</strong>之后，事情就变得不太一样了。</p>
<p>当使用<strong>泛型</strong>定义函数时，本来在函数签名中指定参数类型和返回值类型的地方，会改用泛型来表示。采用这种技术，可以使得代码的适应性更强，从而为函数的调用者提供更多的功能，同时也避免了代码的重复。</p>
<p>我们可以来看下面的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">2i8</span>, <span class="number">3i8</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">1.23</span>, <span class="number">1.23</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型详解"><a href="#泛型详解" class="headerlink" title="泛型详解"></a>泛型详解</h2><p>在上面的代码示例中，<code>T</code>就是<strong>泛型参数</strong>，实际上在Rust中，泛型参数的名称你可以任意起，但是出于惯例，我们都用<code>T</code>（<code>T</code>是<code>type</code>的首字母）来作为首选，这个名称越短越好，除非需要表达含义，否则一个字母是最完美的。</p>
<p>使用泛型参数有一个先决条件，就是必须要在使用前对其进行声明：<code>fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) -&gt; T &#123;</code></p>
<p>同时，在上面的代码示例中，我们可以发现，我们使用<code>T: std::ops::Add&lt;Output = T</code>对类型<code>T</code>进行了限制，因为不是所有的<code>T</code>类型都能进行相加操作。通过如上的代码我们告诉编译器传入的参数可以进行相加操作。</p>
<h2 id="在函数定义中使用泛型"><a href="#在函数定义中使用泛型" class="headerlink" title="在函数定义中使用泛型"></a>在函数定义中使用泛型</h2><p>让我们再来看一下下面这个函数定义的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0369]: binary operation `&gt;` cannot be applied to type `T` // `&gt;`操作符不能用于类型`T`</span><br><span class="line"> --&gt; src/main.rs:5:17</span><br><span class="line">  |</span><br><span class="line">5 |         if item &gt; largest &#123;</span><br><span class="line">  |            ---- ^ ------- T</span><br><span class="line">  |            |</span><br><span class="line">  |            T</span><br><span class="line">  |</span><br><span class="line">help: consider restricting type parameter `T` // 考虑对T进行类型上的限制 :</span><br><span class="line">  |</span><br><span class="line">1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">  |             ++++++++++++++++++++++</span><br></pre></td></tr></table></figure>
<p>通过报错信息，我们可以发现，由于<code>T</code>可以是任何类型，但并不是任何类型都可以相比较，因此，我们需要使用<code>fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T &#123;</code>对<code>T</code>的类型进行限制。 </p>
<h2 id="结构体定义中的泛型"><a href="#结构体定义中的泛型" class="headerlink" title="结构体定义中的泛型"></a>结构体定义中的泛型</h2><p><strong>声明</strong>：结构体名称后面的尖括号中声明泛型参数的名称，结构体定义中可以指定具体数据类型的位置。</p>
<p>在下面的例子中，将展示一个结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>x</code>和<code>y</code>必须得是相同的类型，如果使用不同的类型，那么就会导致下面代码的报错：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point&#123;x: <span class="number">1</span>, y :<span class="number">1.1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types //类型不匹配</span><br><span class="line"> --&gt; src/main.rs:7:28</span><br><span class="line">  |</span><br><span class="line">7 |     let p = Point&#123;x: 1, y :1.1&#125;;</span><br><span class="line">  |                            ^^^ expected integer, found floating-point number //期望y是整数，但是却是浮点数</span><br></pre></td></tr></table></figure>
<p>这是因为当我们把<code>1</code>赋值给<code>x</code>时，变量<code>p</code>的<code>T</code>类型就被确定为整数类型，因此<code>y</code>也必须是整数类型，但是我们却给它赋予了浮点数，因此导致报错。</p>
<p>但如果我们偏偏想要<code>x</code>和<code>y</code>既能类型相同，又能类型不同时，应该怎么办呢？ ————&gt; 使用不同的泛型参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T,U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point&#123;x: <span class="number">1</span>, y :<span class="number">1.1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在方法中使用泛型"><a href="#在方法中使用泛型" class="headerlink" title="在方法中使用泛型"></a>在方法中使用泛型</h2><p>在方法中，我们也可以使用泛型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型参数前，依然需要提前声明：<code>impl&lt;T&gt;</code>，只有提前声明了，我们才能在<code>Point&lt;T&gt;</code>中使用它，这样Rust就知道<code>Point</code>的尖括号中的类型是泛型而不是具体类型。需要注意的是，这里的<code>Point&lt;T&gt; </code>不再是泛型声明，而是一个完整的结构体类型，因为我们定义的结构体就是<code>Point&lt;T&gt;</code>而不再是<code>Point</code>。</p>
<p>除了结构体中的泛型参数，我们还能在该结构体的方法中定义额外的泛型参数，就跟泛型函数一样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y); <span class="comment">//p3.x = 5, p3.y = c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>T,U</code>是定义在结构体<code>Point</code>上的泛型参数，<code>V,W</code>是单独定义在方法<code>mixup</code>上的泛型参数，它们并不冲突，说白了，你可以理解为，一个是结构体泛型，一个是函数泛型。</p>
<h3 id="为具体的泛型实现方法"><a href="#为具体的泛型实现方法" class="headerlink" title="为具体的泛型实现方法"></a>为具体的泛型实现方法</h3><p>对于<code>Point&lt;T&gt;</code>类型，你不仅能定义基于<code>T</code>的方法，还能针对特定的具体类型，进行方法定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码意味着<code>Point&lt;f32&gt;</code>类型会有一个方法<code>distance_from_origin</code>，而其他<code>T</code>不是<code>f32</code>类型的<code>Point&lt;T&gt;</code>实例则没有定义此方法。这个方法计算点实例与坐标<code>(0.0, 0.0)</code>之间的距离，并使用了只能用于浮点型的数学运算符。</p>
<p>这样我们就能针对特定的泛型类型实现某个特定的方法，对于其它泛型类型则没有定义该方法。</p>
<h2 id="const泛型"><a href="#const泛型" class="headerlink" title="const泛型"></a>const泛型</h2><p>在之前的泛型中，可以抽象为一句话：针对<strong>类型</strong>实现的泛型，所有的泛型都是为了抽象不同的类型，那有没有针对<strong>值</strong>的泛型？可能很多同学感觉很难理解，值怎么使用泛型？不急，我们先从数组讲起。</p>
<p>在数组中：<code>[i32; 2]</code>和<code>[i32; 3]</code>是不同的数组类型，比如下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>(arr: [<span class="type">i32</span>; <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后不通过，因为最后一个<code>arr</code>是<code>[i32; 2]</code>类型，而函数显然期望一个<code>[i32; 3]</code>类型的数组。</p>
<p>为了解决这一问题，我们可以采用数组的切片来解决这一问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>(arr: &amp;[<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，更近一步，我们可以使用泛型参数<code>T</code>来替换<code>i32</code>，实现所有类型的数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>&gt;(arr: &amp;[T]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但需要注意的是吗，在上面的代码示例中有序我们需要使用Debug打印<code>arr</code>，因而我们期望传入的参数拥有<code>Debug</code>的特性。</p>
<p>通过上面的数组切片(引用)，显然我们解决了处理任何类型数组的问题。但是在某些不能使用引用的场景下我们应该怎么办呢？Rust给了我们答案：<code>const</code>泛型，也就是针对值的泛型，正好可以用于处理数组长度的问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt;(arr: [T; N]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我们定义了一个类型为<code>[T; N]</code>的数组，其中<code>T</code>是一个基于类型的泛型参数，这个和之前讲的泛型没有区别，而重点在于<code>N</code>这个泛型参数，它是一个基于值的泛型参数！因为它用来替代的是数组的长度。</p>
<p><code>N</code>就是<code>const</code>泛型，定义的语法是<code>const N: usize</code>，表示<code>const</code>泛型<code>N</code>，它基于的值类型是<code>usize</code>。</p>
<h2 id="泛型的性能"><a href="#泛型的性能" class="headerlink" title="泛型的性能"></a>泛型的性能</h2><p>在Rust中泛型是零成本的抽象，意味着你在使用泛型时，完全不用担心性能上的问题。这是因为Rust通过在编译时进行泛型代码的**单态化(monomorphization)**来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p>
<p>让我们来看下面的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">integer</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">float</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br></pre></td></tr></table></figure>
<p>当Rust编译这些代码的时候，它会进行单态化。编译器会读取传递给<code>Option&lt;T&gt;</code>的值并发现有两种<code>Option&lt;T&gt;</code>：一种对应<code>i32</code>另一种对应<code>f64</code>。为此，它会将泛型定义<code>Option&lt;T&gt;</code>展开为<code>Option_i32</code>和<code> Option_f64</code>，接着将泛型定义替换为这两个具体的定义。</p>
<p>编译器生成的单态化版本的代码看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_f64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Option_i32::<span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Option_f64::<span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用泛型来编写不重复的代码，而Rust将会为每一个实例编译其特定类型的代码。这意味着在使用泛型时没有运行时开销；当代码运行，它的执行效率就跟好像手写每个具体定义的重复代码一样。这个单态化过程正是Rust泛型在运行时极其高效的原因。</p>
<p>但是，Rust是在编译期为泛型对应的多个类型，生成各自的代码，因此损失了编译速度和增大了最终生成文件的大小。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/26/rust-smaet-pointer-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/26/rust-smaet-pointer-2/" class="post-title-link" itemprop="url">二十、Rust进阶-智能指针2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-26 21:07:10" itemprop="dateCreated datePublished" datetime="2024-10-26T21:07:10+08:00">2024-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:46:11" itemprop="dateModified" datetime="2024-11-14T07:46:11+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="智能指针2"><a href="#智能指针2" class="headerlink" title="智能指针2"></a>智能指针2</h1><p>在智能指针1中，我们讲到了<code>Box&lt;T&gt;</code>，它是一种在堆上分配内存的智能指针。还讲到了<code>Deref</code>和<code>Drop</code>特征，它们允许我们自定义智能指针的行为。</p>
<p>在本节中，我们将介绍几种其他常见的智能指针，包括<code>Rc&lt;T&gt;</code>、<code>Arc&lt;T&gt;</code>、<code>Mutex&lt;T&gt;</code>和<code>RwLock&lt;T&gt;</code>。</p>
<h2 id="Rc"><a href="#Rc" class="headerlink" title="Rc&lt;T&gt;"></a><code>Rc&lt;T&gt;</code></h2><p><code>Rc&lt;T&gt;</code>是<strong>引用计数指针</strong>，其中Rc是Reference count的缩写，允许用于在多个地方共享所有权。它允许多个所有者共享同一个对象，而不会增加引用计数。</p>
<h3 id="为什么需要Rc"><a href="#为什么需要Rc" class="headerlink" title="为什么需要Rc&lt;T&gt;"></a>为什么需要<code>Rc&lt;T&gt;</code></h3><p>Rust所有权机制要求一个值只能有一个所有者。在大多数情况下都没有问题，但是我们需要考虑以下情况：</p>
<ul>
<li><strong>一个值被多个变量使用</strong>：在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理</li>
<li><strong>一个值被多个线程使用</strong>：在多线程中，多个线程可能会持有同一个数据，但是你受限于 Rust 的安全机制，无法同时获取该数据的可变引用</li>
</ul>
<p>这时候，为了解决此类问题，Rust 在所有权机制之外又引入了额外的措施来简化相应的实现：通过引用计数的方式，允许一个数据资源在同一时刻拥有多个所有者。</p>
<p>这种实现机制就是<code>Rc</code>和<code>Arc</code>，前者适用于单线程，后者适用于多线程。由于二者大部分情况下都相同，因此本章将以<code>Rc</code>作为讲解主体，对于<code>Arc</code>的不同之处，另外进行单独讲解。</p>
<h3 id="Rc的使用"><a href="#Rc的使用" class="headerlink" title="Rc的使用"></a>Rc<T>的使用</h3><p>引用计数(reference counting)，顾名思义，通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放。</p>
<p>而<code>Rc</code>正是引用计数的英文缩写。当我们希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用<code>Rc</code>成为数据值的所有者.</p>
<p>让我们使用之前用<code>Box&lt;T&gt;</code>实现的链表的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上的代码中我们创建了两个共享第三个链表所有权的链表。它的数据结构如下图所示：<br><img src="images/20-1.png" alt="" width="500"></p>
<p>我们可以发现此时代码报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: use of moved value: `a`</span><br></pre></td></tr></table></figure>
<p>因为在为变量<code>b</code>进行赋值时，变量<code>a</code>的所有权被转移给了<code>b</code>，因此变量<code>a</code>不再拥有任何值，所以变量<code>c</code>尝试获取变量<code>a</code>的所有权时，会导致所有权错误。</p>
<p>那我们应该如何解决这个问题呢？可以先考虑一下我们之前学过的生命周期与引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, &amp;<span class="symbol">&#x27;a</span> List&lt;<span class="symbol">&#x27;a</span>&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::*;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, &amp;List::<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, &amp;Nil));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, &amp;a);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, &amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们为<code>List</code>的每个元素添加了生命周期，这样就可以让<code>List</code>的每个元素共享同一个生命周期，从而避免所有权问题。</p>
<p>当然，由于本节课程我们学习的是引用计数<code>Rc&lt;T&gt;</code>，因此我们当然再需要使用<code>Rc&lt;T&gt;</code>来解决这个问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> crate::List::*;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));  </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));     <span class="comment">// 使用Rc::clone(&amp;a)克隆a的引用计数, 引用计数+1</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));     <span class="comment">// 引用计数再+1</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用<code>Rc::clone(&amp;a)</code>来克隆<code>a</code>的引用计数，同时<code>a</code>的引用计数+1，最终打印出来的引用计数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count after creating a = 1</span><br><span class="line">count after creating b = 2</span><br><span class="line">count after creating c = 3</span><br></pre></td></tr></table></figure>

<p>上面的代码中出现了很多关于<code>Rc</code>的方法，接下来我们一一进行讲解。</p>
<p>首先，在使用<code>Rc&lt;T&gt;</code>之前，我们需要在文件头部添加<code>use std::rc::Rc;</code>来引入<code>Rc</code>模块。随后，我们使用<code>Rc::new(T)</code>来创建一个<code>Rc&lt;T&gt;</code>类型的值。具体在代码中我们首先定义了<code>Rc&lt;List&gt;</code>类型, 然后使用<code>Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))))</code>来创建一个<code>Rc&lt;List&gt;</code>类型的<strong>指针</strong>，并赋值给变量<code>a</code>。</p>
<p>智能指针<code>Rc&lt;T&gt;</code>在创建时，会将引用计数+1，此时获取引用计数的关联函数<code>Rc::strong_count</code>返回的值将是<code>1</code>。</p>
<p>接着，在赋值给变量<code>b</code>时，我们使用<code>Rc::clone(&amp;a)</code>克隆了一份智能指针<code>Rc&lt;List&gt;</code>，此时<code>a</code>的引用计数+1，此时获取引用计数的关联函数<code>Rc::strong_count</code>返回的值将是<code>2</code>。同理在赋值<code>c</code>的操作中也是如此。</p>
<p>需要注意的是，<code>Rc::clone(&amp;a)</code>只是克隆了智能指针<code>Rc&lt;List&gt;</code>，而没有克隆<code>a</code>指向的值<code>Cons(5, Rc::new(Cons(10, Rc::new(Nil))))</code>。简而言之这里的<code>Rc::clone(&amp;a)</code><strong>只是浅拷贝，而不是深拷贝</strong>，仅仅复制了智能指针并增加了引用计数，因此<code>a</code>、<code>b</code>、<code>c</code>都共享同一个值。</p>
<h3 id="观察引用计数的变化"><a href="#观察引用计数的变化" class="headerlink" title="观察引用计数的变化"></a>观察引用计数的变化</h3><p>让我们接着上面的代码示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));  </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));     </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)); </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count after creating a = 1</span><br><span class="line">count after creating b = 2</span><br><span class="line">count after creating c = 3</span><br><span class="line">count after c goes out of scope = 2</span><br></pre></td></tr></table></figure>
<p>通过上面的代码以及对应的输出，我们可以发现：</p>
<ul>
<li>由于变量<code>c</code>在语句块内部声明，当离开语句块时它会因为超出作用域而被释放，所以引用计数会减少<code>1</code>，事实上这个得益于<code>Rc&lt;T&gt;</code>实现了<code>Drop</code>特征</li>
<li>变量<code>a</code>、<code>b</code>、<code>c</code>三个智能指针引用计数都是同样的，并且共享底层的数据，因此打印计数时用哪个都行</li>
<li>无法看到的是：当<code>a</code>、<code>b</code>超出作用域后，引用计数会变成<code>0</code>，最终智能指针和它指向的底层字符串都会被清理释放</li>
</ul>
<h3 id="使用Rc的限制"><a href="#使用Rc的限制" class="headerlink" title="使用Rc&lt;T&gt;的限制"></a>使用<code>Rc&lt;T&gt;</code>的限制</h3><p>事实上，<code>Rc&lt;T&gt;</code>是指向底层数据的不可变的引用，因此你无法通过它来修改数据，这也符合Rust的借用规则：要么存在多个不可变借用，要么只能存在一个可变借用。</p>
<p>但是实际开发中我们往往需要对数据进行修改，这时单独使用<code>Rc&lt;T&gt;</code>无法满足我们的需求，需要配合其它数据类型来一起使用，例如内部可变性的<code>RefCell&lt;T&gt;</code>类型以及互斥锁<code>Mutex&lt;T&gt;</code>。事实上，在多线程编程中，<code>Arc</code>跟<code>Mutex</code>锁的组合使用非常常见，它们既可以让我们在不同的线程中共享数据，又允许在各个线程中对其进行修改。</p>
<h2 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell&lt;T&gt;"></a><code>RefCell&lt;T&gt;</code></h2><p><code>RefCell&lt;T&gt;</code>是Rust标准库中的一个智能指针类型，它提供了内部可变性，允许在不可变引用的情况下修改数据。这种特性是的我们可以在编译时保证安全的情况下动态的借用和修改数据。</p>
<h3 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h3><p><code>RefCell&lt;T&gt;</code>的主要特征如下：</p>
<ul>
<li><code>RefCell&lt;T&gt;</code>使用动态借用检查，允许在运行时检查借用规则，而不是在编译时检查。同时，<code>RefCell&lt;T&gt;</code>需要遵循Rust的借用规则，在任何时刻，<code>RefCell&lt;T&gt;</code>只允许存在一个可变引用或多个不可变引用，否则就会导致编译错误.</li>
<li><code>RefCell&lt;T&gt;</code>提供了内部可变性允许你在其拥有的<code>T</code>内部进行修改，即使<code>RefCell&lt;T&gt;</code>本身是不可变的，这是通过在运行时进行借用检查实现的。</li>
<li><code>borrow</code>和<code>borrow_mut</code>方法：<ul>
<li><code>borrow</code>方法用于获取<code>RefCell&lt;T&gt;</code>的不可变引用，返回<code>Ref&lt;T&gt;</code>类型的智能指针，同一时间可以有多个不可变引用</li>
<li><code>borrow_mut</code>方法用于获取<code>RefCell&lt;T&gt;</code>的可变引用，返回<code>RefMut&lt;T&gt;</code>类型的智能指针，同一时间只能有一个可变引用</li>
</ul>
</li>
</ul>
<h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><p>借用规则：<br>    - <code>RefCell&lt;T&gt;</code>在运行时检查借用规则，以防止数据竞争和未定义行为，编译器不进行这些检查。<br>运行时开销：<br>    - 由于<code>RefCell&lt;T&gt;</code>在运行时检查借用规则，因此会带来一定的性能开销。这在需要在编译时确定所有借用规则的场景中不可替代。<br>错误处理：<br>    - 在任何时刻，<code>RefCell&lt;T&gt;</code>只允许存在一个可变引用或多个不可变引用，否则<code>RefCell&lt;T&gt;</code>会在运行时引发<code>panic!</code>异常。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>RefCell&lt;T&gt;</code>通常用于以下场景：</p>
<ul>
<li>数据结构： 在需要可变性但又受限于Rsut的所有权系统是，<code>RefCell</code>允许在数据结构中使用内部可变性。例如，实现需要共享但又需要修改的数据结构（如图、树等）</li>
<li>单线程环境： <code>RefCell</code>在单线程环境中非常有效，因为它不涉及线程安全问题，可以提供高效的内部可变性。但如果我们需要在多线程环境中使用处理内部可变性，则需要使用<code>Mutex</code>或<code>RwLock</code>来替代。</li>
</ul>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 获取不可变引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref1</span> = value.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ref1: &#123;&#125;&quot;</span>, ref1); <span class="comment">// 输出: ref1: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取可变引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ref2</span> = value.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">    *ref2 += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ref2: &#123;&#125;&quot;</span>, ref2); <span class="comment">// 输出: ref2: 6</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再次获取不可变引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref3</span> = value.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ref3: &#123;&#125;&quot;</span>, ref3); <span class="comment">// 输出: ref3: 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们首先创建了一个<code>RefCell&lt;i32&gt;</code>类型的智能指针，并赋值给变量<code>value</code>。接着，我们使用<code>value.borrow()</code>方法获取了<code>value</code>的不可变引用，并赋值给变量<code>ref1</code>。然后，我们使用<code>value.borrow_mut()</code>方法获取了<code>value</code>的可变引用，并赋值给变量<code>ref2</code>。最后，我们再次使用<code>value.borrow()</code>方法获取了<code>value</code>的不可变引用，并赋值给变量<code>ref3</code>。<br>可以发现，代码成功运行，并且没有报错。</p>
<p>但我们再尝试运行以下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skip</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ref3</span> = value.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;ref3: &#123;&#125;&quot;</span>, ref3);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ref4</span> = value.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">*ref4 += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;ref4: &#123;&#125;&quot;</span>, ref4);</span><br></pre></td></tr></table></figure>
<p>此时代码会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `value` as mutable because it is also borrowed as immutable</span><br></pre></td></tr></table></figure>
<p>因为我们再一个作用域内同时获取了<code>value</code>的不可变引用和可变引用，因此报错。</p>
<h2 id="引用循环与内存泄漏"><a href="#引用循环与内存泄漏" class="headerlink" title="引用循环与内存泄漏"></a>引用循环与内存泄漏</h2><p>在Rust中，引用计数<code>Rc&lt;T&gt;</code>和原子引用计数<code>Arc&lt;T&gt;</code>可以让多个所有者共享同一个数据。然而，这种共享机制如果使用不当，就会导致引用循环。引用循环（reference cycle）会导致内存泄漏，因为<code>Rc&lt;T&gt;</code>无法检测到循环引用，因此无法释放内存，造成内存泄漏。</p>
<p>让我们来看一个引用循环的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    next : <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">node1</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">1</span>, next: <span class="literal">None</span> &#125;));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">node2</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">2</span>, next: <span class="literal">None</span> &#125;));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建引用循环</span></span><br><span class="line">    node1.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;node2));</span><br><span class="line">    node2.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;node1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印引用计数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;strong_count: &#123;:?&#125;, weak_count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;node1), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;node1));     <span class="comment">// 输出: strong_count: 2, weak_count: 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;strong_count: &#123;:?&#125;, weak_count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;node2), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;node2));     <span class="comment">// 输出: strong_count: 2, weak_count: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印节点值</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;node1: &#123;:?&#125;&quot;</span>, node1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;node2: &#123;:?&#125;&quot;</span>, node2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码示例中，我们创建了两个<code>Node</code>结构体，并使用<code>Rc&lt;RefCell&lt;Node&gt;&gt;</code>类型来共享它们。接着，我们创建了一个引用循环，使得<code>node1</code>和<code>node2</code>互相引用对方，从而导致了引用计数无法归零，最终内存泄漏。实际上，编译器并不知道<code>node1</code>和<code>node2</code>互相引用对方，因此无法在编译时报错，直到我们运行代码时，才会因为内存泄漏而报错。</p>
<p>那我们应该如何解决这个问题呢？</p>
<h2 id="Weak"><a href="#Weak" class="headerlink" title="Weak&lt;T&gt;"></a><code>Weak&lt;T&gt;</code></h2><p><code>Weak&lt;T&gt;</code>是Rust标准库中的另一个智能指针类型，它提供了弱引用，允许在引用循环中打破循环引用。它的特点如下：</p>
<ul>
<li>非所有权引用：<code>Weak&lt;T&gt;</code>并不拥有数据的所有权，它不会增加<code>Rc&lt;T&gt;</code>的引用计数</li>
<li>不会引发内存泄漏：<code>Weak&lt;T&gt;</code>不会增加<code>Rc&lt;T&gt;</code>的引用计数，因此不会引发内存泄漏</li>
<li>必须升级：<code>Weak&lt;T&gt;</code>无法直接访问它所引用的数据，必须先通过<code>Rc::upgrade</code>方法将其升级为<code>Rc&lt;T&gt;</code>。如果所引用的<code>Rc&lt;T&gt;</code>已经被释放，则<code>Rc::upgrade</code>会返回<code>None</code>。</li>
</ul>
<p>那么，有了弱引用之后，我们就可以解决引用循环的问题了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::rc::Weak;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    next: <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">    prev: <span class="type">Option</span>&lt;Weak&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">node1</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">1</span>, next: <span class="literal">None</span>, prev: <span class="literal">None</span> &#125;));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">node2</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">2</span>, next: <span class="literal">None</span>, prev: <span class="literal">None</span> &#125;));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建引用循环</span></span><br><span class="line">    node1.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;node2));</span><br><span class="line">    node2.<span class="title function_ invoke__">borrow_mut</span>().prev = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">downgrade</span>(&amp;node1));  <span class="comment">// 使用Rc::downgrade(&amp;node1)创建一个弱引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印引用计数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;strong_count: &#123;:?&#125;, weak_count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;node1), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;node1));     <span class="comment">// 输出: strong_count: 1, weak_count: 1</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;strong_count: &#123;:?&#125;, weak_count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;node2), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;node2));     <span class="comment">// 输出: strong_count: 2, weak_count: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印节点值</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;node1: &#123;:?&#125;&quot;</span>, node1);     </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;node2: &#123;:?&#125;&quot;</span>, node2);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="强引用与弱引用的区别"><a href="#强引用与弱引用的区别" class="headerlink" title="强引用与弱引用的区别"></a>强引用与弱引用的区别</h3><ol>
<li>所有权：<ul>
<li>强引用：强引用是所有权引用，拥有对象的所有权，保证数据在作用域内不会被释放。</li>
<li>弱引用：弱引用是非所有权引用，不拥有对象的所有权，不影响数据的生命周期。</li>
</ul>
</li>
<li>引用计数：<ul>
<li>强引用：强引用会增加引用计数，数据被多个所有权共享。</li>
<li>弱引用：弱引用不会增加引用计数，不干扰<code>Rc&lt;T&gt;</code>的生命周期管理。</li>
</ul>
</li>
<li>内存管理：<ul>
<li>强引用：只用当所有强引用都被丢弃，引用计数为0时，对象会被释放。</li>
<li>弱引用：只能通过升级（<code>Rc::upgrade</code>）来访问数据<code>Rc&lt;T&gt;</code>，如果所引用的数据<code>Rc&lt;T&gt;</code>已经被释放，则<code>Rc::upgrade</code>会返回<code>None</code>。</li>
</ul>
</li>
<li>使用场景：<ul>
<li>强引用：通常用于需要共享数据所有权的场景，例如在多个部分之间共享数据，并确保数据在至少一个强引用存在时不会被释放。</li>
<li>弱引用：通常用于避免引用循环或只需要偶尔访问数据（不想持有所有权）的场景，例如在树结构中，父节点和子节点互相引用，形成循环引用，导致内存泄漏。</li>
</ul>
</li>
</ol>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务：</span></span><br><span class="line"><span class="comment">// 实现一个简单的社交网络系统，包含用户和朋友关系，使用Rc&lt;T&gt;,RefCell&lt;T&gt;,Weak&lt;T&gt;来处理用户和朋友之间的关系，并避免循环引用导致的内存泄漏。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求：</span></span><br><span class="line"><span class="comment">// 用户结构：每个用户拥有一个名字和一个朋友列表。</span></span><br><span class="line"><span class="comment">// 添加朋友：支持在两个用户之间建立朋友关系。</span></span><br><span class="line"><span class="comment">// 展示朋友关系：能够展示每个用户的朋友列表。</span></span><br><span class="line"><span class="comment">// 循环引用：处理用户之间的双向引用，确保不产生循环引用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    friends: RefCell&lt;<span class="type">Vec</span>&lt;Weak&lt;User&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        User &#123;</span><br><span class="line">            name,</span><br><span class="line">            friends: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加朋友关系</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_friend</span>(user1: &amp;Rc&lt;User&gt;, user2: &amp;Rc&lt;User&gt;) &#123;</span><br><span class="line">        user1.friends.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(Rc::<span class="title function_ invoke__">downgrade</span>(user2));</span><br><span class="line">        user2.friends.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(Rc::<span class="title function_ invoke__">downgrade</span>(user1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示朋友列表</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">show_friends</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;的朋友列表:&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">friend</span> <span class="keyword">in</span> <span class="keyword">self</span>.friends.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(friend) = friend.<span class="title function_ invoke__">upgrade</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;- &#123;&#125;&quot;</span>, friend.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建用户</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">alice</span> = Rc::<span class="title function_ invoke__">new</span>(User::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bob</span> = Rc::<span class="title function_ invoke__">new</span>(User::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Bob&quot;</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">charlie</span> = Rc::<span class="title function_ invoke__">new</span>(User::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Charlie&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立朋友关系</span></span><br><span class="line">    User::<span class="title function_ invoke__">add_friend</span>(&amp;alice, &amp;bob);</span><br><span class="line">    User::<span class="title function_ invoke__">add_friend</span>(&amp;bob, &amp;charlie);</span><br><span class="line">    User::<span class="title function_ invoke__">add_friend</span>(&amp;alice, &amp;charlie);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示所有用户的朋友列表</span></span><br><span class="line">    alice.<span class="title function_ invoke__">show_friends</span>();</span><br><span class="line">    bob.<span class="title function_ invoke__">show_friends</span>();</span><br><span class="line">    charlie.<span class="title function_ invoke__">show_friends</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/24/rust-smart-pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/24/rust-smart-pointer/" class="post-title-link" itemprop="url">十六、Rust进阶-智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-24 05:53:58" itemprop="dateCreated datePublished" datetime="2024-10-24T05:53:58+08:00">2024-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:45:31" itemprop="dateModified" datetime="2024-11-14T07:45:31+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="智能指针概述"><a href="#智能指针概述" class="headerlink" title="智能指针概述"></a>智能指针概述</h2><p>在各个编程语言中，指针的概念几乎都是相同的：指针是一个包含了内存地址的变量，该内存地址引用或者指向了另外的数据。而在Rust中，最常见的指针类型就是<strong>引用</strong>。</p>
<p>而智能指针（Smart Pointer）虽然也叫做指针，但是它实际上是一类<strong>数据结构</strong>，不仅包含一个指针，还附带一些额外的元数据和功能，与普通指针不同，智能指针在Rust中往往基于结构体实现，并且实现了<code>Deref</code>和<code>Drop</code>两个特征：<br>    <code>Deref</code>可以让智能指针像引用那样工作，这样可以写出同时支持智能指针和引用的代码。<br>    <code>Drop</code>允许智能指针在离开作用域时自动清理资源。</p>
<h2 id="为什么存在智能指针？"><a href="#为什么存在智能指针？" class="headerlink" title="为什么存在智能指针？"></a>为什么存在智能指针？</h2><p><strong>·资源管理</strong><br>    自动管理资源的分配和释放，避免内存泄漏<br><strong>·所有权与借用</strong><br>    Rust的所有权系统通过智能指针来确保内存安全，避免数据竞争和悬垂指针<br><strong>·复杂数据结构</strong><br>    通过智能指针可以构建复杂的数据结构，例如递归结构、共享数据等</p>
<h1 id="Box-堆对象分配"><a href="#Box-堆对象分配" class="headerlink" title="Box 堆对象分配"></a>Box<T> 堆对象分配</h1><p><code>Box&lt;T&gt;</code>是Rust中最常见的智能指针，它允许你将类型<code>T</code>的值分配在堆上，然后在栈上保留一个智能指针指向堆上的数据。当Box被销毁时，堆上的数据也会被销毁。</p>
<h2 id="Box的底层实现"><a href="#Box的底层实现" class="headerlink" title="Box的底层实现"></a>Box的底层实现</h2><p>·Box的底层原理<br>    <code>Box&lt;T&gt;</code>是一个智能指针，内部包含一个指向堆上分配内存的裸指针。当<code>Box&lt;T&gt;</code>被销毁时，其Drop trait会被调用，释放堆上的内存。<br>·内存分配<br>    Rust使用系统的全局分配器(<code>malloc</code>和<code>free</code>)来管理内存。<br>    <code>Box::new</code>分配内存，<code>Drop</code>释放内存<br>·安全性<br>    Rust的所有权系统确保<code>Box&lt;T&gt;</code>的内存安全。当所有权发生转移时，堆内存的生命周期也会随之变化</p>
<h2 id="Box的使用场景"><a href="#Box的使用场景" class="headerlink" title="Box的使用场景"></a>Box的使用场景</h2><p>由于Box是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。而性能和功能往往是鱼和熊掌，因此Box相比其它智能指针，功能较为单一，可以在以下场景中使用它：</p>
<p>·特意的将数据分配在堆上<br>·数据较大时，又不想在转移所有权时进行数据拷贝<br>·类型的大小在编译期无法确定，但是我们又需要固定大小的类型时<br>·特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</p>
<h3 id="使用Box将数据存储在堆上"><a href="#使用Box将数据存储在堆上" class="headerlink" title="使用Box&lt;T&gt;将数据存储在堆上"></a>使用<code>Box&lt;T&gt;</code>将数据存储在堆上</h3><p>Box最常见的用途是将数据分配在堆上而非栈上，这在处理较大的数据结构或数据结构的大小在编译时不确定的情况下尤为重要：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a); <span class="comment">// a = 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面一行代码将报错</span></span><br><span class="line">    <span class="comment">// let b = a + 1; // cannot add `&#123;integer&#125;` to `Box&lt;&#123;integer&#125;&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理动态大小类型（DST）"><a href="#处理动态大小类型（DST）" class="headerlink" title="处理动态大小类型（DST）"></a>处理动态大小类型（DST）</h3><p>Rust需要在编译时知道类型占用多少空间，如果一种类型在编译时无法知道具体的大小，那么被称为动态大小类型DST。Box允许我们处理动态大小的类型，如<code>str</code>和<code>[T]</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;Hello,world!&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;s&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: <span class="type">Box</span>&lt;[<span class="type">i32</span>]&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].<span class="title function_ invoke__">into_boxed_slice</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;arr = &#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归数据结构"><a href="#递归数据结构" class="headerlink" title="递归数据结构"></a>递归数据结构</h3><p>其中另一种无法在编译时知道大小的类型是<strong>递归类型</strong>：它在类型定义中又使用到了自身，或者说该类型的值的一部分可以是相同类型的其它值，这种值的嵌套理论上可以无限进行下去，所以 Rust 不知道递归类型需要多少空间：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中就是函数式语言中常见的<code>Cons List</code>，它的每个节点包含一个<code>i32</code>值，还包含了一个新的<code>List</code>，因此这种嵌套可以无限进行下去，Rust认为该类型是一个DST类型，并给予报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0072]: recursive type `List` has infinite size //递归类型 `List` 拥有无限长的大小</span><br><span class="line"> --&gt; src/main.rs:3:1</span><br><span class="line">  |</span><br><span class="line">3 | enum List &#123;</span><br><span class="line">  | ^^^^^^^^^ recursive type has infinite size</span><br><span class="line">4 |     Cons(i32, List),</span><br><span class="line">  |               ---- recursive without indirection</span><br></pre></td></tr></table></figure>

<p>如果想要解决这个问题，我们可以使用智能指针类型来引用自身：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们将<code>List</code>存储到了堆上，并且使用一个智能指针指向它，完成了从DST到Sized类型（固定大小类型）的转变。</p>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>在 Rust 中，想实现不同类型组成的数组只有两个办法：枚举和特征对象，前者限制较多，因此后者往往是最常用的解决办法，而<code>Box&lt;dyn Trait&gt;</code>可以用于类型擦除，允许在运行时决定类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">speak</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cat</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">speak</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Woo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">speak</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Meow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">animals</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Animal&gt;&gt; = <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Dog), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Cat)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">animal</span> <span class="keyword">in</span> animals.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        animal.<span class="title function_ invoke__">speak</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用了<code>Box&lt;dyn Animal&gt;</code>的智能指针类型，来把<code>Dog</code>和<code>Cat</code>都塞进了<code>animals</code>的向量中。</p>
<h4 id="dyn解释"><a href="#dyn解释" class="headerlink" title="dyn解释"></a><code>dyn</code>解释</h4><p><code>dyn</code>关键字用于指定动态分发的类型，它允许在运行时决定具体类型。在Rust中，<code>dyn</code>关键字用于实现动态分发的<code>trait</code>对象。</p>
<h3 id="内存管理和性能优化"><a href="#内存管理和性能优化" class="headerlink" title="内存管理和性能优化"></a>内存管理和性能优化</h3><p>通过使用Box，可以控制内存的分配和释放，从而优化性能和内存使用。例如，将大型数据结构放在堆上，而不是栈上，可以减少栈的使用量，从而避免<strong>栈溢出</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">large_array</span>: <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">0u8</span>; <span class="number">1_000_000</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Large array allocated on the heap.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Box的优缺点"><a href="#Box的优缺点" class="headerlink" title="Box的优缺点"></a>Box的优缺点</h2><p><strong>·优点</strong><br>    提供堆内存分配，支持复杂数据结构<br>    与Rust的所有权系统完美集成，确保内存安全<br>    动态分配对象，实现类型擦除</p>
<p><strong>·缺点</strong><br>    需要堆内存分配和释放，可能带来性能开销<br>    不适合需要频繁分配和释放的场景</p>
<h2 id="Drop和Deref"><a href="#Drop和Deref" class="headerlink" title="Drop和Deref"></a>Drop和Deref</h2><h3 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h3><p><code>Drop</code>trait用于自定义当值离开作用域时执行的代码，通常用于释放资源（例如内存、文件句柄、网络连接等）。<br><code>Drop</code>trait定义了一个drop方法，当值被释放时，Rust会自动调用这个方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Drop</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Deref"><a href="#Deref" class="headerlink" title="Deref"></a>Deref</h3><p><code>Deref</code> trait用于重载解引用运算符（*），它允许你自定义指针类型的解引用行为。<br><code>Deref</code> trait定义了一个deref方法，该方法返回指向目标类型的引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Deref</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span>: ?Size;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面再举一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">use::ste::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mybox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Mybox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> Mybox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">Mybox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Mybox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        <span class="title function_ invoke__">println</span>(<span class="string">&quot;deref called!&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = Mybox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deref called!</span><br><span class="line">y = 5</span><br></pre></td></tr></table></figure>

<h3 id="DerefMut"><a href="#DerefMut" class="headerlink" title="DerefMut"></a>DerefMut</h3><p>与<code>Deref</code>相似，<code>DerefMut</code>用于重载可变解引用运算符（*），允许对自定义类型进行可变解引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">DerefMut</span>: Deref &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><img src="/images/16-1.png" alt="" width="1000">

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stack_alloc_start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>; <span class="number">1_000_000</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stack_alloc_duration</span> = stack_alloc_start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heap_alloc_start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr_box</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">1</span>; <span class="number">1_000_000</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heap_alloc_duration</span> = heap_alloc_start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stack_access_start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;arr &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stack_access_duration</span> = stack_access_start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heap_access_start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// arr_box.iter() 返回一个迭代器,不能使用for i in &amp;arr_box</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;*arr_box &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heap_access_duration</span> = heap_access_start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Stack allocation duration: &#123;:?&#125;&quot;</span>, stack_alloc_duration);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Heap allocation duration: &#123;:?&#125;&quot;</span>, heap_alloc_duration);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Stack access duration: &#123;:?&#125;&quot;</span>, stack_access_duration);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Heap access duration: &#123;:?&#125;&quot;</span>, heap_access_duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">File</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Folder</span>(FolderNode),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_file</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: &amp;<span class="type">str</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_folder</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: &amp;<span class="type">str</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">list_contents</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FolderNode</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    contents: HashMap&lt;<span class="type">String</span>, <span class="type">Box</span>&lt;Node&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FileSystem</span> <span class="keyword">for</span> <span class="title class_">FolderNode</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_file</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.contents.<span class="title function_ invoke__">insert</span>(path.<span class="title function_ invoke__">to_string</span>(), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">File</span>(path.<span class="title function_ invoke__">to_string</span>())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_folder</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.contents.<span class="title function_ invoke__">insert</span>(</span><br><span class="line">            path.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                Node::<span class="title function_ invoke__">Folder</span>( FolderNode</span><br><span class="line">                    &#123;</span><br><span class="line">                    name: path.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                    contents: HashMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">list_contents</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents_list</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (name, node) <span class="keyword">in</span> &amp;<span class="keyword">self</span>.contents &#123;</span><br><span class="line">            <span class="keyword">match</span> node.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">                Node::<span class="title function_ invoke__">File</span>(file) =&gt; contents_list.<span class="title function_ invoke__">push</span>(file.<span class="title function_ invoke__">clone</span>()),</span><br><span class="line">                Node::<span class="title function_ invoke__">Folder</span>(folder) =&gt; &#123;</span><br><span class="line">                    contents_list.<span class="title function_ invoke__">push</span>(folder.name.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">sub_contents</span> = folder.<span class="title function_ invoke__">list_contents</span>();</span><br><span class="line">                    <span class="comment">// 将子文件夹内容路径化</span></span><br><span class="line">                    <span class="keyword">for</span> <span class="variable">sub_item</span> <span class="keyword">in</span> sub_contents &#123;</span><br><span class="line">                        contents_list.<span class="title function_ invoke__">push</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;/&#123;&#125;&quot;</span>, name, sub_item));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        contents_list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display_list_as_tree</span>(contents_list: &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> contents_list &#123;</span><br><span class="line">        <span class="comment">// 计算当前路径中的层级，通过&#x27;/&#x27;分割来确定缩进层次</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">level</span> = item.<span class="title function_ invoke__">matches</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_ invoke__">count</span>();</span><br><span class="line">        <span class="comment">// 添加适当数量的空格来表示缩进</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">indent</span> = <span class="string">&quot;  &quot;</span>.<span class="title function_ invoke__">repeat</span>(level);</span><br><span class="line">        result.<span class="title function_ invoke__">push_str</span>(&amp;<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;\n&quot;</span>, indent, item.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">root</span> = FolderNode &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;root&quot;</span>),</span><br><span class="line">        contents: HashMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    root.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;file1.txt&quot;</span>);</span><br><span class="line">    root.<span class="title function_ invoke__">create_folder</span>(<span class="string">&quot;folder1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(folder) = root.contents.<span class="title function_ invoke__">get_mut</span>(<span class="string">&quot;folder1&quot;</span>) &#123;    <span class="comment">//get_mut()是HashMap的方法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Node</span>::<span class="title function_ invoke__">Folder</span>(folder1) = folder.<span class="title function_ invoke__">as_mut</span>() &#123;    <span class="comment">//使用as_mut()获取Box&lt;T&gt;中的T</span></span><br><span class="line">            folder1.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;file2.txt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Contents: &#123;:?&#125;&quot;</span>, root.<span class="title function_ invoke__">list_contents</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">display_list_as_tree</span>(&amp;root.<span class="title function_ invoke__">list_contents</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/23/rust-module-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/23/rust-module-system/" class="post-title-link" itemprop="url">十五、Rust基础-模块化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-23 04:21:27 / Modified: 08:11:46" itemprop="dateCreated datePublished" datetime="2024-10-23T04:21:27+08:00">2024-10-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>我们首先从以下四个名词出发来了解Rust中的模块：</p>
<h1 id="项目Package"><a href="#项目Package" class="headerlink" title="项目Package"></a>项目Package</h1><p>在Rust中，由于Rust团队标新立异的起名传统，以及包的名称被<code>crate</code>占用，库的名称被<code>library</code>占用，经过斟酌， 我们决定将<code>Package</code>翻译成项目，你也可以理解为工程、软件包。<br>由于<code>Package</code>就是一个项目，因此它包含有独立的<code>Cargo.toml</code>文件，以及因为功能性被组织在一起的一个或多个包。一个<code>Package</code>只能包含一个库(library)类型的包，但是可以包含多个二进制可执行类型(binary crates)的包。</p>
<h1 id="包Crate"><a href="#包Crate" class="headerlink" title="包Crate"></a>包Crate</h1><p>对于Rust而言，包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库。</p>
<p>一个包会将相关联的功能打包在一起，使得该功能可以很方便的在多个项目中分享。例如标准库中没有提供但是在三方库中提供的<code>rand</code>包，它提供了随机数生成的功能，我们只需要将该包通过<code>use rand</code>; 引入到当前项目的作用域中，就可以在项目中使用<code>rand</code>的功能：<code>rand::XXX</code>。</p>
<p>同一个包中不能有同名的类型，但是在不同包中就可以。例如，虽然<code>rand</code>包中，有一个<code>Rng</code>特征，可是我们依然可以在自己的项目中定义一个<code>Rng</code>，前者通过<code>rand::Rng</code>访问，后者通过<code>Rng</code>访问，对于编译器而言，这两者的边界非常清晰，不会存在引用歧义。</p>
<h2 id="二进制Package"><a href="#二进制Package" class="headerlink" title="二进制Package"></a>二进制Package</h2><p>我们可以通过如下命令来创建一个二进制<code>Package</code>：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-project</span><br><span class="line">     Created binary (application) `my-project` package</span><br><span class="line">$ <span class="built_in">ls</span> my-project</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ <span class="built_in">ls</span> my-project/src</span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>
<p>这里，<code>Cargo</code>为我们创建了一个名称是<code>my-project</code>的<code>Package</code>，同时在其中创建了<code>Cargo.toml</code>文件，可以看一下该文件，里面并没有提到<code>src/main.rs</code>作为程序的入口，原因是<code>Cargo</code>有一个惯例：<code>src/main.rs</code>是二进制包的根文件，该二进制包的包名跟所属<code>Package</code>相同，在这里都是<code>my-project</code>，所有的代码执行都从该文件中的<code>fn main()</code>函数开始。</p>
<p>使用<code>cargo run</code>可以运行该项目，输出：<code>Hello, world!</code>。</p>
<h2 id="库Package"><a href="#库Package" class="headerlink" title="库Package"></a>库Package</h2><p>再来创建一个库类型的<code>Package</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-lib --lib</span><br><span class="line">     Created library `my-lib` package</span><br><span class="line">$ ls my-lib</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ ls my-lib/src</span><br><span class="line">lib.rs</span><br></pre></td></tr></table></figure>
<p>首先，如果你试图运行<code>my-lib</code>，会报错：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">error: a bin target must be available <span class="keyword">for</span> `cargo run`</span><br></pre></td></tr></table></figure>
<p>原因是库类型的<code>Package</code>只能作为三方库被其它项目引用，而不能使用<code>Cargo run</code>等命令独立运行，只有之前的二进制<code>Package</code>才可以运行。</p>
<p>与<code>src/main.rs</code>一样，<code>Cargo</code>知道，如果一个<code>Package</code>包含有<code>src/lib.rs</code>，意味它包含有一个库类型的同名包<code>my-lib</code>，该包的根文件是<code>src/lib.rs</code>。</p>
<h2 id="易混淆的Package和包"><a href="#易混淆的Package和包" class="headerlink" title="易混淆的Package和包"></a>易混淆的Package和包</h2><p>看完上面，相信大家看出来为何<code>Package</code>和包容易被混淆了吧？因为你用<code>cargo new</code>创建的<code>Package</code>和它其中包含的包是同名的！</p>
<p>不过，只要你牢记<code>Package</code>是一个项目工程，而包只是一个编译单元，也就不会再混淆这两个概念<code>src/main.rs</code>和<code>src/lib.rs</code>都是编译单元，因此它们都是包。</p>
<h2 id="典型的Package结构"><a href="#典型的Package结构" class="headerlink" title="典型的Package结构"></a>典型的Package结构</h2><p>上面创建的<code>Package</code>中仅包含<code>src/main.rs</code>文件，意味着它仅包含一个二进制同名包<code>my-project</code>。如果一个<code>Package</code>同时拥有<code>src/main.rs</code>和<code>src/lib.rs</code>，那就意味着它包含两个包：库包和二进制包，这两个包名也都是<code>my-project</code>—— 都与<code>Package</code>同名。</p>
<p>一个真实项目中典型的<code>Package</code>，会包含多个二进制包，这些包文件被放在<code>src/bin</code>目录下，每一个文件都是独立的二进制包，同时也会包含一个库包，该包只能存在一个<code>src/lib.rs</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── src</span><br><span class="line">│   ├── main.rs</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   └── bin</span><br><span class="line">│       └── main1.rs</span><br><span class="line">│       └── main2.rs</span><br><span class="line">├── tests</span><br><span class="line">│   └── some_integration_tests.rs</span><br><span class="line">├── benches</span><br><span class="line">│   └── simple_bench.rs</span><br><span class="line">└── examples</span><br><span class="line">    └── simple_example.rs</span><br></pre></td></tr></table></figure>
<p>·唯一库包：<code>src/lib.rs</code><br>·默认二进制包：<code>src/main.rs</code>，编译后生成的可执行文件与<code>Package</code>同名<br>·其余二进制包：<code>src/bin/main1.rs</code>和<code>src/bin/main2.rs</code>，它们会分别生成一个文件同名的二进制可执行文件。<br>·集成测试文件：<code>tests</code>目录下<br>·基准性能测试<code>benchmark</code>文件：<code>benches</code>目录下<br>·项目示例：<code>examples</code>目录下</p>
<p>这种目录结构基本上是Rust的标准目录结构，在GitHub的大多数项目上，你都将看到它的身影。</p>
<h1 id="模块Module"><a href="#模块Module" class="headerlink" title="模块Module"></a>模块Module</h1><p>在这里，我们将讨论Rust的代码构成单元：模块。使用模块可以将包中的代码按照功能性进行重组，最终实现更好的可读性及易用性。同时，我们还能非常灵活地去控制代码的可见性，进一步强化Rust的安全性。</p>
<h2 id="创建嵌套模块"><a href="#创建嵌套模块" class="headerlink" title="创建嵌套模块"></a>创建嵌套模块</h2><p>在Rust中，我们可以通过<code>mod</code>关键字来创建新模块：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 餐厅前厅，用于吃饭</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码创建了三个模块，有几点需要注意的：</p>
<p>·使用<code>mod</code>关键字来创建新模块，后面紧跟着模块名称<br>·模块可以嵌套，这里嵌套的原因是招待客人和服务都发生在前厅，因此我们的代码模拟了真实场景<br>·模块中可以定义各种Rust类型，例如函数、结构体、枚举、特征等<br>·所有模块均定义在同一个文件中</p>
<p>类似上述代码中所做的，使用模块，我们就能将功能相关的代码组织到一起，然后通过一个模块名称来说明这些代码为何被组织在一起。这样其它程序员在使用你的模块时，就可以更快地理解和上手。</p>
<h2 id="模块树"><a href="#模块树" class="headerlink" title="模块树"></a>模块树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure>
<p>这颗树展示了模块之间彼此的嵌套关系，因此被称为模块树。其中<code>crate</code>包根是<code>src/lib.rs</code>文件，包根文件中的三个模块分别形成了模块树的剩余部分。</p>
<h3 id="父子模块"><a href="#父子模块" class="headerlink" title="父子模块"></a>父子模块</h3><p>如果模块<code>A</code>包含模块<code>B</code>，那么<code>A</code>是<code>B</code>的父模块，<code>B</code>是<code>A</code>的子模块。在上例中，<code>front_of_house</code>是<code>hosting </code>和<code>serving</code>的父模块，反之，后两者是前者的子模块。</p>
<h2 id="用路径引用模块"><a href="#用路径引用模块" class="headerlink" title="用路径引用模块"></a>用路径引用模块</h2><p>想要调用一个函数，我们就需要知道它的路径，在Rust中，这种路径有两种形式：<br>· <strong>绝对路径</strong>，从包根开始，路径名以包名或者<code>crate</code>开头<br>· <strong>相对路径</strong>，从当前模块开始，以<code>self</code>、<code>super</code>或当前模块的标识符作为开头</p>
<p>让我们继续上面的代码示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绝对路径引用"><a href="#绝对路径引用" class="headerlink" title="绝对路径引用"></a>绝对路径引用</h3><p>在上面的例子中，由于<code>eat_at_restaurant</code>和<code>add_to_waitlist()</code>都定义在一个包（crate）中，因此在使用绝对路径引用时，可以直接用<code>crate</code>开头，随后逐层引用，每一层之间以<code>::</code>分隔：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crate::front_of_house::hosting::add_to_waitlist();</span><br></pre></td></tr></table></figure>

<h3 id="相对路径引用"><a href="#相对路径引用" class="headerlink" title="相对路径引用"></a>相对路径引用</h3><p>由于<code>eat_at_restaurant</code>和<code>add_to_waitlist()</code>都定义在一个包（crate）中，因此相对路径引用可以使用<code>front_of_house</code>作为开头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">front_of_house::hosting::add_to_waitlist();</span><br></pre></td></tr></table></figure>
<h4 id="使用super引用模块"><a href="#使用super引用模块" class="headerlink" title="使用super引用模块"></a>使用super引用模块</h4><p><code>super</code>代表的是父模块为开始的引用方式，非常类似于文件系统中的<code>..</code>语法：<code>../a/b</code></p>
<p>让我们来看下面的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 厨房模块</span></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们使用<code>super::serve_order()</code>语法，调用了父模块中的<code>serve_order</code>函数</p>
<h4 id="使用self引用模块"><a href="#使用self引用模块" class="headerlink" title="使用self引用模块"></a>使用self引用模块</h4><p><code>self</code>其实就是引用自身模块中的项，也就是说和我们之前章节的代码类似，都调用同一模块中的内容，区别在于之前章节中直接通过名称调用即可，而<code>self</code>，你得多此一举：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;</span><br><span class="line">    self::back_of_house::<span class="title function_ invoke__">cook_order</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        crate::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，实际上我们完全可以使用<code>back_of_house::cook_order()</code>来直接跳用函数，但是<code>self</code>在接下来还有一个大用处。</p>
<h2 id="代码可见性"><a href="#代码可见性" class="headerlink" title="代码可见性"></a>代码可见性</h2><p>让我们运行下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行<code>cargo bulid</code>编译此库类型的 Package，意料之外的报错了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line"> --&gt; src/lib.rs:9:28</span><br><span class="line">  |</span><br><span class="line">9 |     crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line">  |                            ^^^^^^^ private module</span><br></pre></td></tr></table></figure>
<p>错误信息提示我们:<code>hosting</code>模块是私有的，无法在包根进行访问，那么为何<code>front_of_house</code>模块就可以访问？因为它和<code>eat_at_restaurant</code>同属于一个包根作用域内，同一个模块内的代码自然不存在私有化问题.</p>
<p>Rust出于安全的考虑，默认情况下，所有的类型都是私有化的，包括函数、方法、结构体、枚举、常量，是的，就连模块本身也是私有化的。在中国，父亲往往不希望孩子拥有小秘密，但是在Rust中，父模块完全无法访问子模块中的私有项，但是子模块却可以访问父模块、父父..模块的私有项。</p>
<h3 id="pub关键字"><a href="#pub关键字" class="headerlink" title="pub关键字"></a>pub关键字</h3><p>在Rust中提供了<code>pub</code>关键字，通过它你可以控制模块和模块中指定项的可见性。如果我们想要修复上面的报错，按道理只需要将<code>hosting</code>模块标记为对外可见即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--- snip ----*/</span></span><br></pre></td></tr></table></figure>
<p>但不幸的是，在执行上述代码时，又发生了报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error[E0603]: function `add_to_waitlist` is private</span><br><span class="line">  --&gt; src/lib.rs:12:30</span><br><span class="line">   |</span><br><span class="line">12 |     front_of_house::hosting::add_to_waitlist();</span><br><span class="line">   |                              ^^^^^^^^^^^^^^^ private function</span><br></pre></td></tr></table></figure>
<p>通过报错信息，我们可以发现，编译器提示我们还需要对函数<code>add_to_waitlist</code>标记为可见。<br>是的，没错，模块可见性不代表模块内部项的可见性，模块的可见性仅仅是允许其它模块去引用它，但是想要引用它内部的项，还得继续将对应的项标记为<code>pub</code>。</p>
<p>因此，既然知道了如何解决，那么我们为函数也标记上<code>pub</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--- snip ----*/</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果需要在模块内部调用函数，那么不需要为使用<code>pub</code>关键字将调用的函数标记为对外可见。</p>
<h2 id="使用use引入模块"><a href="#使用use引入模块" class="headerlink" title="使用use引入模块"></a>使用use引入模块</h2><p>在上面，我们使用绝对路径和相对路径引入了模块中的函数。但是如果我们需要调用的函数数量增加，或者某些函数在模块中嵌套及其深时，我们就需要换一种方式来引入函数或模块：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting::add_to_waitlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们使用<code>use</code>和相对路径的方式，直接引入了该模块中的<code>add_to_waitlist</code>函数。通过该方法，我们简化了函数的调用过程。</p>
<h3 id="思考引入函数还是引入模块"><a href="#思考引入函数还是引入模块" class="headerlink" title="思考引入函数还是引入模块"></a>思考引入函数还是引入模块</h3><p>从使用简洁性来说，引入函数自然是更甚一筹，但是在某些时候，引入模块会更好：<br>·需要引入同一个模块的多个函数<br>·作用域中存在同名函数</p>
<h2 id="避免同名引用"><a href="#避免同名引用" class="headerlink" title="避免同名引用"></a>避免同名引用</h2><p>有时候，我们会发现模块之间、包之间会存在同名。此时，遇到同名的情况我们应该如何处理呢？</p>
<h3 id="模块-函数"><a href="#模块-函数" class="headerlink" title="模块::函数"></a>模块::函数</h3><p>让我们来看下面的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子给出了很好的解决方案，使用模块引入的方式，具体的 Result 通过 模块::Result 的方式进行调用。</p>
<p>可以看出，避免同名冲突的关键，就是使用父模块的方式来调用，除此之外，还可以给予引入的项起一个别名。</p>
<h3 id="as别名引用"><a href="#as别名引用" class="headerlink" title="as别名引用"></a>as别名引用</h3><p>对于同名冲突问题，还可以使用<code>as</code>关键字来解决，它可以赋予引入项一个全新的名称：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，首先通过<code>use std::io::Result</code>将<code>Result</code>引入到作用域，然后使用<code>as</code>给予它一个全新的名称<code>IoResult</code>，这样就不会再产生冲突：<br>·<code>Result</code>代表<code>std::fmt::Result</code><br>·<code>IoResult</code>代表<code>std:io::Result</code></p>
<h3 id="使用-简化引入方式"><a href="#使用-简化引入方式" class="headerlink" title="使用{}简化引入方式"></a>使用{}简化引入方式</h3><p>对于一下一行一行的引入方式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br></pre></td></tr></table></figure>
<p>可以使用<code>&#123;&#125;</code>来一起引入进来，在大型项目中，使用这种方式来引入，可以减少大量<code>use</code>的使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::&#123;HashMap,BTreeMap,HashSet&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br></pre></td></tr></table></figure>

<p>对于下面的同时引入模块和模块中的项：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用<code>&#123;&#125;</code>的方式来进行简化：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="受限的可见性"><a href="#受限的可见性" class="headerlink" title="受限的可见性"></a>受限的可见性</h2><p>· <strong>private(default)</strong><br>· <strong>pub(crate)</strong>  在当前的crate中可见 还有pub(self)、pub(super)<br>· <strong>pub(in path)</strong>  例如pub(in crate::a),只在模块a中可见</p>
<h2 id="引入项再导出"><a href="#引入项再导出" class="headerlink" title="引入项再导出"></a>引入项再导出</h2><p>当外部的模块项<code>A</code>被引入到当前模块中时，它的可见性自动被设置为私有的，如果你希望允许其它外部代码引用我们的模块项<code>A</code>，那么可以对它使用<code>pub use</code>进行再导出：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，使用<code>pub use</code>即可实现。这里<code>use</code>代表引入<code>hosting</code>模块到当前作用域，<code>pub</code>表示将该引入的内容再度设置为可见。</p>
<p>当你希望将内部的实现细节隐藏起来或者按照某个目的组织代码时，可以使用<code>pub use</code>再导出，例如统一使用一个模块来提供对外的API，那该模块就可以引入其它模块中的API，然后进行再导出，最终对于用户来说，所有的API都是由一个模块统一提供的。</p>
<h2 id="使用第三方包"><a href="#使用第三方包" class="headerlink" title="使用第三方包"></a>使用第三方包</h2><p>之前我们一直在引入标准库模块或者自定义模块。但是当我们的项目越来越大时，一个lib crate无法支撑，此时我们需要引入下第三方包中的模块：</p>
<ol>
<li>修改<code>Cargo.toml</code>文件，在<code>[dependencies]</code>区域添加一行：<code>rand = &quot;0.8.3&quot;</code></li>
<li>此时，如果你用的是VSCode和rust-analyzer插件，该插件会自动拉取该库，你可能需要等它完成后，再进行下一步（VSCode 左下角有提示）</li>
<li>此时，<code>rand</code>包已经被我们添加到依赖中，我们可以在代码中使用</li>
</ol>
<p>同时，<code>Cargo</code>还支持我们在<code>Cargo.toml</code>中自己在<code>workspace</code>中手动添加一些自己创建的依赖。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/22/rust-return-value-and-error-handling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/22/rust-return-value-and-error-handling/" class="post-title-link" itemprop="url">十四、Rust基础-返回值与错误处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-22 18:52:10" itemprop="dateCreated datePublished" datetime="2024-10-22T18:52:10+08:00">2024-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-24 03:10:58" itemprop="dateModified" datetime="2024-10-24T03:10:58+08:00">2024-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="匹配Option"><a href="#匹配Option" class="headerlink" title="匹配Option"></a>匹配<code>Option</code></h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="title function_ invoke__">Some</span>(x+<span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h1><h2 id="Option的辅助函数"><a href="#Option的辅助函数" class="headerlink" title="Option&lt;T&gt;的辅助函数"></a><code>Option&lt;T&gt;</code>的辅助函数</h2><p>关于<code>Option</code>的所有辅助函数，我们可以在Rust<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/index.html">官方文档</a>中进行查阅。下面列举几个常用的函数。</p>
<h3 id="使用unwarp"><a href="#使用unwarp" class="headerlink" title="使用unwarp()"></a>使用<code>unwarp()</code></h3><p>如果我们确定<code>Option</code>中一定存在值，可以使用<code>unwrap</code>方法直接获取值。反之，如果<code>Option</code>类型的值是<code>None</code>，就会直接触发<code>panic!</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">pop</span>();    <span class="comment">//返回Some（“h”）</span></span><br><span class="line">    s.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwarp</span>();   <span class="comment">//返回&quot;h&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用is-some和is-none"><a href="#使用is-some和is-none" class="headerlink" title="使用is_some和is_none"></a>使用<code>is_some</code>和<code>is_none</code></h3><p>我们可以通过使用<code>is_some</code>和<code>is_none</code>方法来判断一个<code>Option</code>中是否存在值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">10</span>,<span class="number">40</span>,<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">if</span> v.<span class="title function_ invoke__">get</span>(<span class="number">1</span>).<span class="title function_ invoke__">is_some</span>() &#123;     <span class="comment">//使用is_some()判断是否存在值</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用unwrap-or-来提供默认值"><a href="#使用unwrap-or-来提供默认值" class="headerlink" title="使用unwrap_or()来提供默认值"></a>使用<code>unwrap_or()</code>来提供默认值</h3><p>我们在使用<code>unwrap</code>方法获取<code>Option</code>中值的时候，如果为<code>None</code>，则会直接触发<code>panic!</code>。实际上，Rust为我们提供了另一种方法<code>unwrap_or</code>，它可以在<code>None</code>时返回我们所设定的默认值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">div</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b!= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">div</span>(a,b).<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0.0</span>);   <span class="comment">//返回0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Rust 中的错误主要分为两类：<br><strong>可恢复错误</strong>，通常用于从系统全局角度来看可以接受的错误，例如处理用户的访问、操作等错误，这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响。<br><strong>不可恢复错误</strong>，刚好相反，该错误通常是全局性或者系统性的错误，例如数组越界访问，系统启动时发生了影响启动流程的错误等等，这些错误的影响往往对于系统来说是致命的。<br>很多编程语言，并不会区分这些错误，而是直接采用异常的方式去处理。Rust 没有异常，<code>Result&lt;T, E&gt;</code>用于可恢复错误，<code>panic!</code>用于不可恢复错误。</p>
<h2 id="被动触发"><a href="#被动触发" class="headerlink" title="被动触发"></a>被动触发</h2><p>让我们先来看一段简单的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有过C语言的经验，即使你越界了，问题不大，我依然尝试去访问，至于这个值是不是你想要的（<code>100</code>号内存地址也有可能有值，只不过是其它变量或者程序的！），抱歉，不归我管，我只负责取，你要负责管理好自己的索引访问范围。上面这种情况被称为<strong>缓冲区溢出</strong>，并可能会导致安全漏洞，例如攻击者可以通过索引来访问到数组后面不被允许的数据。<br>而在Rust中，为了保护程序远离这些漏洞，如果尝试读取一个索引不存在的元素，Rust会停止执行并拒绝继续，直接抛出<code>panic!</code>.</p>
<h2 id="主动调用"><a href="#主动调用" class="headerlink" title="主动调用"></a>主动调用</h2><p>在某些特殊场景中，开发者想要主动抛出一个异常，例如开头提到的在系统启动阶段读取文件失败。</p>
<p>对此，Rust为我们提供了<code>panic!</code>宏，当调用执行该宏时，程序会打印出一个错误信息，<strong>展开报错点往前的函数调用堆栈，最后退出程序</strong>。例如如下示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;crash and burn&#x27;, src/main.rs:2:5</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>

<h2 id="backtrace-栈展开"><a href="#backtrace-栈展开" class="headerlink" title="backtrace 栈展开"></a>backtrace 栈展开</h2><p>在上面代码抛出的异常中，编译器提醒我们<code>run with </code>RUST_BACKTRACE&#x3D;1<code> environment variable to display a backtrace</code>。这就是Rust为我们提供的栈展开技术。在真实场景中，错误往往涉及到很长的调用链甚至会深入第三方库，如果没有栈展开技术，错误将难以跟踪处理。<br>让我们看下面一个真实的崩溃例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们如果使用<code>RUST_BACKTRACE=1 cargo run</code>运行程序，会得到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 3 but the index is 99&#x27;, src/main.rs:4:5</span><br><span class="line">stack backtrace:</span><br><span class="line">   0: rust_begin_unwind</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5</span><br><span class="line">   1: core::panicking::panic_fmt</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14</span><br><span class="line">   2: core::panicking::panic_bounds_check</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5</span><br><span class="line">   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10</span><br><span class="line">   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9</span><br><span class="line">   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9</span><br><span class="line">   6: world_hello::main</span><br><span class="line">             at ./src/main.rs:4:5</span><br><span class="line">   7: core::ops::function::FnOnce::call_once</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5</span><br><span class="line">note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.</span><br></pre></td></tr></table></figure>
<p>上面的代码就是一次<strong>栈展开</strong>（也称栈回溯），它包含了函数调用的顺序，当然按照逆序排列：最近调用的函数排在列表的最上方。因为咱们的<code>main</code>函数基本是最先调用的函数了，所以排在了倒数第二位，还有一个关注点，排在最顶部最后一个调用的函数是<code>rust_begin_unwind</code>，该函数的目的就是进行栈展开，呈现这些列表信息给我们。</p>
<p>要获取到栈回溯信息，你还需要开启<code>debug</code>标志，该标志在使用<code>cargo run</code>或者<code>cargo build</code>时自动开启（这两个操作默认是<code>Debug</code>运行方式）。同时，栈展开信息在不同操作系统或者Rust版本上也有所不同。</p>
<h2 id="panic-时的两种中止方式"><a href="#panic-时的两种中止方式" class="headerlink" title="panic 时的两种中止方式"></a>panic 时的两种中止方式</h2><p>无论是主动调用还是被动触发，在出现<code>panic!</code>时，Rust为我们提供了两种方式来处理终止流程：<strong>栈展开</strong>（unwinding）和<strong>直接终止</strong>(abort)</p>
<p>其中，默认的方式就是栈展开，这意味着Rust会回溯栈上数据和函数调用，因此也意味着更多的善后工作，好处是可以给出充分的报错信息和栈调用信息，便于事后的问题复盘。<br>直接终止，顾名思义，不清理数据就直接退出程序，善后工作交与操作系统来负责。</p>
<p>对于绝大多数用户，使用默认选择是最好的，但是当你关心最终编译出的二进制可执行文件大小时，那么可以尝试去使用直接终止的方式，例如下面的配置修改<code>Cargo.toml</code>文件，实现在<code>release</code>模式下遇到<code>panic</code>直接终止：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic = <span class="symbol">&#x27;abort</span>&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="可恢复的错误-Result"><a href="#可恢复的错误-Result" class="headerlink" title="可恢复的错误 Result"></a>可恢复的错误 Result</h1><p>大部分错误并没有严重到需要程序完全停止执行。有时候，一个函数失败仅仅是因为一个容易理解和响应的原因。例如：如果因为打开一个并不存在的文件而失败，此时我们可能想要创建这个文件，而并不是终止进程。此时，我们就可以使用<code>Result</code>来处理这种可恢复的错误。<br>之前章节提到过，<code>Result&lt;T, E&gt;</code>是一个枚举类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型参数<code>T</code>代表成功时存入的正确值的类型，存放方式是<code>Ok(T)</code>，<code>E</code>代表错误时存入的错误值，存放方式是<code>Err(E)</code>。</p>
<p>让我们来看下面一个代码示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MathError</span> &#123;</span><br><span class="line">    DivisionByZero,</span><br><span class="line">    NegativeSquareRoot,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">div</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, MathError&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b!= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MathError::DivisionByZero)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">div</span>(a,b).<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0.0</span>);   <span class="comment">//返回0.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sqrt</span>(a:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, MathError&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MathError::NegativeSquareRoot)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a.<span class="title function_ invoke__">sqrt</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码示例中，我们通过定义了一个<code>MathError</code>的枚举，使得我们进行错误运算时的返回值更加简洁易懂，也更方便管理。</p>
<h2 id="对返回的错误进行处理"><a href="#对返回的错误进行处理" class="headerlink" title="对返回的错误进行处理"></a>对返回的错误进行处理</h2><p>我们以标准库中对于文件的操作作为示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,   <span class="comment">//返回文件句柄</span></span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在匹配出<code>error</code>后，又对<code>error</code>进行了详细的匹配解析，最终结果：<br>· 如果是文件不存在错误<code>ErrorKind::NotFound</code>，就创建文件，这里创建文件<code>File::create</code>也是返回<code>Result</code>，因此继续用<code>match</code>对其结果进行处理：创建成功，将新的文件句柄赋值给<code>f</code>，如果失败，则 panic。<br>·  剩下的错误，一律<code>panic</code>。</p>
<h2 id="Result的辅助方法"><a href="#Result的辅助方法" class="headerlink" title="Result&lt;T, E&gt;的辅助方法"></a><code>Result&lt;T, E&gt;</code>的辅助方法</h2><p>在对<code>Result</code>的处理中，<code>match</code>可以胜任它的工作，不过他可能有点冗长并且不总是能很好的表明它的意图。<code>Result&lt;T,E&gt;</code>类型定义了很多辅助方法来处理各种情况。我们可以在Rust<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/index.html">官方文档</a>中进行查阅。下面列举几个常用的函数。</p>
<h3 id="unwrap"><a href="#unwrap" class="headerlink" title="unwrap"></a>unwrap</h3><p>使用<code>unwrap</code>方法处理<code>Result&lt;T,E&gt;</code>类型时，如果返回成功，就将<code>Ok(T)</code>中的值取出来，但是如果失败，就直接<code>panic!</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unwrap-or"><a href="#unwrap-or" class="headerlink" title="unwrap_or"></a>unwrap_or</h3><p>与上面我们在<code>Option</code>中讲到的<code>unwrap_or()</code>类似，我们也可以使用<code>unwrap_or</code>，在返回失败时返回我们设置的默认信息。这里不再举例。</p>
<h3 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h3><p><code>expect</code>跟<code>unwrap</code>很像，也是遇到错误直接<code>panic</code>, 但是会带上自定义的错误提示信息，相当于重载了错误打印的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;Failed to open hello.txt: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;, src/main.rs:4:37</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code>方法使得我们可以在两个<code>Result</code>类型之间进行相互转换：<code>Result&lt;T, E&gt;</code> -&gt; <code>Result&lt;U, E&gt;</code>(只转换Ok值的类型)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">line</span> = <span class="string">&quot;1\n2\n3\n4\n&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> line.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">match</span> num.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map</span>(|i| i*<span class="number">2</span>) &#123;     <span class="comment">//parse方法将字符串转换成i32</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;n&#125;&quot;</span>),      <span class="comment">//依次输出2, 4, 6, 8</span></span><br><span class="line">            <span class="title function_ invoke__">Err</span>(..) =&gt; &#123;&#125;,  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map-err"><a href="#map-err" class="headerlink" title="map_err"></a>map_err</h3><p><code>map_err</code>与我们上面介绍的<code>map</code>互补，它使得我们可以将：<code>Result&lt;T, E&gt;</code>转换为<code>Result&lt;T, F&gt;</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">x</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">map_err</span>(|e: std::io::Error| <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123; <span class="built_in">format!</span>(<span class="string">&quot;&#123;e&#125;&quot;</span>) &#125;); <span class="comment">//将错误信息类型转换为String类型</span></span><br><span class="line">    <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(()),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h2><p>咱们的程序几乎不太可能只有<code>A-&gt;B</code>形式的函数调用，在实际应用中，我们通常会把错误层层上传然后交给调用链的上游函数进行处理，错误传播将极为常见。</p>
<p>例如以下函数从文件中读取用户名，然后将结果进行返回：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 打开文件，f是`Result&lt;文件句柄,io::Error&gt;`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="comment">// 打开文件成功，将file句柄赋值给f</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="comment">// 打开文件失败，将错误返回(向上传播)</span></span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建动态字符串s</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="comment">// 从f文件句柄读取数据并写入s中</span></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="comment">// 读取成功，返回Ok封装的字符串</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="comment">// 将错误向上传播</span></span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传播错误的简写；-运算符"><a href="#传播错误的简写；-运算符" class="headerlink" title="传播错误的简写；?运算符"></a>传播错误的简写；<code>?</code>运算符</h2><p><code>?</code>运算符实际上就是一个宏，它的作用跟上面的<code>match</code>几乎一模一样：<br>对于<code>Result</code>来说：<br>·如果结果是<code>Ok(T)</code>，则把<code>T</code>赋值给一个变量<br>·如果结果是<code>Err(E)</code>，则直接返回该错误</p>
<p>对于<code>Option</code>来说：<br>·如果值是<code>Some(T)</code>，<code>Some(T)</code>中的值<code>T</code>便作为该表达式的返回值，同时函数继续<br>·如果值是<code>None</code>，此时<code>None</code>会从函数中提前返回</p>
<p>我们在使用<code>?</code>运算符后，下面的代码示例与上面的代码示例相同：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而实际上，<code>?</code>还能实现链式调用，<code>File::open</code>遇到错误就返回，没有错误就将<code>Ok</code>中的值取出来用于下一个方法调用:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="转换错误类型"><a href="#转换错误类型" class="headerlink" title="转换错误类型"></a>转换错误类型</h2><p>想象一下，一个设计良好的系统中，肯定有自定义的错误特征，错误之间很可能会存在上下级关系，例如标准库中的<code>std::io::Error</code>和<code>std::error::Error</code>，前者是<code>IO</code>相关的错误结构体，后者是一个最最通用的标准错误特征，同时前者实现了后者，因此<code>std::io::Error</code>可以转换为<code>std:error::Error</code>。<br>明白了以上的错误转换，? 的更胜一筹就很好理解了，它可以自动进行类型提升（转换）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">open_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;File, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中<code>File::open</code>报错时返回的错误是<code>std::io::Error</code>类型，但是<code>open_file</code>函数返回的错误类型是<code>std::error::Error</code>的特征对象，可以看到一个错误类型通过<code>?</code>返回后，变成了另一个错误类型，这就是<code>?</code>的神奇之处。</p>
<p>根本原因是在于标准库中定义的<code>From</code>特征，该特征有一个方法<code>from</code>，用于把一个类型转成另外一个类型，<code>?</code>可以自动调用该方法，然后进行隐式类型转换。因此只要函数返回的错误<code>ReturnError</code>实现了 <code>From&lt;OtherError&gt;</code>特征，那么<code>?</code>就会自动把<code>OtherError</code>转换为<code>ReturnError</code>。</p>
<p>这种转换非常好用，意味着你可以用一个大而全的<code>ReturnError</code>来覆盖所有错误类型，只需要为各种子错误类型实现这种转换即可。</p>
<p>同时，我们也可以使用我们在上面所提到的<code>map_err</code>来手动的修改返回的错误值的类型；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">x</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">map_err</span>(|e| <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123; <span class="built_in">format!</span>(<span class="string">&quot;&#123;e&#125;&quot;</span>) &#125;)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-时常见的错误"><a href="#使用-时常见的错误" class="headerlink" title="使用?时常见的错误"></a>使用?时常见的错误</h2><p>初学者在使用<code>?</code>是，经常容易出现错误，比如写出如下的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first</span>(arr: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">   arr.<span class="title function_ invoke__">get</span>(<span class="number">0</span>)?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码无法通过编译，切记<code>?</code>操作符需要一个变量来承载正确的值，这个函数只会返回<code>Some(&amp;i32)</code>或者<code>None</code>，只有错误值能直接返回，正确的值不行，所以如果数组中存在<code>0</code>号元素，那么函数第二行使用<code>?</code>后的返回类型为<code>&amp;i32</code>而不是<code>Some(&amp;i32)</code>。因此<code>?</code>只能用于以下形式：<br><code>let v = xxx()?;</code><br><code>xxx()?.yyy()?;</code></p>
<p>我们需要修改上述代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first</span>(arr: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span> = arr.<span class="title function_ invoke__">get</span>(<span class="number">0</span>)?;</span><br><span class="line">   <span class="title function_ invoke__">Some</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Option和Result的相互转换"><a href="#Option和Result的相互转换" class="headerlink" title="Option和Result的相互转换"></a>Option和Result的相互转换</h2><p>在枚举那节的笔记中就有详细介绍，这里不再赘述。</p>
<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><img src="/images/14-10.png" alt="" width="1000">

<p>修改后的代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修复calL函数的错误</span></span><br><span class="line"><span class="comment">//当b为None时，按默认值1</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">divide</span>(a,b).<span class="title function_ invoke__">unwrap_or</span>(<span class="number">1</span>);   <span class="comment">//使用unwrap_or()方法设定默认值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">sqrt</span>(r).<span class="title function_ invoke__">map_err</span>(|e| <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123; <span class="built_in">format!</span>(<span class="string">&quot;&#123;e&#125;&quot;</span>) &#125;)?;  <span class="comment">//使用map_err方法转换错误的类型，并使用？传播错误</span></span><br><span class="line">    <span class="title function_ invoke__">OK</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="number">0</span>ption&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b !=<span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">MathError</span> &#123;</span><br><span class="line">    DivisionByZero,</span><br><span class="line">    NegativeSquareRoot,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sqrt</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, MathError&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> x&lt;<span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MathError::NegativeSquareRoot)</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(x.<span class="title function_ invoke__">sqrt</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/22/rust-collections/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/22/rust-collections/" class="post-title-link" itemprop="url">十三、Rust基础-常见集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-22 10:09:47" itemprop="dateCreated datePublished" datetime="2024-10-22T10:09:47+08:00">2024-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-24 05:47:42" itemprop="dateModified" datetime="2024-10-24T05:47:42+08:00">2024-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h1><p>集合类型在Rust中是一类比较特殊的类型，因为 Rust 中大多数数据类型都只能代表一个特定的值，但是集合却可以代表一大堆值。而且与语言级别的数组、字符串类型不同，标准库里的这些家伙是分配在堆上，因此都可以进行动态的增加和减少。标准库中最最常用的集合类型有：<code>Vector</code>、<code>HashNap</code>、<code>String</code>。</p>
<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p><code>Vec</code>是一个动态数组，可以根据需要动态增长和缩小。适用于需要按顺序存储数据的场景。</p>
<h3 id="创建和初始化"><a href="#创建和初始化" class="headerlink" title="创建和初始化"></a>创建和初始化</h3><p>在Rust中，有多种方式可以创建动态数组。</p>
<p>我们可以使用<code>Vec::new</code>来创建动态数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>
<p>也可以通过宏<code>vec!</code>来创建数组，同时，使用<code>vec!</code>创建数组时还可以在创建的同时给予初始化的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>当我们想要向数组的尾部添加元素时，我们可以使用<code>push</code>的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>与其它类型一样，必须将<code>v</code>声明为<code>mut</code>后，才能进行修改。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>从<code>vec</code>中读取指定位置的元素有两种方法可以选择：<br>·通过下标索引访问<br>·通过<code>get</code>方法访问</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The is no third element&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，通过<code>get()</code>方法访问时返回的是<code>Option</code>类型，在索引处有值时返回<code>Some(T)</code>，在数组越界访问时返回<code>None</code>。这是一种相对安全的访问方法，相反，通过下标索引进行访问时，如果出现越界访问，程序会直接<code>panic!</code>.</p>
<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">v[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>);   <span class="comment">// The third element is 10</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;       <span class="comment">//推荐使用向量的引用，否则所有权会发生转移</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们可以在迭代过程中，修改<code>v</code>中的元素：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用枚举存储多种类型"><a href="#使用枚举存储多种类型" class="headerlink" title="使用枚举存储多种类型"></a>使用枚举存储多种类型</h2><p><code>Vec</code>中的元素必须类型相同，但我们也可以通过使用枚举类型和特征对象来实现不同类型元素的存储:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V10</span>(<span class="type">i32</span>),   <span class="comment">//随便加的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        IpAddr::<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        IpAddr::<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::1&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        IpAddr::<span class="title function_ invoke__">V10</span>(<span class="number">32</span>)</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ip</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        <span class="title function_ invoke__">show_addr</span>(ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show_addr</span>(ip: IpAddr) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过特征对象实现不同类型元素的存储老师没讲，具体请参照：<a target="_blank" rel="noopener" href="https://course.rs/basic/collections/vector.html">Rust语言圣经</a></p>
<h2 id="容量与重新分配"><a href="#容量与重新分配" class="headerlink" title="容量与重新分配"></a>容量与重新分配</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">10</span>);     <span class="comment">//创建一个容量为10的数组</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Capacity is: &#123;&#125;&quot;</span>, v.<span class="title function_ invoke__">capacity</span>());  <span class="comment">// Capacity is 10</span></span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Capacity is: &#123;&#125;&quot;</span>, v.<span class="title function_ invoke__">capacity</span>());  <span class="comment">// Capacity is 10, push容量不会扩容，避免内存重新分配</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;value is &#123;:?&#125;&quot;</span>, v);   <span class="comment">//value is [1]  </span></span><br></pre></td></tr></table></figure>

<h2 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h2><p>· <strong>不安全的索引访问</strong><br>如上所述，直接通过索引对数组进行访问，一旦越界就会直接报错<code>panic!</code>。因此，推荐使用<code>get()</code>方法对数组进行访问，或者在通过索引进行访问前确认所访问的索引未越界（一般通过<code>if</code>）.</p>
<p>· <strong>可变引用与不可变引用的混用</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);  <span class="comment">//可变引用</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The first element is &#123;&#125;&quot;</span>, first);     <span class="comment">//此时会报错，因为Rust不允许可变引用和不可变引用同时存在</span></span><br></pre></td></tr></table></figure>

<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>和动态数组一样，<code>HashMap</code>也是Rust标准库中提供的集合类型，但是又与动态数组不同，<code>HashMap</code>中存储的是一一映射的<code>KV</code>键值对，并提供了平均复杂度为<code>O(1)</code>的查询方法，当我们希望通过一个<code>Key</code>去查询值时，该类型非常有用，以致于 Go 语言将该类型设置成了语言级别的内置特性。</p>
<p>Rust 中哈希类型（哈希映射）为<code>HashMap&lt;K,V&gt;</code>。</p>
<h3 id="创建和初始化-1"><a href="#创建和初始化-1" class="headerlink" title="创建和初始化"></a>创建和初始化</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;string, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);    <span class="comment">// 插入元素</span></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>从上面的例子中，我们需要注意：在使用<code>HashMap</code>类型时需要手动通过<code>use ...</code>来从标准库中引入到我们当前的作用域中，因为<code>HashMap</code>并没有包含在Rust的<code>prelude</code>中。<br>同时，跟其它集合类型一致，<code>HashMap</code>也是内聚性的，即所有的<code>K</code>必须拥有同样的类型，<code>V</code>也是如此。</p>
<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;string, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);    <span class="comment">// 插入元素</span></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);     <span class="comment">//使用get方法进行访问，返回Option类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> score &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The &#123;&#125; score is &#123;&#125;&quot;</span>, team_name, s),</span><br><span class="line">    <span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历元素-1"><a href="#遍历元素-1" class="headerlink" title="遍历元素"></a>遍历元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;string, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);    </span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (team, score) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The &#123;&#125; score is &#123;&#125;&quot;</span>, team_name, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更新哈希表"><a href="#更新哈希表" class="headerlink" title="更新哈希表"></a>更新哈希表</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;string, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);    </span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);       <span class="comment">//&#123;&quot;Blue&quot;: 10, &quot;Yellow&quot;: 25&#125;</span></span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name); </span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> score &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; score is &#123;&#125;&quot;</span>, team_name, s), <span class="comment">// Blue score is 25</span></span><br><span class="line">    <span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">entry</span> = scores.<span class="title function_ invoke__">entry</span>(<span class="string">&quot;Red&quot;</span>).<span class="title function_ invoke__">or_insert</span>(<span class="number">5</span>);    <span class="comment">// entry方法，查询Yellow对应的值，如果不存在则插入新值</span></span><br><span class="line">*entry += <span class="number">10</span>;   <span class="comment">//说明or_insert返回了&amp;mut entry引用，因此可以通过该可变引用直接修改 map 中对应的值</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码示例中，我们可以发现<code>insert</code>不仅可以插入新值，还可以覆盖原有的值。<br>同时，我们还可以发现<code>entry</code>可以查询HashMap中的键，如果其下没有值，则插入新值。</p>
<h2 id="合并哈希表"><a href="#合并哈希表" class="headerlink" title="合并哈希表"></a>合并哈希表</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map1.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map1.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map2</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map2.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;b&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map2.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;c&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k,v) <span class="keyword">in</span> map2 &#123;  <span class="comment">//HashMap的遍历是无序的</span></span><br><span class="line">    map1.<span class="title function_ invoke__">insert</span>(k,v);   <span class="comment">//map2的b值3覆盖map1的b</span></span><br><span class="line">    map1.<span class="title function_ invoke__">entry</span>(k).<span class="title function_ invoke__">or_insert</span>(v);     <span class="comment">//与上面相反</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use::std::collections::HashMap;</span><br><span class="line">use::std::collections::hash_map::DefaultHasher;</span><br><span class="line">use::std::hash::&#123;Hash,Hasher&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_hash</span>&lt;t: &amp;T&gt; <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = DefaultHasher::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    t.<span class="title function_ invoke__">hash</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">    s.<span class="title function_ invoke__">finish</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Key1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Key2&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hash of key1:&#123;&#125;, hash of key2:&#123;&#125;&quot;</span>, <span class="title function_ invoke__">calculate_hash</span>(&amp;key1), <span class="title function_ invoke__">calculate_hash</span>(&amp;key2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面，我们构建了函数是的我们可以查看对应<code>key</code>的哈希值。我们在编程中需要尽量避免哈希冲突</p>
<h2 id="值的所有权问题"><a href="#值的所有权问题" class="headerlink" title="值的所有权问题"></a>值的所有权问题</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">field_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(field_name, field_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时field_name和field_value的所有权已经发生转移</span></span><br></pre></td></tr></table></figure>

<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><img src="/images/13-1.png" alt="" width="1000">

<p>练习1:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;T&gt; &#123;</span><br><span class="line">    elements: vec&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Stack&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        Stack &#123;</span><br><span class="line">            elements: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, item: T) &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements.<span class="title function_ invoke__">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">pop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements.<span class="title function_ invoke__">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">peek</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements.<span class="title function_ invoke__">last</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = Stack::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Top element is: &#123;:?&#125;&quot;</span>, stack.<span class="title function_ invoke__">peek</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Popped element: &#123;:?&#125;&quot;</span>, stack.<span class="title function_ invoke__">pop</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Top element is: &#123;:?&#125;&quot;</span>, stack.<span class="title function_ invoke__">peek</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习2:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">word_frequency_counter</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> HashMap&lt;<span class="type">String</span>, <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">frequencies</span> = HashMap::<span class="title function_ invoke__">new</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历文本，将其按空格或标点符号分割成单词</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cleaned_word</span> = word</span><br><span class="line">            .<span class="title function_ invoke__">trim_matches</span>(|c: <span class="type">char</span>| !c.<span class="title function_ invoke__">is_alphabetic</span>())</span><br><span class="line">            .<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !cleaned_word.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            *frequencies.<span class="title function_ invoke__">entry</span>(cleaned_word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>) += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frequencies</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;On a quiet night, the city lights reflected on the rippling river, and the distant sound of a bell echoed softly. Eileen stood by the bridge, pondering her upcoming journey. Her backpack was filled with maps, a compass, and an unsent letter. She had rewritten the letter countless times but had never mustered the courage to deliver it to that person.&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word_frequencies</span> = <span class="title function_ invoke__">word_frequency_counter</span>(text);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (word, count) <span class="keyword">in</span> word_frequencies &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27;: &#123;&#125;&quot;</span>, word, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习3:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    title: <span class="type">String</span>,</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    quantity: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Inventory</span> &#123;</span><br><span class="line">    books: HashMap&lt;<span class="type">String</span>, Book&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Inventory</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Inventory &#123;</span><br><span class="line">        Inventory &#123;</span><br><span class="line">            books: HashMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_book</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, title: <span class="type">String</span>, author: <span class="type">String</span>, quantity: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">book</span> = Book &#123;</span><br><span class="line">            title: title.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            author,</span><br><span class="line">            quantity,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">self</span>.books.<span class="title function_ invoke__">insert</span>(title, book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">query_inventory</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">book</span> <span class="keyword">in</span> <span class="keyword">self</span>.books.<span class="title function_ invoke__">values</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Title: &#123;&#125;, Author: &#123;&#125;, Quantity: &#123;&#125;&quot;</span>, book.title, book.author, book.quantity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update_quantity</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, title: &amp;<span class="type">str</span>, quantity: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(book) = <span class="keyword">self</span>.books.<span class="title function_ invoke__">get_mut</span>(title) &#123;</span><br><span class="line">            book.quantity = quantity;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Updated &#123;&#125; quantity to &#123;&#125;&quot;</span>, title, quantity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Book not found: &#123;&#125;&quot;</span>, title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">delete_book</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, title: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.books.<span class="title function_ invoke__">remove</span>(title).<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Deleted book: &#123;&#125;&quot;</span>, title);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Book not found: &#123;&#125;&quot;</span>, title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/22/rust-pattern-matching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/22/rust-pattern-matching/" class="post-title-link" itemprop="url">十二、Rust-模式匹配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-22 08:21:56" itemprop="dateCreated datePublished" datetime="2024-10-22T08:21:56+08:00">2024-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-24 03:56:54" itemprop="dateModified" datetime="2024-10-24T03:56:54+08:00">2024-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><p>模式匹配是一种强大的功能，可以检查拘束的结构并进行相应操作。同时，使用模式匹配可以提高代码的可读性和简洁性，减少错误，尤其是在处理复杂数据结构时。</p>
<h2 id="match表达式"><a href="#match表达式" class="headerlink" title="match表达式"></a><code>match</code>表达式</h2><p>让我们先来看一下 <code>match</code>表达式的通用形式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> target &#123;</span><br><span class="line">    模式<span class="number">1</span> =&gt; 表达式<span class="number">1</span>,</span><br><span class="line">    模式<span class="number">2</span> =&gt; &#123;</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        表达式<span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    _ =&gt; 表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>match</code>允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行对应的代码，下面让我们来一一详解，先看一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">match</span> number &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One!&quot;</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Two!&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Other!&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的，使用<code>match</code>进行模式匹配时必须遍历所有可能的值，在上述的例子中，我们使用通配符<code>_</code>来匹配<code>number</code>除了<code>1</code>和<code>2</code>的其他情况。</p>
<h3 id="字面值模式"><a href="#字面值模式" class="headerlink" title="字面值模式"></a>字面值模式</h3><p>使用<code>match</code>匹配字面值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> number &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One!&quot;</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Two!&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Other!&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> y &#123;</span><br><span class="line">    <span class="string">&quot;hello&quot;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Hello!&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Other!&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量模式"><a href="#变量模式" class="headerlink" title="变量模式"></a>变量模式</h3><p>使用<code>match</code>匹配变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    var =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，此时<code>x</code>的值实际上转移给了<code>var</code>中，只是示例中的<code>x</code>是<code>i32</code>类型，实现了<code>copy</code>特性。如果是<code>String</code>类型，则所有权已经发生了转移，之后不能使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    var =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);     <span class="comment">// 此时无法打印，因为所有权已经发生了转移</span></span><br></pre></td></tr></table></figure>

<h3 id="通配符模式"><a href="#通配符模式" class="headerlink" title="通配符模式"></a>通配符模式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Any Value!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构模式"><a href="#结构模式" class="headerlink" title="结构模式"></a>结构模式</h3><p>下面的例子展示了如何使用<code>match</code>来解构结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; x:<span class="type">i32</span>, y:<span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Point&#123; x:<span class="number">0</span>, y:<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">match</span> p &#123;</span><br><span class="line">    Point&#123; x, y:<span class="number">0</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>, x);</span><br><span class="line">    Point&#123; x:<span class="number">0</span>, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>, y);</span><br><span class="line">    Point&#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On neither axis: (&#123;&#125;,&#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="守卫和绑定"><a href="#守卫和绑定" class="headerlink" title="守卫和绑定"></a>守卫和绑定</h3><p>· <strong>守卫</strong>： 在模式匹配中，可以使用守卫来添加额外的条件判断：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    n <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Even!&quot;</span>);</span><br><span class="line">    n =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Odd!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>· <strong>绑定</strong>：在模式匹配中，可以使用绑定将模式中的值绑定到变量上：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello&#123; id:<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello&#123; id: var @ <span class="number">3</span>..<span class="number">7</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Found id in range, value: &#123;&#125;&quot;</span>, var);</span><br><span class="line">    Message::Hello&#123; id &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Found other id, value: &#123;&#125;&quot;</span>, var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，最重要的就是符号<code>@</code>，它可以将匹配模式的范围进行值的绑定。</p>
<h2 id="匹配模式的应用场景"><a href="#匹配模式的应用场景" class="headerlink" title="匹配模式的应用场景"></a>匹配模式的应用场景</h2><h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">divide</span>(<span class="number">4</span>,<span class="number">2</span>);    <span class="comment">//返回Result类型</span></span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The error is &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>,<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">From</span>(<span class="string">&quot;Cannot divide by zero&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a / b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，模式匹配还可以用于解析命令行参数、解析配置文件、解析数据包、解析XML或JSON等数据格式。</p>
<h2 id="高级技巧-嵌套模式"><a href="#高级技巧-嵌套模式" class="headerlink" title="高级技巧-嵌套模式"></a>高级技巧-嵌套模式</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Say</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">MoveTo</span>(<span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColorRGB</span>(<span class="type">u16</span>, <span class="type">u16</span>, <span class="type">u16</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">actions</span> = [</span><br><span class="line">        Action::<span class="title function_ invoke__">Say</span>(<span class="string">&quot;Hello Rust&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        Action::<span class="title function_ invoke__">MoveTo</span>(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">        Action::<span class="title function_ invoke__">ChangeColorRGB</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">action</span> <span class="keyword">in</span> actions &#123;</span><br><span class="line">        <span class="keyword">match</span> action &#123;</span><br><span class="line">            Action::<span class="title function_ invoke__">Say</span>(s) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">            &#125;,</span><br><span class="line">            Action::<span class="title function_ invoke__">MoveTo</span>(x, y) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;point from (0, 0) move to (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">            &#125;,</span><br><span class="line">            Action::<span class="title function_ invoke__">ChangeColorRGB</span>(r, g, _) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;change color into &#x27;(r:&#123;&#125;, g:&#123;&#125;, b:0)&#x27;, &#x27;b&#x27; has been ignored&quot;</span>,</span><br><span class="line">                    r, g,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匹配模式与迭代器的结合"><a href="#匹配模式与迭代器的结合" class="headerlink" title="匹配模式与迭代器的结合"></a>匹配模式与迭代器的结合</h2><p>在实战中，我们可以结合<code>iter</code>和<code>match</code>使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">vec2</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (a,b) <span class="keyword">in</span> vec1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(vec2) &#123;    <span class="comment">//zip()方法自行查阅文档，在提取(a,b）时用到了模式匹配</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, a, b , a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if-let和while-let"><a href="#if-let和while-let" class="headerlink" title="if let和while let"></a><code>if let</code>和<code>while let</code></h2><p>使用<code>if let</code>和<code>while let</code>可以简化单个模式匹配：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">opt</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = opt &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Value is &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_ invoke__">into_iter</span>();     <span class="comment">//迭代器类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;matched &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ref和ref-mut"><a href="#ref和ref-mut" class="headerlink" title="ref和ref mut"></a><code>ref</code>和<code>ref mut</code></h2><p>在模式匹配中，如果我们不想所有权发生转移，则可以使用<code>ref</code>和<code>ref mut</code>关键字来借用数据而非转移所有权：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="keyword">ref</span> var =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);     <span class="comment">// 此时可以打印，因为只是借用，所有权并为发生转移</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="keyword">ref</span> var =&gt; &#123;</span><br><span class="line">        *var = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);     <span class="comment">// 此时可以打印，且字符串的值发生了变化</span></span><br></pre></td></tr></table></figure>

<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><img src="/images/12-1.png" alt="" width="1000">

<p>解：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> serde_json::&#123;Value, json&#125;;</span><br><span class="line"><span class="keyword">use</span> serde_json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = json!(&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="number">30</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;alice@example.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;street&quot;</span>: <span class="string">&quot;123 Main St&quot;</span>,</span><br><span class="line">            <span class="string">&quot;city&quot;</span>: <span class="string">&quot;Wonderland&quot;</span> ,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;phone_numbers&quot;</span>: [<span class="string">&quot;123-456-7890&quot;</span>, <span class="string">&quot;987-654-3210&quot;</span>],</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(name) = data.<span class="title function_ invoke__">get</span>(<span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Value</span>::<span class="title function_ invoke__">String</span>(name_str) = name &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Name: &#123;&#125;&quot;</span>, name_str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(age) = data.<span class="title function_ invoke__">get</span>(<span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Value</span>::<span class="title function_ invoke__">Number</span>(age_num) = age &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Age: &#123;&#125;&quot;</span>, age_num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(address) = data.<span class="title function_ invoke__">get</span>(<span class="string">&quot;address&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Value</span>::<span class="title function_ invoke__">Object</span>(address_obj) = address &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(street) = address_obj.<span class="title function_ invoke__">get</span>(<span class="string">&quot;street&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Street: &#123;&#125;&quot;</span>, street);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(city) = address_obj.<span class="title function_ invoke__">get</span>(<span class="string">&quot;city&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;City: &#123;&#125;&quot;</span>, city);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(phone_numbers) = data.<span class="title function_ invoke__">get</span>(<span class="string">&quot;phone_numbers&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Value</span>::<span class="title function_ invoke__">Array</span>(numbers) = phone_numbers &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> numbers &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Value</span>::<span class="title function_ invoke__">String</span>(number_str) = number &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Phone number: &#123;&#125;&quot;</span>, number_str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/17/rust-struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/rust-struct/" class="post-title-link" itemprop="url">十一、Rust基础-结构体</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-17 06:47:15" itemprop="dateCreated datePublished" datetime="2024-10-17T06:47:15+08:00">2024-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-24 02:06:37" itemprop="dateModified" datetime="2024-10-24T02:06:37+08:00">2024-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="结构体语法"><a href="#结构体语法" class="headerlink" title="结构体语法"></a>结构体语法</h2><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>一个结构体由以下几部分组成：<br>· 通过关键字<code>struct</code>定义<br>·一个清晰明确的结构体<code>名称</code><br>·几个有名字的结构体<code>字段</code></p>
<p>示例代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        active: <span class="type">bool</span>,</span><br><span class="line">        username: <span class="type">String</span>,</span><br><span class="line">        email: <span class="type">String</span>,</span><br><span class="line">        sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，该<code>User</code>结构体拥有四个字段。</p>
<h3 id="创建结构体实例"><a href="#创建结构体实例" class="headerlink" title="创建结构体实例"></a>创建结构体实例</h3><p>在定义好结构体后，为了使用它，我们需要创建<code>User</code>结构体的<strong>实例</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在初始化结构体实例的时候，我们需要注意：</p>
<ol>
<li>每个字段都要进行初始化；</li>
<li>初始化时的字段顺序不需要与定义时的顺序一致</li>
<li>字段名需要用逗号分隔</li>
</ol>
<h3 id="访问结构体字段"><a href="#访问结构体字段" class="headerlink" title="访问结构体字段"></a>访问结构体字段</h3><p>通过<code>.</code>操作符即可访问结构体实例内部的字段值，如果我们需要修改结构体中的某个字段，首先我们需要保证该结构体实例是可变的，因为Rust并不允许我们只将其中的某个字段标记为可变：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="简化结构体创建"><a href="#简化结构体创建" class="headerlink" title="简化结构体创建"></a>简化结构体创建</h3><p>下面我们构建一个函数来返回<code>User</code>结构体的实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email: email,</span><br><span class="line">        username: username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数接收两个字符串参数：<code>email</code>和<code>username</code>，然后使用它们来创建一个<code> User</code>结构体，并且返回。可以注意到这两行：<code>email: email</code>和<code>username: username</code>，有些啰嗦，但是好在我们可以对它进行简化：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体更新语法"><a href="#结构体更新语法" class="headerlink" title="结构体更新语法"></a>结构体更新语法</h3><p>在实际场景中，有一种情况很常见：根据已有的结构体实例，创建新的结构体实例，例如根据已有的<code>user1</code>实例来构建<code>user2</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">      active: user1.active,</span><br><span class="line">      username: user1.username,</span><br><span class="line">      email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">      sign_in_count: user1.sign_in_count,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>上面这段更新语法也有些繁琐，需要我们手动的<code>user1</code>的三个字段逐渐赋值给<code>user2</code>，但是我们有如下的语法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">      email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">      ..user1</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>..user1</code>语法来表示凡是我们没有显式声明的字段，全部从<code>user1</code>中自动获取。</p>
<h2 id="元组结构体（Tuple-Struct）"><a href="#元组结构体（Tuple-Struct）" class="headerlink" title="元组结构体（Tuple Struct）"></a>元组结构体（Tuple Struct）</h2><p>结构体必须要有名称，但是结构体的字段可以没有名称。对于这些长的像元组的没有字段名称的结构体，我们称之为元组结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, black.<span class="number">0</span>, origin.<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单元结构体（Unit-like-Struct）"><a href="#单元结构体（Unit-like-Struct）" class="headerlink" title="单元结构体（Unit-like Struct）"></a>单元结构体（Unit-like Struct）</h2><p>如果你定义一个类型，但是不关心该类型的内容，只关心它的行为时，就可以使用<code>单元结构体</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SomeTrait</span> <span class="keyword">for</span> <span class="title class_">AlwaysEqual</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体数据的所有权"><a href="#结构体数据的所有权" class="headerlink" title="结构体数据的所有权"></a>结构体数据的所有权</h2><p><strong>所有权</strong>是Rust中最为核心的概念。自然，结构体也有所有权。在结构体中，所有权的范围在字段范围内，也就是说，当一个结构体中的一个字段的所有权发生了转移时，该结构体中的其他字段仍然可以继续使用。但是，由于该结构体中的一个字段的所有权已经发生了转移，因此该结构体也不能再被继续使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    active: user1.active,</span><br><span class="line">    username: user1.username,</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, user1.active);   <span class="comment">//use1.active实现了copy特性，因此所有权没有转移</span></span><br><span class="line"><span class="comment">// 下面这行会报错</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, user1.username);   <span class="comment">//use1.username是String类型并没有实现copy特性，所有权在赋值时发生了转移</span></span><br><span class="line"><span class="comment">// 下面这行也会报错</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, user1);</span><br></pre></td></tr></table></figure>

<p>在上面<code>User</code>结构体的定义中，对于<code>username</code>和<code>email</code>字段我们均使用了自身拥有所有权的<code>String</code>类型而非基于引用的<code>&amp;str</code>字符串切片类型。这是因为我们希望<code>User</code>结构体<strong>拥有它所有的数据，而不是从其他地方借用数据</strong>。如果我们想让<code>User</code>结构体从其他对象借用数据，我们就需要引入<strong>生命周期</strong>这个概念，否则就会报错：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: &amp;<span class="type">str</span>,</span><br><span class="line">    email: &amp;<span class="type">str</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="string">&quot;someone@example.com&quot;</span>,</span><br><span class="line">        username: <span class="string">&quot;someusername123&quot;</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器会抱怨它需要生命周期标识符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:2:15</span><br><span class="line">  |</span><br><span class="line">2 |     username: &amp;str,</span><br><span class="line">  |               ^ expected named lifetime parameter // 需要一个生命周期</span><br><span class="line">  |</span><br><span class="line">help: consider introducing a named lifetime parameter // 考虑像下面的代码这样引入一个生命周期</span><br><span class="line">  |</span><br><span class="line">1 ~ struct User&lt;&#x27;a&gt; &#123;</span><br><span class="line">2 ~     username: &amp;&#x27;a str,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:3:12</span><br><span class="line">  |</span><br><span class="line">3 |     email: &amp;str,</span><br><span class="line">  |            ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">1 ~ struct User&lt;&#x27;a&gt; &#123;</span><br><span class="line">2 |     username: &amp;str,</span><br><span class="line">3 ~     email: &amp;&#x27;a str,</span><br><span class="line">  |</span><br></pre></td></tr></table></figure>
<p>我们只需要在对应的地方添加生命周期标识符，就可以通过编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    username: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    email: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="string">&quot;someone@example.com&quot;</span>,</span><br><span class="line">        username: <span class="string">&quot;someusername123&quot;</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Rust中的结构体<code>struct</code>是一个符合数据结构，它是拥有数据的集合。同时对于结构体来说，它也可以具有一些行为，这些行为在Rust中叫做方法。</p>
<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><p>· 使用<code>impl</code>关键字包裹结构体上下文，随后使用<code>fn</code>关键字和名称声明。它可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。<br>· 方法与函数是不同的，因为方法在结构体的上下文中被定义，它们的第一个参数总是<code>self</code>，代表着<strong>调用该方法的结构体实例</strong>。</p>
<p>我们来看如下代码示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width:<span class="number">30</span>, height:<span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the area of rectangle is &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码示例中，我们使用<code>&amp;self</code>作为传入方法的参数，它实际上是<code>self: &amp;Self</code>和<code>rectangle: &amp;Rectangle</code>的简写，上面三种写法效果一致。</p>
<p>同时我们需要注意<code>self</code>依然有着所有权的概念：<br>· <code>self</code>表示<code>Rectangle</code>的所有权需要转移到该方法中，这种形式使用较少<br>· <code>&amp;self</code>表示该方法对<code>Rectangle</code>的不可变借用<br>· <code>&amp;mut self</code>表示可变借用</p>
<h3 id="方法名与结构体字段名相同"><a href="#方法名与结构体字段名相同" class="headerlink" title="方法名与结构体字段名相同"></a>方法名与结构体字段名相同</h3><p>在Rust中，我们允许方法名跟结构体的字段名相同：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width:<span class="number">30</span>, height:<span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rect1.<span class="title function_ invoke__">width</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the rectangle has  a non-zero width: &#123;&#125;&quot;</span>, rect1.width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述的代码示例中，当我们使用方法<code>rect1.width()</code>时，Rust知道我们在调用它的方法；而在使用<code>rect1.width</code>时，则是访问它的字段。</p>
<h3 id="getter访问器"><a href="#getter访问器" class="headerlink" title="getter访问器"></a><code>getter</code>访问器</h3><p>在许多场景下，我们需要将结构体设置为私有，而定义一些公开的方法来让用户可以访问结构体的字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width:<span class="number">30</span>, height:<span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">width</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们只能通过访问器<code>rect1.width()</code>来获取举行的宽度。而<code>width</code>字段时私有的，当用户在其他模块访问<code>rect1.width</code>字段时，就会报错</p>
<h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><p>所有在<code>impl</code>块中定义的函数被称为<strong>关联函数</strong>（associated functions），因为它们与<code>impl</code>后面命名的类型相关。</p>
<p>关联函数并没有<code>self</code>，也不能使用<code>f.read()</code>的形式调用，因此它是一个函数而不是方法，<code>String::from</code>就是一个关联函数。</p>
<p>让我们来看如下的代码示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width, height &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle::<span class="title function_ invoke__">new</span>(<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码示例中，我们为结构体<code>Rectangle</code>创建了关联函数<code>new</code>。在调用关联函数时，我们需要使用<code>::</code>来进行调用。</p>
<p>值得注意的是，Rust有一个约定俗成的规则，就是使用<code>new</code>来作为构造器的名称。</p>
<h3 id="多个impl定义"><a href="#多个impl定义" class="headerlink" title="多个impl定义"></a>多个impl定义</h3><p>Rust允许我们为一个结构体定义多个<code>impl</code>块，其目的是为了提供更多的灵活性和代码组织性。当方法较多时，我们可以将相关的方法组织在一个<code>impl</code>块中。</p>
<h2 id="实现trait"><a href="#实现trait" class="headerlink" title="实现trait"></a>实现trait</h2><h3 id="为类型实现特征"><a href="#为类型实现特征" class="headerlink" title="为类型实现特征"></a>为类型实现特征</h3><p>如果不同的类型具有相同的行为，那么我们就可以定义一个特征，然后为这些类型实现该特征。</p>
<p><strong>定义特征</strong>是把一些方法组合在一起，目的是定义一个实现某些目标所必需的行为的集合。我们需要使用<code>trait</code>关键词来定义一个特征； </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">tarit Shape &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    radius: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.width * <span class="keyword">self</span>.height) <span class="keyword">as</span> <span class="type">f64</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        (radius * radius) <span class="keyword">as</span> <span class="type">f64</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_area</span>(shape: &amp;<span class="keyword">impl</span> <span class="title class_">Shape</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, shape.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="title function_ invoke__">print_area</span>(&amp;rect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Debug特征"><a href="#Debug特征" class="headerlink" title="Debug特征"></a>Debug特征</h3><p>与上一节<code>enum</code>相同，我们需要使用<code>#[derive(Dbug)]</code>对结构体进行标记，才能使用<code>println!(&quot;&#123;&#125;&quot;, struct)</code>对结构体进行打印，原因也相同，因为结构体并没有实现<code>Display</code>特征。</p>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>对于以下的结构体，实现<code>Debug</code>特征：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    height: <span class="type">i32</span>,</span><br><span class="line">    width: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use::std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    height: <span class="type">i32</span>,</span><br><span class="line">    width: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::<span class="built_in">Debug</span> <span class="keyword">for</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;Rectangle &#123;&#123; height: &#123;&#125;, width: &#123;&#125; &#125;&#125;&quot;</span>, <span class="keyword">self</span>.height, <span class="keyword">self</span>.width)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rec</span> = Rectangle&#123; height: <span class="number">10</span>, width: <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, rec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/12/rust-enum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/12/rust-enum/" class="post-title-link" itemprop="url">十、Rust-枚举Enum</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-12 22:33:00" itemprop="dateCreated datePublished" datetime="2024-10-12T22:33:00+08:00">2024-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-24 03:11:34" itemprop="dateModified" datetime="2024-10-24T03:11:34+08:00">2024-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="枚举（Enum）"><a href="#枚举（Enum）" class="headerlink" title="枚举（Enum）"></a>枚举（Enum）</h1><p>· Option<br>· Result</p>
<h2 id="对比不同语言中的enum"><a href="#对比不同语言中的enum" class="headerlink" title="对比不同语言中的enum"></a>对比不同语言中的enum</h2><pre><code>从写法上对比一下
</code></pre>
<h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">North</span>,</span><br><span class="line">    <span class="title class_">East</span>,</span><br><span class="line">    <span class="title class_">South</span>,</span><br><span class="line">    <span class="title class_">West</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Using enum</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">dir</span>: <span class="title class_">Direction</span> = <span class="title class_">Direction</span>.<span class="property">North</span>;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    North,</span><br><span class="line">    East,</span><br><span class="line">    South,</span><br><span class="line">    West</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Using enum</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Direction dir:  = North;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h3><p>在<code>Rust</code>中，对于<code>enum</code>的定义与其他语言并无二致，我们可以通过列举可能的成员来定义一个<strong>枚举类型</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    North,</span><br><span class="line">    East,</span><br><span class="line">    South,</span><br><span class="line">    West,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Using enum</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">dir</span>: Direction = Direction::North;</span><br></pre></td></tr></table></figure>
<p>同时，我们也可以通过<code>::</code>操作符来访问我们创建的<code>枚举类型Direction</code>下具体的<code>枚举成员North</code></p>
<h2 id="语法-规范"><a href="#语法-规范" class="headerlink" title="语法&amp;规范"></a>语法&amp;规范</h2><p><strong>· 语法</strong><br>    · field-less enum   &#x2F;&#x2F;只定义类型而不包含任何值的enum<br>    · unit-only enum    &#x2F;&#x2F;只包含单元类型的enum<br><strong>· 语法</strong><br>    · Pascal Case       &#x2F;&#x2F;枚举类型和枚举成员的每个单词首字母大写，中间不使用下划线和分隔符<br>    · snake_case        &#x2F;&#x2F;变量名、函数名采用小写字母和下划线分割</p>
<p>接下来我们通过一些代码来了解具体如何使用<code>enum</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Pets</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Cat</span>(<span class="type">String</span>),   <span class="comment">//将数据信息直接关联在枚举成员上</span></span><br><span class="line">        Dog &#123; name: <span class="type">String</span>, age: Usize&#125;,    <span class="comment">//使用Struct结构体</span></span><br><span class="line">        Bird    <span class="comment">//Unit type</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cat</span> = Pets::<span class="title function_ invoke__">Cat</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cat&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dog</span> = Pets::Dog &#123;</span><br><span class="line">        name: <span class="string">&quot;Alen&quot;</span>.<span class="title function_ invoke__">to_string</span>()，</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">我们来看上面的代码，首先我们定义了枚举类型`Pets`下面的三个枚举成员`<span class="title function_ invoke__">Cat</span>(<span class="type">String</span>)`、`Dog &#123;...&#125;`、`Bird`。随后，我们创建了枚举类型`Pets`下的两个成员实例`cat`、`dog`，它们也被称为枚举值，但他们都是货真价实的`Pets`枚举类型的。</span><br><span class="line"></span><br><span class="line">**任何类型的数据都可以放入枚举成员中**：例如字符串，数值、结构体甚至是另一个枚举。</span><br><span class="line"></span><br><span class="line">接下来我们看看如何最简单的使用一下这些枚举值，首先我们尝试打印：</span><br><span class="line">``` rust</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;dog is &#123;&#125;&quot;</span>, dog);</span><br></pre></td></tr></table></figure>
<p>很遗憾，此时编译器会提示我们并没有为<code>Pets</code>枚举类型实现<code>Display</code>的特性，所以我们无法直接打印。目前，我们可以通过<code>Debug</code>的方式来进行打印：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要在定义 enum Pets 的上面添加上 #[derive(Debug)]，否则会报没有实现 Debug</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;dog is &#123;:?&#125;&quot;</span>, dog);</span><br></pre></td></tr></table></figure>

<p>那我们再来看看如何在枚举上实现一些方法呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Pets</span> &#123;</span><br><span class="line">    <span class="comment">// methods</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">speak</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用<code>impl</code>为枚举类型<code>Pets</code>实现了一个方法，但我们应该怎样使用呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dog.<span class="title function_ invoke__">speak</span>()</span><br></pre></td></tr></table></figure>
<p>这样就可以啦!</p>
<p>同时我们还可以为枚举类型实现一些关联函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Pets</span> &#123;</span><br><span class="line">    <span class="comment">// 关联函数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">log</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;name is &#123;name&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Pets::<span class="title function_ invoke__">log</span>(<span class="string">&quot;alen&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，控制台会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name is alen</span><br></pre></td></tr></table></figure>

<h2 id="判别式（Discriminants）"><a href="#判别式（Discriminants）" class="headerlink" title="判别式（Discriminants）"></a>判别式（Discriminants）</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Fieldless</span> &#123;</span><br><span class="line">        <span class="comment">//只定义类型而不包含任何值，Fieldless enum</span></span><br><span class="line">        <span class="title function_ invoke__">Tuple</span>(),</span><br><span class="line">        Struce &#123;&#125;,</span><br><span class="line">        Unit,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    asserteq!(<span class="number">0</span>, Fieldless::<span class="title function_ invoke__">Tuple</span>() <span class="keyword">as</span> size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">UnitOnlyEnum</span> &#123;</span><br><span class="line">        Foo = <span class="number">0</span>,</span><br><span class="line">        Bar = <span class="number">1</span>,</span><br><span class="line">        Baz = <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">UnitOnlyEnum2</span> &#123;</span><br><span class="line">        Foo,</span><br><span class="line">        Bar,</span><br><span class="line">        Baz,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    asserteq!(<span class="number">0</span>, UnitOnlyEnum::Foo <span class="keyword">as</span> size);</span><br><span class="line">    asserteq!(<span class="number">0</span>, UnitOnlyEnum2::Foo  <span class="keyword">as</span> size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>· <code>match</code> vs <code>if let</code><br>· <code>match</code>必须能匹配所有条件</p>
<p>我们接着来看下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Pets</span> &#123;</span><br><span class="line">        Cat,</span><br><span class="line">        Dog,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cat</span> = Pets::Cat;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dog</span> = Pets::Dog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cat == dog &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们想要比较<code>cat</code>和<code>dog</code>两个枚举值是否相等，但是此时编译器会报错，因为我们并没有对<code>Pets</code>枚举类型实现<code>std::cmp::PartialEq</code>这个特性，因此我们无法直接使用<code>==</code>判断两个枚举值是否相等。那么，我们应该怎么办呢QAQ？</p>
<p>首先，我们可以手动实现这一特性，只需要在定义<code>Pets</code>前加上如下代码即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[dereive(PartialEq)]</span></span><br></pre></td></tr></table></figure>
<p>除了以上方法，我们还能通过什么路径实现对两个枚举值的比较呢？</p>
<p>这时候，就需要祭出Rust语言的大杀器<code>match</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> cat &#123;</span><br><span class="line">    Pets::Cat =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;is cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Pets::Dog =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;is dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，我们通过<code>match</code>来对枚举值<code>cat</code>进行模式匹配。但是<code>match</code>实际上非常强大，它可以对许多类型进行模式匹配：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">0</span> =&gt; &#123;&#125;</span><br><span class="line">    <span class="number">1</span> =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们想对变量<code>num</code>进行模式匹配，但此时编译器会报错，因为我们没有匹配<code>num</code>中的所有可能。<code>num</code>实际上是<code>i32</code>类型的，我们需要使用在<code>match</code>中遍历所有的可能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">0</span> =&gt; &#123;&#125;</span><br><span class="line">    <span class="number">1</span> =&gt; &#123;&#125;</span><br><span class="line">    _ =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，我们使用通配符<code>_</code>来代表<code>num</code>变量除了<code>0</code>和<code>1</code>的所有可能取值。</p>
<p>实际上，如果我们只在乎一种可能的取值，我们就可以使用<code>if let</code>语法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">num</span> = <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h2><p>在其它编程语言中，往往都有一个<code>null</code>关键字，该关键字用于表明一个变量当前的值为空（不是零值，例如整型的零值是<code>0</code>），也就是不存在值。当你对这些<code>null</code>进行操作时，例如调用一个方法，就会直接抛出<code>null</code>异常，导致程序的崩溃，因此我们在编程时需要格外的小心去处理这些<code>null</code>空值。</p>
<p>尽管如此，空值的表达依然非常有意义，因为空值表示当前时刻变量的值是缺失的。有鉴于此，Rust吸取了众多教训，决定抛弃<code>null</code>，而改为使用<code>Option</code>枚举变量来表述这种结果。</p>
<p><code>Option</code>枚举包含两个成员，一个成员表示含有值：<code>Some(T)</code>, 另一个表示没有值：<code>None</code>，定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>T</code>是泛型参数，<code>Some(T)</code>表示该枚举成员的数据类型是<code>T</code>，换句话说，<code>Some</code>可以包含任何类型的数据。</p>
<p><code>Option&lt;T&gt;</code>枚举是如此有用以至于它被包含在了<code>prelude</code>（<code>prelude</code>属于Rust标准库，Rust会将最常用的类型、函数等提前引入其中，省得我们再手动引入）之中，你不需要将其显式引入作用域。另外，它的成员<code>Some</code>和<code>None</code>也是如此，无需使用<code>Option::</code>前缀就可直接使用<code>Some</code>和<code>None</code>。</p>
<p>再来看如下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的代码实例中，我们可以发现在使用<code>Some</code>时，你无须显式的指定类型，但是对于<code>None</code>值，你需要告诉Rust<code>Option&lt;T&gt;</code>是什么类型的，因为编译器无法只通过<code>None</code>值来推断<code>Some</code>成员保存的值的类型。</p>
<p>我们可以通过<code>match</code>来提取<code>Some</code>中的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> some_number &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(val) =&gt; &#123;&#125;</span><br><span class="line">    <span class="literal">None</span> =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们再来看一些其他的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">map</span>: Hashmap&lt;&amp;<span class="type">str</span>, <span class="type">usize</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = map.<span class="title function_ invoke__">get</span>(<span class="string">&quot;a&quot;</span>);   <span class="comment">//option&lt;&amp;usize&gt;</span></span><br><span class="line">    <span class="keyword">match</span> a &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(val) =&gt; &#123;&#125;</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">last_one</span> = vec.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">last</span>();</span><br><span class="line">    <span class="keyword">match</span> last_one &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(val) =&gt; &#123;&#125;</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>·<code>Ok&lt;T&gt;</code><br>·<code>Err&lt;E&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span>: <span class="type">Result</span>&lt;<span class="type">usize</span>,()&gt; = <span class="title function_ invoke__">Ok</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; &#123;&#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用<code>Ok()</code>时需要显式的指定变量类型，理由同上。</p>
<p>给<code>main</code>函数加上返回值<code>Result</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), ()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span>: <span class="type">Result</span>&lt;<span class="type">usize</span>,()&gt; = <span class="title function_ invoke__">Ok</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; &#123;&#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="title function_ invoke__">Err</span>(())     <span class="comment">//Ok(())</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其他一些需要用到`<span class="type">Result</span>`类型的示例：</span><br><span class="line">``` rust</span><br><span class="line"><span class="keyword">use</span> std::num::ParseIntError</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span>: <span class="type">Result</span>&lt;<span class="type">usize</span>, ParseIntError&gt; = <span class="string">&quot;24&quot;</span>.<span class="title function_ invoke__">parse</span>();     <span class="comment">//.parse()是将字符串类型转为usize类型的方法，其返回值是Result类型</span></span><br><span class="line">    <span class="keyword">match</span> len &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; &#123;&#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;a.txt&quot;</span>);     <span class="comment">//File::open是打开文件，返回Result&lt;File, Error&gt;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tcp_connection</span> = TcpStream::<span class="title function_ invoke__">connect</span>(addr: <span class="string">&quot;127.0.0.1:3000&quot;</span>);    <span class="comment">//建立Tcp连接，返回Result&lt;TcpStream, Error&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Option-Result转换"><a href="#Option-Result转换" class="headerlink" title="Option&amp;Result转换"></a>Option&amp;Result转换</h2><p> · <code>ok_or*</code><br> ·<code>ok()</code> <code>err()</code><br> ·<code>map</code></p>
<h3 id="Option转Result"><a href="#Option转Result" class="headerlink" title="Option转Result"></a>Option转Result</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">opt</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = opt.<span class="title function_ invoke__">ok_or</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(res, <span class="title function_ invoke__">Ok</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = opt.<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(res, <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Result转Option"><a href="#Result转Option" class="headerlink" title="Result转Option"></a>Result转Option</h3><p><code>ok()</code>方法会将<code>Result&lt;T, E&gt;</code>转换为<code>Option&lt;T&gt;</code>，并且忽略错误信息。即，如果<code>Result</code>是<code>Ok(value)</code>，则返回<code>Some(value)</code>；如果是<code>Err(_)</code>，则返回<code>None</code>。</p>
<p>使用<code>ok()</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Ok</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">opt</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = res.<span class="title function_ invoke__">ok</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(res, <span class="title function_ invoke__">Ok</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = res.<span class="title function_ invoke__">ok</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(res, <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>err()</code>方法类似于<code>ok()</code>，但是它会将<code>Result&lt;T, E&gt;</code>转换为<code>Option&lt;E&gt;</code>，即提取错误信息。如果<code>Result</code>是<code>Err(error)</code>，返回<code>Some(error)</code>；如果是<code>Ok(_)</code>，则返回<code>None</code>。</p>
<p>使用<code>error()</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Ok</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">option_err</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = result.<span class="title function_ invoke__">err</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(option_err, <span class="literal">None</span>);  <span class="comment">// 没有错误，返回 None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result_err</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">option_err</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = result_err.<span class="title function_ invoke__">err</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(option_err, <span class="title function_ invoke__">Some</span>(<span class="string">&quot;error&quot;</span>));  <span class="comment">// 转换为 Some 错误信息</span></span><br></pre></td></tr></table></figure>

<p><strong>如何选择何时使用<code>ok()</code>还是<code>err()</code></strong>:<br>·当你只关心<code>Result</code>的成功值，并且想忽略错误信息时，使用<code>ok()</code>。<br>·当你只关心<code>Result</code>的错误值，想忽略成功值时，使用<code>err()</code>。</p>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">option</span> = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = option.<span class="title function_ invoke__">map</span>(|num| num+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = option.<span class="title function_ invoke__">and_then</span>(|val| <span class="title function_ invoke__">Some</span>((val+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = option.<span class="title function_ invoke__">or_else</span>(|| <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = option.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = option.<span class="title function_ invoke__">expetc</span>(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">    dbg!(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, ()&gt; = <span class="title function_ invoke__">Ok</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = result.<span class="title function_ invoke__">map</span>(|num| num+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = result.<span class="title function_ invoke__">and_then</span>(|val| <span class="title function_ invoke__">Ok</span>((val+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = result.<span class="title function_ invoke__">or_else</span>(|val| <span class="title function_ invoke__">Err</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enum内存分配与占用"><a href="#enum内存分配与占用" class="headerlink" title="enum内存分配与占用"></a>enum内存分配与占用</h2><p><code>enum</code>的内存占用是由两部分决定的：最大变体size和判别式（判别式用于区分枚举的不同变体）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        a, <span class="comment">//判别式=0</span></span><br><span class="line">        b, <span class="comment">//1</span></span><br><span class="line">        c, <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>enum A</code>中存储着三个单元类型的枚举成员，他们本身不占内存，但需要判别式进行区分，所以一共占用1个字节。</p>
<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><img src = "/images/10-1.png" alt = "" width = "1000">

<p>解：<br>对于第一个枚举:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">A</span>(<span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    B,</span><br><span class="line">    C &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>元组A中有两个<code>u8</code>类型，各占用1个字节，因此其大小一共为2个字节。<br>枚举成员B是空的单元变体，其中没有任何数据，它的大小是0个字节。但是它仍需占用1个字节的空间，因为它需要一个有效的大小表示。<br>同时，枚举成员C也是一个空的结构变体，同上所述，它也占用1个字节。</p>
<p>因此该枚举中的最大变体占用2个字节，再加上需要存储三个变体的判别式的1个字节，共三个字节。打印<code>MyEnum</code>的内存大小程序如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">A</span>(<span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    B,</span><br><span class="line">    C &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">size</span> = mem::size_of::&lt;MyEnum&gt;();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Size of MyEnum: &#123;&#125; bytes&quot;</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size of MyEnum: 3 bytes</span><br></pre></td></tr></table></figure>

<p>对于第二个枚举：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumA</span> &#123;</span><br><span class="line">    A = <span class="number">255</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一开始，我的看法是，判别式的值为255。因此，<code>EnumA</code>枚举需要一个内存的存储空间，但实际上，如果我们没有使用<code>#[repr(type)]</code>为枚举指定底层的存储类型时，程序打印出来的存储空间为0。</p>
<p>而如果我们使用<code>#[repr(type)]</code>来为枚举指定底层的存储类型时，程序打印出来的存储空间就和该类型占用的存储空间相同。例如我们使用了<code>#[repr(u8)]</code>时，便打印出1个字节；当我们使用<code>#[repr(i32)]</code>时，就会打印出4个字节</p>
<p>对于第三个枚举：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumB</span> &#123;</span><br><span class="line">    A = <span class="number">255</span>,</span><br><span class="line">    B,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，情况又有所不同。首先我们可以肯定Rust自动将枚举成员<code>B</code>的枚举值设置为了<code>256</code>，因此，存储判别式的值就需要2个字节。而我们使用程序打印出来的值也是2个字节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/10/rust-string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/10/rust-string/" class="post-title-link" itemprop="url">九、Rust-字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-10 20:54:49" itemprop="dateCreated datePublished" datetime="2024-10-10T20:54:49+08:00">2024-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-12 23:07:34" itemprop="dateModified" datetime="2024-10-12T23:07:34+08:00">2024-10-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h1><p>首先我们来看如下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> =  <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greet</span>(s: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该代码，可以发现编译器报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line"> --&gt; src/main.rs:3:11</span><br><span class="line">  |</span><br><span class="line">3 |     greet(my_name);</span><br><span class="line">  |           ^^^^^^^</span><br><span class="line">  |           |</span><br><span class="line">  |           expected struct `std::string::String`, found `&amp;str`</span><br><span class="line">  |           help: try using a conversion method: `my_name.to_string()`</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br></pre></td></tr></table></figure>
<p>可以发现<code>greet</code>函数需要一个<code>String</code>类型的字符串，但是我们却传入了一个<code>&amp;str</code>类型的字符串。那么这两种<strong>字符串类型</strong>到底有什么区别呢？？</p>
<h2 id="什么是字符串？"><a href="#什么是字符串？" class="headerlink" title="什么是字符串？"></a>什么是字符串？</h2><p>· 字符串是由字符组成的连续集合<br>· Rust中的字符是<code>Unicode</code>类型，每个字符占据定长的4个字节内存空间；但是字符串是<code>UTF-8</code>编码，也就是字符串中的字符所占的字节是变长字节（1-4）</p>
<p>我们可以看下面一个“hello 中国”的字符串例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   h    e    l    l    o   _       中            国</span><br><span class="line">[ 104  101  108  108  111  32  228,184,173  229,155,189]</span><br></pre></td></tr></table></figure>
<h2 id="str"><a href="#str" class="headerlink" title="str"></a>str</h2><p> <code>str</code>类型，是Rust在语言级别提供<code>的唯一一种**字符串**类型，其本质是一个字节数组</code>[u8]<code>;  </code>str<code>或者</code>[u8]&#96;类型的值存放在内存某处：可能是堆，可能是栈，还可能硬编码进可执行程序</p>
<h3 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h3><p>对于上面的<code>str</code>类型的变量，什么时候可能被硬编码进可执行程序内呢：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> =  <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面代码中这种直接使用双引号来赋值的方式，我们把它叫做字符串字面值，对于该字面值，Rust在编译时就将字面值编译进可执行文件中，其在可执行文件中的类型就是<code>str</code>。</p>
<p>那么对于<code>s</code>来说，它已经被编译进可执行文件中了，无法被修改，那么我们该如何访问它呢？</p>
<p>实际上，这里的<code>s</code>以不可变引用类型<code>&amp;str</code>出现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="type">str</span> = <span class="string">&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>但是，有的字符串是在程序运行的过程中动态生成的，并不能在编译时就确定，我们该怎么存储它们呢？</p>
<p>在Rsut标准库中，定义了一个新的字符串类型<code>String</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello 中国&quot;</span>)；</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>String</code>在Rust中是一个复合数据类型，定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    vec: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现，<code>String</code>类型被存储在可以动态增长的<code>Vec&lt;u8&gt;</code>上，它被分配在堆上。这意味着<code>String</code>是可改变的，并且拥有所有权。</p>
<p>除了用<code>String::from</code>来定义</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了<code>&amp;str</code>字符串切片和<code>String</code>类这两种最常用的字符串外，Rust的标准库还提供了其他类型的字符串，例如<code>OsString</code>、<code>OsStr</code>、<code>CsString</code>、<code>CsStr</code>等，它们可以被用于特定的场景。</p>
<h2 id="str-VS-String"><a href="#str-VS-String" class="headerlink" title="&amp;str VS String"></a>&amp;str VS String</h2><p><code>&amp;str</code>: 字符串切片，它大小固定，并且不能改变。<br><code>String</code>: 这是一个可增长、可改变、拥有所有权、UTF-8编码的字符串类型，它通常用于需要改变或者增长字符串的情况。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="字节数组-u8-Vec-str"><a href="#字节数组-u8-Vec-str" class="headerlink" title="字节数组[u8]|Vec -&gt; &amp;str"></a>字节数组[u8]|Vec<u8> -&gt; &amp;str</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = [<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">228</span>, <span class="number">184</span>, <span class="number">173</span>, <span class="number">229</span>, <span class="number">155</span>, <span class="number">189</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">str</span>::from-<span class="title function_ invoke__">uft8</span>(&amp;b).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);  <span class="comment">//  hello 中国</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Vec-String"><a href="#Vec-String" class="headerlink" title="Vec -&gt; String"></a>Vec<u8> -&gt; String</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="built_in">vec!</span>(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">228</span>, <span class="number">184</span>, <span class="number">173</span>, <span class="number">229</span>, <span class="number">155</span>, <span class="number">189</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::from-<span class="title function_ invoke__">uft8</span>(b).<span class="title function_ invoke__">unwrap</span>();  <span class="comment">//无需取引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);  <span class="comment">//  hello 中国</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="str-u8-Vec"><a href="#str-u8-Vec" class="headerlink" title="&amp;str -&gt; [u8]|Vec"></a>&amp;str -&gt; [u8]|Vec<u8></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello 中国&quot;</span>.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    dbg!(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String-str"><a href="#String-str" class="headerlink" title="String -&gt; &amp;str"></a>String -&gt; &amp;str</h3><p>将<code>String</code>类型转换为<code>&amp;str</code>类型十分便捷而且无损，直接取引用即可。同时，Rust实现了<code>deref</code>自动解引用，在必要时<code>&amp;String</code>可以自动转换为<code>&amp;Str</code>，因而在很多函数中，如果接受的参数是字符串的引用，通常会采用<code>&amp;str</code>作为入参，以获取更好的数据兼容性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s);          <span class="comment">//引用</span></span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s[..]);      <span class="comment">//切片</span></span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(s.<span class="title function_ invoke__">as_str</span>());  <span class="comment">//as_str()函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="str-String"><a href="#str-String" class="headerlink" title="&amp;str -&gt; String"></a>&amp;str -&gt; String</h3><p>从一个<code>&amp;str</code>获得一个<code>String</code>却是低效的，因为要重新<code>malloc</code>数据，我们可以通过以下两种方式将<code>&amp;str</code>转换为<code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello world!&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>

<h3 id="其他各种转换"><a href="#其他各种转换" class="headerlink" title="其他各种转换"></a>其他各种转换</h3><img src="images/9-1.png" alt="" width="750">

<h2 id="字符串索引与切片"><a href="#字符串索引与切片" class="headerlink" title="字符串索引与切片"></a>字符串索引与切片</h2><p>在对字符串进行索引与切片的时候，我们需要特别注意，<strong>索引的字节需要刚好落在字符的边界上</strong>，否则就会报错</p>
<h2 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h2><p>由于<code>String</code>类型是可变字符串，所以我们可以对它进行修改、添加、删除等常用方法：</p>
<h3 id="追加（push）"><a href="#追加（push）" class="headerlink" title="追加（push）"></a>追加（push）</h3><p>在字符串尾部可以使用<code>push()</code>方法追加字符<code>char</code>，也可以使用<code>push_str()</code>方法追加字符串字面量<code>str</code>。这两个方法都是<strong>在原有的字符串上追加，并不会返回新的字符串</strong>。由于字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由<code>mut</code>关键字修饰。</p>
<p>示例代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;rust&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;追加字符串 push_str() -&gt; &#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;追加字符 push() -&gt; &#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">追加字符串 push_str() -&gt; Hello rust</span><br><span class="line">追加字符 push() -&gt; Hello rust!</span><br></pre></td></tr></table></figure>

<h3 id="插入（insert）"><a href="#插入（insert）" class="headerlink" title="插入（insert）"></a>插入（insert）</h3><p>可以使用<code>insert()</code>方法插入单个字符<code>char</code>，也可以使用<code>insert_str()</code>方法插入字符串字面量，与<code>push()</code>方法不同，这俩方法需要传入两个参数，第一个参数是字符（串）插入位置的索引，第二个参数是要插入的字符（串），索引从<code>0</code>开始计数，如果越界则会发生错误。由于字符串插入操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由<code>mut</code>关键字修饰。</p>
<p>示例代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello rust!&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">insert</span>(<span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;插入字符 insert() -&gt; &#123;&#125;&quot;</span>, s);</span><br><span class="line">    s.<span class="title function_ invoke__">insert_str</span>(<span class="number">6</span>, <span class="string">&quot; I like&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;插入字符串 insert_str() -&gt; &#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">插入字符 insert() -&gt; Hello, rust!</span><br><span class="line">插入字符串 insert_str() -&gt; Hello, I like rust!</span><br></pre></td></tr></table></figure>

<h3 id="替换（replace）"><a href="#替换（replace）" class="headerlink" title="替换（replace）"></a>替换（replace）</h3><p>如果想要把字符串中的某个字符串替换成其它的字符串，那可以使用 replace() 方法。与替换有关的方法有三个。</p>
<ol>
<li><code>replace</code><br>该方法可适用于<code>String</code>和<code>&amp;str</code>类型。<code>replace()</code>方法接收两个参数，第一个参数是要被替换的字符串，第二个参数是新的字符串。该方法会替换所有匹配到的字符串。该方法是<strong>返回一个新的字符串，而不是操作原来的字符串</strong>，因而不需要原有的字符串用<code>mut</code>修饰。</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string_replace</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I like rust. Learning rust is my favorite!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_string_replace</span> = string_replace.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;RUST&quot;</span>);</span><br><span class="line">    dbg!(new_string_replace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_string_replace = &quot;I like RUST. Learning RUST is my favorite!&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>replacen</code><br>该方法可适用于<code>String</code>和<code>&amp;str</code>类型。<code>replacen()</code>方法接收三个参数，前两个参数与<code>replace()</code>方法一样，第三个参数则表示替换的个数。该方法是<strong>返回一个新的字符串，而不是操作原来的字符串</strong>。</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string_replace</span> = <span class="string">&quot;I like rust. Learning rust is my favorite!&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_string_replacen</span> = string_replace.<span class="title function_ invoke__">replacen</span>(<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;RUST&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    dbg!(new_string_replacen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_string_replacen = &quot;I like RUST. Learning rust is my favorite!&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>replace_range</code><br>该方法仅适用于<code>String</code>类型。<code>replace_range</code>接收两个参数，第一个参数是要替换字符串的范围（Range），第二个参数是新的字符串。该方法是<strong>直接操作原来的字符串，不会返回新的字符串</strong>。该方法需要使用<code>mut</code>关键字修饰。</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">string_replace_range</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I like rust!&quot;</span>);</span><br><span class="line">    string_replace_range.<span class="title function_ invoke__">replace_range</span>(<span class="number">7</span>..<span class="number">8</span>, <span class="string">&quot;R&quot;</span>);</span><br><span class="line">    dbg!(string_replace_range);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string_replace_range = &quot;I like Rust!&quot;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果<code>range</code>参数小于新的字符串长度，替换后整个字符串的长度就会增加，反之减少。</p>
<p>举例如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">string_replace_range</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I like rust!&quot;</span>);</span><br><span class="line">    string_replace_range.<span class="title function_ invoke__">replace_range</span>(<span class="number">7</span>..<span class="number">8</span>, <span class="string">&quot;RUST&quot;</span>);</span><br><span class="line">    dbg!(string_replace_range);     <span class="comment">// I like RUSTust!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时还需要注意我们的<code>range</code>必须落在字符的边界上。</p>
<h3 id="删除（delete）"><a href="#删除（delete）" class="headerlink" title="删除（delete）"></a>删除（delete）</h3><p>与字符串删除相关的方法有4个，他们分别是<code>pop()</code>，<code>remove()</code>，<code>truncate()</code>，<code>clear()</code>。这四个方法仅适用于<code>String</code>类型。</p>
<ol>
<li><p><code>pop</code> —— 删除并返回字符串的最后一个字符<br>该方法是<strong>直接操作原来的字符串</strong>。但是存在返回值，其返回值是一个<code>Option</code>类型，<strong>有值就返回字符</strong>；如果字符串为空，则返回<code>None</code>。示例代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">string_pop</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust pop 中文!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = string_pop.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = string_pop.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">    dbg!(p1);</span><br><span class="line">    dbg!(p2);</span><br><span class="line">    dbg!(string_pop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p1 = Some(</span><br><span class="line">   &#x27;!&#x27;,</span><br><span class="line">)</span><br><span class="line">p2 = Some(</span><br><span class="line">   &#x27;文&#x27;,</span><br><span class="line">)</span><br><span class="line">string_pop = &quot;rust pop 中&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>remove</code> —— 删除并返回字符串中指定位置的字符</p>
</li>
</ol>
<p>该方法是<strong>直接操作原来的字符串</strong>。但是存在返回值，其返回值是删除位置的字符串，只接收一个参数，表示该字符起始索引位置<code>remove()</code>方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。</p>
<p>示例代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">string_remove</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;测试remove方法&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;string_remove 占 &#123;&#125; 个字节&quot;</span>,</span><br><span class="line">        std::mem::<span class="title function_ invoke__">size_of_val</span>(string_remove.<span class="title function_ invoke__">as_str</span>())</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 删除第一个汉字</span></span><br><span class="line">    string_remove.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 下面代码会发生错误</span></span><br><span class="line">    <span class="comment">// string_remove.remove(1);</span></span><br><span class="line">    <span class="comment">// 直接删除第二个汉字</span></span><br><span class="line">    <span class="comment">// string_remove.remove(3);</span></span><br><span class="line">    dbg!(string_remove);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string_remove 占 18 个字节</span><br><span class="line">string_remove = &quot;试remove方法&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>truncate</code> —— 删除字符串中从指定位置开始到结尾的全部字符</li>
</ol>
<p>该方法是<strong>直接操作原来的字符串</strong>。无返回值。该方法<code>truncate()</code>方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。</p>
<p>示例代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">string_truncate</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;测试truncate&quot;</span>);</span><br><span class="line">    string_truncate.<span class="title function_ invoke__">truncate</span>(<span class="number">3</span>);</span><br><span class="line">    dbg!(string_truncate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string_truncate = &quot;测&quot;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>clear</code> —— 清空字符串<br>该方法是直接操作原来的字符串。调用后，删除字符串中的所有字符，相当于<code>truncate()</code>方法参数为<code>0</code>的时候。<br>示例代码如下：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">string_clear</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;string clear&quot;</span>);</span><br><span class="line">    string_clear.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">    dbg!(string_clear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码运行结果如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string_clear = &quot;&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>TIPS:剩下的连接和字符串转义实在懒得记了，可以看链接：</strong> <a target="_blank" rel="noopener" href="https://practice-zh.course.rs/basic-types/statements-expressions.html" title="查看Rust语言圣经">Rust语言圣经</a></p>
<h3 id="连接（concatenate）"><a href="#连接（concatenate）" class="headerlink" title="连接（concatenate）"></a>连接（concatenate）</h3><ol>
<li><p>使用<code>+</code>或者<code>+=</code>连接字符串</p>
</li>
<li><p>使用<code>format!</code>连接字符串</p>
</li>
</ol>
<h2 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a>字符串转义</h2><p>我们可以通过转义的方式<code>\</code>输出<code>ASCII</code>和<code>Unicode</code>字符</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>

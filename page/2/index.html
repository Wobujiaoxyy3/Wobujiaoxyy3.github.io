<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Wobujiaoxyy3">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Wobujiaoxyy3">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Wobujiaoxyy3</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wobujiaoxyy3</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/31/rust-macros/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/31/rust-macros/" class="post-title-link" itemprop="url">二十一、Rust进阶-宏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-31 18:36:49" itemprop="dateCreated datePublished" datetime="2024-10-31T18:36:49+08:00">2024-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:44:41" itemprop="dateModified" datetime="2024-11-14T07:44:41+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="宏macros">宏Macros</h1>
<p>在Rust中，宏（Macros）是一种强大的工具，用于生成代码。它们在编译时展开，可以执行复杂的文本操作。</p>
<p>实际上我们早就见到过宏，比如<code>println!</code>、<code>vec!</code>等，这些都是Rust内置的宏，宏在Rust中无处不在：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_common_macros</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>&#123;<span class="string">&quot;Hello, World!&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>[<span class="string">&quot;Hello, World!&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，我们可以发现虽然我们平时使用<code>println!</code>时，是<code>println!("Hello, World!")</code>，但是<code>println!</code>也可以使用<code>&#123;&#125;</code>、<code>[]</code>、<code>&#123;&#125;</code>等作为参数。虽然三种使用方式都正确，但是Rust内置的宏有自己默认的使用方式，如<code>assert_eq!()</code>、<code>panic!()</code>等。</p>
<p><strong>宏分为两类：声明宏（Declarative
Macros）和三种过程宏（Procedural Macros）</strong>： -
<code>#[derive]</code>，在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如
Debug 特征 - 类属性宏(Attribute-like macro)，用于为目标添加自定义的属性
- 类函数宏(Function-like macro)，看上去就像是函数调用</p>
<h2 id="宏和函数的区别">宏和函数的区别</h2>
<p>宏和函数的区别并不少，而且对于宏擅长的领域，函数其实是有些无能为力的。</p>
<h3 id="元编程">元编程</h3>
<p>从根本上说，宏是通过一种代码来生成另一种代码，它和元编程有一定的共同点。</p>
<p>例如<code>derive</code>宏，它可以在编译时自动为结构体派生出相应特征的实现代码。例如<code>#[derive(Debug)]</code>，还有熟悉的<code>println!</code>和<code>vec!</code>，所有的这些宏都会展开成相应的代码，且很可能是长得多的代码。</p>
<p>总之，元编程可以帮我们减少所需编写的代码，也可以一定程度上减少维护的成本，虽然函数复用也有类似的作用，但是宏依然拥有自己独特的优势。</p>
<h3 id="可变参数">可变参数</h3>
<p>Rust
的函数签名是固定的：定义了两个参数，就必须传入两个参数，多一个少一个都不行。</p>
<p>而宏就可以拥有可变数量的参数，例如可以调用一个参数的<code>println!("hello")</code>，也可以调用两个参数的<code>println!("hello &#123;&#125;", name)</code>。</p>
<h3 id="宏展开">宏展开</h3>
<p>由于宏会被展开成其它代码，且这个展开过程是发生在编译器对代码进行解释之前。因此，宏可以为指定的类型实现某个特征：先将宏展开成实现特征的代码后，再被编译。</p>
<p>而函数就做不到这一点，因为它直到运行时才能被调用，而特征需要在编译期被实现。</p>
<h3 id="宏的缺点">宏的缺点</h3>
<p>相对函数来说，由于宏是基于代码再展开成代码，因此实现相比函数来说会更加复杂，再加上宏的语法更为复杂，最终导致定义宏的代码相当地难读，也难以理解和维护。</p>
<p><strong>就是十分难写，十分难懂，十分难维护！！</strong></p>
<h2 id="声明宏">声明宏</h2>
<p>在Rust中最广泛使用的宏就是声明宏，声明宏使用<code>macro_rules!</code>来定义，<code>macro_rules!</code>看起来像是一个函数，但是它和函数没有任何关系，它允许你通过模式匹配来生成代码：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明宏</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> say_hello &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    say_hello!();</span><br><span class="line">    say_hello![];</span><br><span class="line">    say_hello!&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其实上面的例子是一个十分十分简单的声明宏，它没有进行任何的匹配，只是打印了一个固定的语句。</p>
<h3 id="实现简化版的vec">实现简化版的vec!</h3>
<p>在之前动态数组的环节中，我们学习了使用<code>vec!</code>宏来创建动态数组:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
最重要的是，通过<code>vec!</code>创建的动态数组支持任何元素类型，也并没有限制数组的长度，如果使用函数，我们是无法做到这一点的。</p>
<p>现在让我们尝试用<code>macro_rules!</code>来自己实现一个简化版的<code>vec!</code>宏:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ($($e:expr),*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.<span class="title function_ invoke__">push</span>($e);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
即使是简化版本的<code>vec!</code>宏，它还是那么难理解，不过没关系，我们慢慢来。</p>
<p>首先<code>#[macro_export]</code>是用来导出宏的，这样宏就可以在当前crate之外使用。</p>
<p>紧接着我们使用<code>macro_rules!</code>是声明宏的语法，<code>vec!</code>是宏的名称，<code>($($e:expr),*)</code>是模式匹配，跟模式相匹配的代码就在<code>=&gt;</code>后面。</p>
<h3 id="模式解析">模式解析</h3>
<p>现在，让我们来简单地解析一下<code>($($e:expr),*)</code>这个模式：</p>
<p>首先，我们使用圆括号<code>()</code>来将整个宏模式包裹其中，随后是<code>$()</code>，在此括号中跟模式相匹配的值(传入的Rust源代码)会被捕获，然后用于代码替换。在这里，模式
<code>$x:expr</code>
会匹配<strong>任何Rust表达式</strong>并给予该模式一个名称：<code>$x</code>。</p>
<p><code>$()</code> 之后的逗号说明在 <code>$()</code>
所匹配的代码的后面会有一个可选的逗号分隔符，紧随逗号之后的
<code>*</code> 说明 <code>*</code>
之前的模式会被匹配零次或任意多次(类似正则表达式)。</p>
<p>当我们使用 vec![1, 2, 3] 来调用该宏时，$x 模式将被匹配三次，分别是
1、2、3。为了帮助大家巩固，我们再来一起过一下：</p>
<ul>
<li><code>$()</code>中包含的是模式<code>$x:expr</code>，该模式中的<code>expr</code>表示会匹配任何Rust表达式，并给予该模式一个名称<code>$x</code></li>
<li>因此<code>$x</code>模式可以跟整数<code>1</code>进行匹配，也可以跟字符串<code>"hello"</code>进行匹配:<code>vec!["hello", "world"]</code></li>
<li><code>$()</code>之后的逗号，意味着<code>1</code>和<code>2</code>之间可以使用逗号进行分割，也意味着<code>3</code>既可以没有逗号，也可以有逗号：<code>vec![1, 2, 3,]</code></li>
<li><code>*</code>说明之前的模式可以出现零次也可以任意次，这里出现了三次.</li>
</ul>
<p>接下来，让我们再看看与模式相关联，在<code>=&gt;</code>之后所写的代码：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    $(</span><br><span class="line">        temp_vec.<span class="title function_ invoke__">push</span>($e);</span><br><span class="line">    )*</span><br><span class="line">    temp_vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里就比较好理解了，<code>$()</code>中的<code>temp_vec.push()</code>将根据模式匹配的次数生成对应的代码，当调用<code>vec![1, 2, 3]</code>时，下面这段生成的代码将替代传入的源代码，也就是替代<code>vec![1, 2, 3]</code>:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    temp_vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
至此，我们已经能够大致理解这个简化版的<code>vec!</code>宏了。它可以接受任意数量和任意类型的参数，并创建一个包含这些参数的向量。</p>
<h2 id="过程宏">过程宏</h2>
<p>第二种常用的宏就是过程宏（Procedural
Macros），从形式上来看，过程宏跟函数较为相像，但过程宏是使用源代码作为输入参数，基于代码进行一系列操作后，再输出一段全新的代码。<strong>注意，过程宏中的
derive
宏输出的代码并不会替换之前的代码，这一点与声明宏有很大的不同！</strong></p>
<p>至于前文提到的过程宏的三种类型(自定义
derive、属性宏、函数宏)，它们的工作方式都是类似的。</p>
<p>当创建过程宏时，它的定义必须要放入一个独立的包中，且包的类型也是特殊的，必须使用<code>#[proc_macro]</code>属性来标注。过程宏需要放入独立包的原因比较复杂，在于它必须先被编译后才能使用，如果过程宏和使用它的代码在一个包，就必须先单独对过程宏的代码进行编译，然后再对我们的代码进行编译，但悲剧的是
Rust 的编译单元是包，因此你无法做到这一点。</p>
<h3 id="派生宏">派生宏</h3>
<h4 id="派生宏的实现">派生宏的实现</h4>
<p>值得注意的是，在大多数情况下，我们在编写代码的过程中不需要自己定义或者实现宏，我们只需要用好Rust内置的宏即可。</p>
<p>这里，我们简单看一下派生宏的实现： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_macro_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span> = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">HelloMacro</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">hello_macro</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Hello, Macro! My name is &#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
同时，我们还需要在<code>Cargo.toml</code>中添加<code>quote</code>和<code>syn</code>的依赖，以及<code>proc-macro</code>的工具：
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">syn</span> = <span class="string">&quot;2.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure> 实现派生宏真的十分复杂，请在有需要的时候自行查阅文档<a
target="_blank" rel="noopener" href="https://course.rs/advance/macro.html">Rust语言圣经</a></p>
<p>那么，Rust当中有那些已经为我们实现的内置宏呢？常用的有： -
<code>#[derive(Debug)]</code><br />
- <code>#[derive(Clone)]</code> - <code>#[derive(Copy)]</code> -
<code>#[derive(Default)]</code> - <code>#[derive(PartialEq)]</code> -
<code>#[derive(Eq)]</code> - <code>#[derive(Hash)]</code> -
<code>#[derive(PartialOrd)]</code> - <code>#[derive(Ord)]</code></p>
<h3 id="类属性宏">类属性宏</h3>
<p>类属性过程宏跟<code>derive</code>宏类似，但是前者允许我们定义自己的属性。除此之外，<code>derive</code>只能用于结构体和枚举，而类属性宏可以用于其它类型项，例如函数。</p>
<p>假设我们在开发一个web框架，当用户通过<code>HTTP GET</code>请求访问<code>/</code>根路径时，使用<code>index</code>函数为其提供服务:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[route(GET, <span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">index</span>() &#123;</span><br></pre></td></tr></table></figure>
如上所示，代码功能非常清晰、简洁，这里的<code>#[route]</code>属性就是一个过程宏，它的定义函数大概如下：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">route</span>(attr: TokenStream, item: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br></pre></td></tr></table></figure>
与<code>derive</code>宏不同，类属性宏的定义函数有两个参数：</p>
<ul>
<li>第一个参数时用于说明属性包含的内容：<code>Get</code>,
<code>/</code>部分</li>
<li>第二个是属性所标注的类型项，在这里是<code>fn index() &#123;...&#125;</code>，注意，函数体也被包含其中</li>
</ul>
<p>除此之外，类属性宏跟<code>derive</code>宏的工作方式并无区别：创建一个包，类型是<code>proc-macro</code>，接着实现一个函数用于生成想要的代码。</p>
<h3 id="类函数宏">类函数宏</h3>
<p>类函数宏可以让我们定义像函数那样调用的宏，从这个角度来看，它跟声明宏<code>macro_rules</code>较为类似。</p>
<p>区别在于，<code>macro_rules</code>的定义形式与<code>match</code>匹配非常相像，而类函数宏的定义形式则类似于之前讲过的两种过程宏：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sql</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br></pre></td></tr></table></figure> 而使用形式则类似于函数调用： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sql</span> = sql!(SELECT * FROM users);</span><br></pre></td></tr></table></figure></p>
<p>Rust内置的类函数宏有： - <code>assert_eq!</code> -
<code>assert!</code> - <code>println!</code> - <code>vec!</code> -
<code>include_str!</code> // 包含字符串 - <code>env!</code> //
获取环境变量 - <code>concat!</code> // 连接字符串 - <code>format!</code>
// 格式化字符串 - <code>todo!</code> // 生成未实现代码</p>
<h2 id="总结">总结</h2>
<ul>
<li><strong>创建声明宏</strong>：使用<code>macro_rules!</code>定义宏，通过模式匹配生成代码</li>
<li><strong>创建过程宏</strong>：使用过程宏函数<code>#[proc_macro]</code>、派生宏<code>#[proc_macro_attribute]</code>和属性宏<code>#[proc_macro_derive]</code>生成代码</li>
</ul>
<p>宏的使用场景： 1.
<strong>减少重复代码</strong>：宏可以减少重复代码，提高代码的复用性 2.
<strong>编译期计算</strong>：宏可以在编译期进行复杂的计算，减少运行时的开销
3.
<strong>DSL（领域特定语言）</strong>：宏可以用于创建领域特定语言，提高代码的表达力和可读性</p>
<h2 id="课后作业">课后作业</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求：</span></span><br><span class="line"><span class="comment">// 通过`macro_rules!`宏实现对应的marco，并通过测试case</span></span><br><span class="line"><span class="comment">// assert_eq!(repeat!(&quot;x&quot;, 3), &quot;xxx&quot;);</span></span><br><span class="line"><span class="comment">// assert_eq!(sum!(1, 2, 3, 4, 5), 15);</span></span><br><span class="line"><span class="comment">// assert_eq!(max_value!(1, 8, 9), 9);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> repeat &#123;</span><br><span class="line">    ($item:expr, $n:expr) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..$n &#123;</span><br><span class="line">                result.<span class="title function_ invoke__">push_str</span>(&amp;$item);</span><br><span class="line">            &#125;</span><br><span class="line">            result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> sum &#123;</span><br><span class="line">    ($($x:expr),*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">            $(</span><br><span class="line">                sum += $x;</span><br><span class="line">            )*</span><br><span class="line">            sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> max_value &#123;</span><br><span class="line">    ($first:expr, $($rest:expr),*) =&gt; &#123; <span class="comment">//需要分别处理第一个值和剩余值，第一个值用于初始化sum</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max</span> = $first; </span><br><span class="line">            $(</span><br><span class="line">                <span class="keyword">if</span> $rest &gt; max &#123;</span><br><span class="line">                    max = $rest;</span><br><span class="line">                &#125;</span><br><span class="line">            )*</span><br><span class="line">            max</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(repeat!(<span class="string">&quot;x&quot;</span>, <span class="number">3</span>), <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum!(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(max_value!(<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/28/rust-lifetime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/28/rust-lifetime/" class="post-title-link" itemprop="url">十九、Rust进阶-生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-28 20:09:43" itemprop="dateCreated datePublished" datetime="2024-10-28T20:09:43+08:00">2024-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:40:46" itemprop="dateModified" datetime="2024-11-14T07:40:46+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="生命周期">生命周期</h1>
<p>在这个章节中，我们将介绍Rust中十分困难的概念：<strong>生命周期</strong>。生命周期，简而言之就是引用的有效作用域，在大部分情况下，我们无需手动的声明生命周期，因为编译器可以自动进行推导；但在一些特殊情况下，在多种类型存在时，如果编译器无法推导出某个引用的生命周期，就需要我们手动标明生命周期。</p>
<h2 id="悬垂指针与生命周期">悬垂指针与生命周期</h2>
<p>让我们来看下面一个例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">        r = &amp;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这段代码有几点值得注意:
·<code>let r</code>;
的声明方式貌似存在使用<code>null</code>的风险，实际上，当我们不初始化它就使用时，编译器会给予报错
·<code>r</code>引用了内部花括号中的<code>x</code>变量，但是<code>x</code>会在内部花括号<code>&#125;</code>处被释放，因此回到外部花括号后，<code>r</code>会引用一个无效的<code>x</code>
·此处<code>r</code>就是一个悬垂指针，它引用了提前被释放的变量<code>x</code>，可以预料到，这段代码会报错：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `x` does not live long enough // `x` 活得不够久</span><br><span class="line">  --&gt; src/main.rs:7:17</span><br><span class="line">   |</span><br><span class="line">7  |             r = &amp;x;</span><br><span class="line">   |                 ^^ borrowed value does not live long enough // 被借用的 `x` 活得不够久</span><br><span class="line">8  |         &#125;</span><br><span class="line">   |         - `x` dropped here while still borrowed // `x` 在这里被丢弃，但是它依然还在被借用</span><br><span class="line">9  |</span><br><span class="line">10 |         println!(&quot;r: &#123;&#125;&quot;, r);</span><br><span class="line">   |                           - borrow later used here // 对 `x` 的借用在此处被使用</span><br></pre></td></tr></table></figure>
在这里<code>r</code>拥有更大的作用域，或者说活得更久。如果<code>Rust</code>不阻止该悬垂引用的发生，那么当<code>x</code>被释放后，<code>r</code>所引用的值就不再是合法的，会导致我们程序发生异常行为，且该异常行为有时候会很难被发现。</p>
<h2 id="借用检查">借用检查</h2>
<p>为了保证Rust的所有权和借用的正确性，Rust使用了一个借用检查器(Borrow
checker)，来检查我们程序的借用正确性： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;                <span class="comment">// ---------+-- &#x27;a</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    &#123;                     <span class="comment">//          |</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;        <span class="comment">// -+-- &#x27;b  |</span></span><br><span class="line">        r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">    &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//          |</span></span><br><span class="line">&#125;                         <span class="comment">// ---------+</span></span><br></pre></td></tr></table></figure>
这段代码和之前的一模一样，唯一的区别在于增加了对变量生命周期的注释。这里，<code>r</code>变量被赋予了生命周期
<code>'a</code>，<code>x</code>被赋予了生命周期<code>'b</code>，从图示上可以明显看出生命周期<code>'b</code>比<code>'a</code>小很多。</p>
<p>在编译期，<code>Rust</code>会比较两个变量的生命周期，结果发现<code>r</code>明明拥有生命周期<code>'a</code>，但是却引用了一个小得多的生命周期<code>'b</code>，在这种情况下，编译器会认为我们的程序存在风险，因此拒绝运行。</p>
<p>如果想要编译通过，也很简单，只要<code>'b</code>比<code>'a</code>大就好。总之，<code>x</code>变量只要比<code>r</code>活得久，那么<code>r</code>就能随意引用<code>x</code>且不会存在危险：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;            <span class="comment">// ----------+-- &#x27;b</span></span><br><span class="line">                          <span class="comment">//           |</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;x;           <span class="comment">// --+-- &#x27;a  |</span></span><br><span class="line">                          <span class="comment">//   |       |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//   |       |</span></span><br><span class="line">                          <span class="comment">// --+       |</span></span><br><span class="line">&#125;                         <span class="comment">// ----------+</span></span><br></pre></td></tr></table></figure>
根据之前的结论，我们重新实现了代码，现在<code>x</code>的生命周期<code>'b</code>大于<code>r</code>的生命周期<code>'a</code>，因此<code>r</code>对<code>x</code>的引用是安全的。</p>
<h2 id="函数中的生命周期">函数中的生命周期</h2>
<p>有代码示例如下： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的示例中，<code>longest</code>函数接受两个字符串切片参数，并返回其中一个更长的字符串切片，看起来是一个十分正常且合理的实现方式，但实际上，编译器会发生报错：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:9:33</span><br><span class="line">  |</span><br><span class="line">9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">  |               ----     ----     ^ expected named lifetime parameter // 参数需要一个生命周期</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is</span><br><span class="line">  borrowed from `x` or `y`</span><br><span class="line">  = 帮助： 该函数的返回值是一个引用类型，但是函数签名无法说明，该引用是借用自 `x` 还是 `y`</span><br><span class="line">help: consider introducing a named lifetime parameter // 考虑引入一个生命周期</span><br><span class="line">  |</span><br><span class="line">9 | fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">  |           ^^^^    ^^^^^^^     ^^^^^^^     ^^^</span><br></pre></td></tr></table></figure>
在如上的报错中，我们可以发现，主要是编译器无法知道该函数的返回值到底引用<code>x</code>还是<code>y</code>，因为编译器需要知道这些，来确保函数调用后的引用生命周期分析。</p>
<p>但实际上，我们自己也不知道调用该函数时会返回<code>x</code>还是<code>y</code>。自然，编译器也无法推导出返回的引用值的生命周期。因此，正如开头所说，当编译器无法自动推导生命周期时，就需要我们去进行手动标注。</p>
<h2 id="生命周期标注语法">生命周期标注语法</h2>
<p>在Rust中，生命周期主要通过生命周期注解来创建和使用。生命周期注解是一种显式声明引用有效时间的方式，通常用<code>'a</code>、<code>'b</code>这样的符号表示：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 一个引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 具有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 具有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>
一个生命周期标注，它自身并不具有什么意义，<strong>它并不会改变任何引用的实际作用域</strong>，因为生命周期的作用就是告诉编译器多个引用之间的关系。例如，有一个函数，它的第一个参数<code>first</code>是一个指向<code>i32</code>类型的引用，具有生命周期<code>'a</code>，该函数还有另一个参数<code>second</code>，它也是指向<code>i32</code>类型的引用，并且同样具有生命周期<code>'a</code>。此处生命周期标注仅仅说明，这两个参数<code>first</code>和<code>second</code>至少活得和<code>'a</code>一样久，至于到底活多久或者哪个活得更久，抱歉我们都无法得知：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">useless</span>&lt;<span class="symbol">&#x27;a</span>&gt;(first: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, second: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数签名中的生命周期标注">函数签名中的生命周期标注</h3>
<p>让我们回到之前<code>longest</code>函数的例子中，下面展示了正确的声明周期注解：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 要注意的点如下： ·
和泛型一样，使用生命周期参数，需要先声明<code>&lt;'a&gt;</code>
(随便举一个泛型的例子：<code>fn longest&lt;T&gt;(x: T, y: T) -&gt; T &#123;&#125;</code>)
·
<code>x</code>、<code>y</code>和返回值<strong>至少</strong>活得和<code>'a</code>一样久（因为返回值要么是<code>x</code>，要么是<code>y</code>）</p>
<p>让我们再具体分析一下上面的例子，我们先声明了生命周期参数<code>&lt;'a&gt;</code>，随后为函数的两个传入参数<code>x</code>和<code>y</code>以及函数的返回值都标注了生命周期参数<code>'a</code>。实际上，这意味着<strong>返回值的生命周期与参数生命周期中的较小值一致</strong>：虽然两个参数的生命周期都是标注了<code>'a</code>，但是实际上这两个参数的真实生命周期可能是不一样的（生命周期<code>'a</code>不代表生命周期等于<code>'a</code>，而是大于等于<code>'a</code>）。</p>
<p>当把具体的引用传给<code>longest</code>时，那生命周期<code>'a</code>的大小就是<code>x</code>和<code>y</code>的作用域的重合部分，换句话说，<code>'a</code>的大小将等于<code>x</code>和<code>y</code>中较小的那个。由于返回值的生命周期也被标记为<code>'a</code>，因此返回值的生命周期也是<code>x</code>和<code>y</code>中作用域较小的那个。</p>
<p>让我们再来看一个例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上例中，<code>string1</code>的作用域直到<code>main</code>函数的结束，而<code>string2</code>的作用域到内部花括号的结束<code>&#125;</code>，那么根据之前的理论，<code>'a</code>是两者中作用域较小的那个，也就是<code>'a</code>的生命周期等于<code>string2</code>的生命周期，同理，由于函数返回的生命周期也是<code>'a</code>，可以得出函数返回的生命周期也等于<code>string2</code>的生命周期。</p>
<p>现在来验证下上面的结论：result
的生命周期等于参数中生命周期最小的，因此要等于 string2
的生命周期，也就是说，result 要活得和 string2
一样久，观察下代码的实现，可以发现这个结论是正确的！ <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此时，按照我们上面的结论，自然而然地编译器报错了： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `string2` does not live long enough</span><br><span class="line"> --&gt; src/main.rs:6:44</span><br><span class="line">  |</span><br><span class="line">6 |         result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">  |                                            ^^^^^^^ borrowed value does not live long enough</span><br><span class="line">7 |     &#125;</span><br><span class="line">  |     - `string2` dropped here while still borrowed</span><br><span class="line">8 |     println!(&quot;The longest string is &#123;&#125;&quot;, result);</span><br><span class="line">  |                                          ------ borrow later used here</span><br></pre></td></tr></table></figure>
该代码成功打印出<code>result</code>的前提是它的生命周期能够达到<code>println!()</code>这一行。但<code>result</code>的生命周期为<code>'a</code>，是<code>string1</code>和<code>string2</code>两个传入参数的生命周期的最小值。这说明，只有<code>string2</code>的生命周期能够达到<code>println!()</code>，<code>result</code>才能成功打印，但很可惜的是<code>string2</code>只能活到内部语句块的花括号<code>&#125;</code>处，因而编译出错。</p>
<h2 id="结构体和枚举中的生命周期">结构体和枚举中的生命周期</h2>
<p>不仅仅函数具有生命周期，在结构体和枚举enum中都有这个概念。在之前我们对结构体的使用中都尽量规避了没有所有权的引用类型，因而不需要加上生命周期标注。但如果我们想要在结构体或者是枚举中使用引用，那我们就需要为其中的每一个引用标注上生命周期：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>ImportantExcerpt</code>结构体中有一个引用类型的字段<code>part</code>，因此需要为它标注上生命周期。结构体的生命周期标注语法跟泛型参数语法很像，需要对生命周期参数进行声明<code>&lt;'a&gt;</code>。该生命周期标注说明，结构体
<code>ImportantExcerpt</code>所引用的字符串<code>str</code>生命周期需要大于等于该结构体的生命周期。</p>
<p>从<code>main</code>函数实现来看，<code>ImportantExcerpt</code>的生命周期从第<code>4</code>行开始，到<code>main</code>函数末尾结束，而该结构体引用的字符串从第一行开始，也是到<code>main</code>函数末尾结束，可以得出结论结构体引用的字符串生命周期大于等于结构体，这符合了编译器对生命周期的要求，因此编译通过。</p>
<p>与之相反，下面的代码就无法通过编译： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">        i = ImportantExcerpt &#123;</span><br><span class="line">            part: first_sentence,</span><br><span class="line">        &#125;;  <span class="comment">// first_sentence生命周期结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,i);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
我们观察代码可以发现，该结构体中的引用字段的生命周期在内部花括号处生命周期就结束了。但是后续该结构体<code>i</code>又被使用了，因此会导致无效的引用，编译报错。</p>
<p>如果我们想要在结构体或<code>enum</code>中使用多个具有不同生命周期的引用，就需要为每一个引用进行生命周期标注：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">StringOption</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>((&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>)),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法中的生命周期">方法中的生命周期</h2>
<p>既然在枚举和结构体中可以使用生命周期标注的引用，那么，我们自然也西药为具有生命周期的结构体实现方法。在实现时，我们使用的语法也与泛型参数的语法相似：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
首先，我们需要在<code>impl</code>后加上<code>&lt;'a&gt;</code>来声明该方法的实现需要用到生命周期。其次，<code>impl</code>中必须使用结构体的完整名称，包括<code>&lt;'a&gt;</code>，因为生命周期标注也是结构体类型的一部分！</p>
<p>如果有多种参数，示例如下： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">StringOption</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>((&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>)),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; StringOption&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="生命周期消除lifetime-elision">生命周期消除（Lifetime
Elision）</h2>
<p>对于编译器来说，每一个引用类型都存在一个与之对应的生命周期，但我们在实际的使用过程中，很多时候我们并不需要标注生命周期，例如：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
该该函数的参数和返回值都是引用类型，尽管我们没有显式的为其标注生命周期，编译依然可以通过。</p>
<p>这是因为，Rust为我们提供了<strong>三条生命周期的消除规则</strong>：</p>
<p><strong>编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期</strong>。其中第一条规则应用在输入生命周期上，第二、三条应用在输出生命周期上。若编译器发现三条规则都不适用时，就会报错，提示你需要手动标注生命周期。</p>
<ol type="1">
<li><p>每个引用参数都有自己的生命周期参数。</p></li>
<li><p>如果只有一个输入引用参数，那么它的生命周期会被赋予所有输出引用。</p></li>
<li><p>如果有多个输入生命周期参数，但其中一个是<code>&amp;self</code>或<code>&amp;mut self</code>，那么<code>self</code>的生命周期会被赋予所有输出引用。</p></li>
</ol>
<p>三条规则实际上都很好理解，但是当实际情况与规则发生一定的冲突时，我们应该怎么办呢？如第三条规则，若一个方法，它的返回值的生命周期就是跟参数<code>&amp;self</code>的不一样怎么办？这时候我们就需要<strong>手动标注生命周期</strong>，因为这些规则只是<strong>编译器发现你没有标注生命周期时默认去使用的</strong>，当你标注生命周期后，编译器自然会乖乖听你的话。</p>
<p>让我们再举一些例子，带入编译器的视角理解引用这些规则： ### 例子1
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123; </span><br></pre></td></tr></table></figure>
有代码如上，编译器会首先应用第一条规则，为每个参数标注一个生命周期:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123; <span class="comment">// 编译器自动为参数添加生命周期</span></span><br></pre></td></tr></table></figure>
此时，第二条规则就可以进行应用，因为函数只有一个输入生命周期，因此该生命周期会被赋予所有的输出生命周期：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123; <span class="comment">// 编译器自动为返回值添加生命周期</span></span><br></pre></td></tr></table></figure>
此时，编译器为函数签名中的所有引用都自动添加了具体的生命周期，因此编译通过，且用户无需手动去标注生命周期，只要按照<code>fn first_word(s: &amp;str) -&gt; &amp;str &#123;</code>的形式写代码即可。</p>
<h3 id="例子2">例子2</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123; </span><br></pre></td></tr></table></figure>
<p>首先，编译器会应用第一条规则，为每个参数都标注生命周期：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>
但是此时，第二条规则却无法被使用，因为输入生命周期有两个，第三条规则也不符合，因为它是函数，不是方法，因此没有<code>&amp;self</code>参数。在套用所有规则后，编译器依然无法为返回值标注合适的生命周期，因此，编译器就会报错，提示我们需要手动标注生命周期：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:1:47</span><br><span class="line">  |</span><br><span class="line">1 | fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;str &#123;</span><br><span class="line">  |                       -------     -------     ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span><br><span class="line">note: these named lifetimes are available to use</span><br><span class="line"> --&gt; src/main.rs:1:12</span><br><span class="line">  |</span><br><span class="line">1 | fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;str &#123;</span><br><span class="line">  |            ^^  ^^</span><br><span class="line">help: consider using one of the available lifetimes here</span><br><span class="line">  |</span><br><span class="line">1 | fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;lifetime str &#123;</span><br><span class="line">  |                                                +++++++++</span><br></pre></td></tr></table></figure></p>
<h2 id="静态生命周期标注">静态生命周期标注</h2>
<p>在 Rust
中有一个非常特殊的生命周期，那就是<code>'static</code>，它表示整个程序运行期间都有效的生命周期。这通常用于全局变量或字符串字面量。</p>
<p>在之前我们学过字符串字面量，提到过它是被硬编码进Rust的二进制文件中，因此这些字符串变量全部具有<code>'static</code>的生命周期：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;我没啥优点，就是活得久，嘿嘿&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>还有如下常量的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SOME_COORDINATE: (<span class="type">i32</span>, <span class="type">i32</span>) = (<span class="number">7</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">static_reference</span>: &amp;<span class="symbol">&#x27;static</span>(<span class="type">i32</span>, <span class="type">i32</span>) = &amp;SOME_COORDINATE;</span><br></pre></td></tr></table></figure></p>
<h2 id="特殊生命周期标注">特殊生命周期标注</h2>
<p>当我们在为带有生命周期的结构体或者枚举实现方法或函数时，如果我们不关心生命周期本身，那么我们就可以应用占位符<code>_</code>替换生命周期标注：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    counter: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span>&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">increment</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        *<span class="keyword">self</span>.counter += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="生命周期约束">生命周期约束</h2>
<p>让我们来看下面这个例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此时，我们可以发现，该函数<code>announce_and_return_part</code>存在两个生命周期标注<code>'a</code>和<code>'b</code>，但是在该函数中，并不满足我们之前提到的三条规则，因而编译器无法知道<code>'a</code>和<code>'b</code>的关系。在该函数中，返回的<code>&amp;'b str</code>实际上是<code>self.part</code>，因此我们实际上显然需要生命周期<code>'a</code>比<code>'b</code>大，因此，我们需要进行生命周期的约束：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;b</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上面的代码示例中： ·
<code>'a: 'b</code>，是生命周期约束语法，跟泛型约束非常相似，用于说明<code>'a</code>必须比<code>'b</code>活得久
·
可以把<code>'a</code>和<code>'b</code>都在同一个地方声明（如上），或者分开声明但通过<code>where 'a: 'b</code>约束生命周期关系，如下：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="生命周期子类型和协变">生命周期子类型和协变</h2>
<p>生命周期可以有子类型关系，较短的生命周期可以被视为较长的生命周期的子类型。这在协变（covariance）中尤为重要‼️
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">example</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y:&amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> </span><br><span class="line"><span class="keyword">where</span> <span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>,</span><br><span class="line">&#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>下面是一段十分有问题的代码： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_mut</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>) &#123;</span><br><span class="line">        my_vec.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span> = <span class="built_in">vec!</span>[&amp;x];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my vec: &#123;my_vec:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，最大的问题便是我们使用了不同的生命周期标注<code>'a</code>和<code>'b</code>。对于<code>&amp;y</code>，编译器在没有明确指示的情况下默认它在执行完<code>insert_value(&amp;mut my_vec, &amp;y);</code>语句后就已经自动<code>drop</code>
掉了。因此在后续打印时出现了无效的引用。因此，我们需要通过生命周期约束告诉编译器<code>&amp;y</code>的生命周期<code>'b</code>需要大于等于<code>'a</code>:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_mut</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>) &#123;</span><br><span class="line">        my_vec.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span> = <span class="built_in">vec!</span>[&amp;x];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(&amp;<span class="keyword">mut</span> my_vec, &amp;y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my vec: &#123;my_vec:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者，我们也可以简单的使用<code>fn insert_value&lt;'a&gt;(my_vec: &amp;mut Vec&lt;&amp;'a i32&gt;, value: &amp;'a i32) &#123;</code>来告诉编译器两个生命周期相同，编译器就不再会报错。</p>
<h2 id="课后习题">课后习题</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_lifetime_multiple</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">insert_value</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(my_vec: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>&gt;, value: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>) &#123; <span class="comment">// 使用&#x27;a和&#x27;b两个生命周期参数,</span></span><br><span class="line">        my_vec.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_vec</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val1</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val2</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = &amp;<span class="keyword">mut</span> my_vec;</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(a, &amp;val1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a is &#123;:?&#125;&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = &amp;<span class="keyword">mut</span> my_vec;</span><br><span class="line">    <span class="title function_ invoke__">insert_value</span>(b, &amp;val2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b is &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, my_vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/26/rust-trait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/26/rust-trait/" class="post-title-link" itemprop="url">十八、Rust进阶-特征</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-26 16:19:45" itemprop="dateCreated datePublished" datetime="2024-10-26T16:19:45+08:00">2024-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:46:46" itemprop="dateModified" datetime="2024-11-14T07:46:46+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="特征-trait">特征 Trait</h1>
<p>trait定义了某个特定类型拥有可能与其他类型共享的功能。（有点类似于其他语言中的接口（interfaces），虽然存在些许不同）</p>
<h2 id="定义的特征与实现">定义的特征与实现</h2>
<p>让我们来看下面一个例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的示例中，我们使用<code>trait</code>关键字来声明一个特征，其中<code>Summary</code>是特征名，在大括号中定义了该特征的所有方法。</p>
<p>特征只定义行为看起来是什么样的，而不定义行为具体是怎么样的。因此，我们只定义特征方法的签名，而不进行实现，此时方法签名结尾是
;，而不是一个 {}。</p>
<p>接下来，每一个实现这个特征的类型都需要具体实现该特征的相应方法，编译器也会确保任何实现<code>Summary</code>特征的类型<strong>都</strong>拥有与这个签名的定义完全一致的<code>summarize</code>方法。</p>
<h2 id="为类型实现特征">为类型实现特征</h2>
<p>接下来，我们为每一个类型都实现具体的特征： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>, <span class="comment">// 标题</span></span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>, <span class="comment">// 作者</span></span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>, <span class="comment">// 内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;</span>, <span class="keyword">self</span>.title, <span class="keyword">self</span>.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;发表了微博&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实现特征的语法与为结构体、枚举实现方法很像：<code>impl Summary for Post</code>，读作“为<code>Post</code>类型实现<code>Summary</code>特征”，然后在<code>impl</code>的花括号中实现该特征的具体方法。</p>
<p>既然已经为类型实现了特征，接下来我们就可以在类型上调用特征的方法：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post</span> = Post&#123;title: <span class="string">&quot;Rust语言简介&quot;</span>.<span class="title function_ invoke__">to_string</span>(),author: <span class="string">&quot;Sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(), content: <span class="string">&quot;Rust棒极了!&quot;</span>.<span class="title function_ invoke__">to_string</span>()&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">weibo</span> = Weibo&#123;username: <span class="string">&quot;sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(),content: <span class="string">&quot;好像微博没Tweet好用&quot;</span>.<span class="title function_ invoke__">to_string</span>()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,post.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,weibo.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 运行上述代码后，会输出如下结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文章 Rust 语言简介, 作者是Sunface</span><br><span class="line">sunface发表了微博好像微博没Tweet好用</span><br></pre></td></tr></table></figure></p>
<h3
id="孤儿规则特征定义和实现的位置">孤儿规则——特征定义和实现的位置</h3>
<p>上面我们将<code>Summary</code>定义成了<code>pub</code>公开的。这样，如果他人想要使用我们的<code>Summary</code>特征，则可以引入到他们的包中，然后再进行实现。</p>
<p>关于特征实现与定义的位置，有一条非常重要的原则：如果你想要为<strong>类型<code>A</code>实现特征<code>T</code>，那么<code>A</code>或者<code>T</code>至少有一个是在当前作用域中定义的！</strong>
例如我们可以为上面的<code>Post</code>类型实现标准库中的<code>Display</code>特征，这是因为<code>Post</code>类型定义在当前的作用域中。同时，我们也可以在当前包中为<code>String</code>类型实现<code>Summary</code>特征，因为<code>Summary</code>定义在当前作用域中。</p>
<p>但是你无法在当前作用域中，为<code>String</code>类型实现<code>Display</code>特征，因为它们俩都定义在标准库中，其定义所在的位置都不在当前作用域。</p>
<p>该规则被称为<strong>孤儿规则</strong>，可以确保其它人编写的代码不会破坏你的代码，也确保了你不会莫名其妙就破坏了风马牛不相及的代码。</p>
<h3 id="默认实现">默认实现</h3>
<p>实际上，我们可以在特征中定义具有<code>默认实现</code>的方法，这样其他类型就无需再次实现该方法，或者我们也可以选择重载该方法：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，我们为特征<code>Summary</code>定义了一个默认实现，下面继续：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Post</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;发表了微博&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,post.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,weibo.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，<code>Post</code>选择了默认实现，而<code>Weibo</code>重载了该方法，输出如下：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Read more...)</span><br><span class="line">sunface发表了微博好像微博没Tweet好用</span><br></pre></td></tr></table></figure></p>
<p>同时，<strong>默认实现允许调用相同特征中的其他方法，哪怕这些方法没有默认实现</strong>。如此，特征可以提供很多有用的功能而只需要实现指定的一小部分内容。例如，我们可以定义<code>Summary</code>特征，使其具有一个需要实现的<code>summarize_author</code>方法，然后定义一个<code>summarize</code>方法，此方法的默认实现调用<code>summarize_author</code>方法：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
为了使用<code>Summary</code>，只需要实现<code>summarize_author</code>方法即可：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;1 new weibo: &#123;&#125;&quot;</span>, weibo.<span class="title function_ invoke__">summarize</span>());</span><br></pre></td></tr></table></figure>
此时，<code>weibo.summarize()</code>会先调用<code>Summary</code>特征默认实现的<code>summarize</code>方法，通过该方法进而调用<code>Weibo</code>为<code>Summary</code>实现的<code>summarize_author</code>方法，最终输出：<code>1 new weibo: (Read more from @horse_ebooks...)</code>。</p>
<h2 id="带泛型的trait">带泛型的trait</h2>
<p>如果我们需要在特征trait中使用泛型参数<code>T</code>，则需要在定义时使用尖括号注明。同时，我们可以针对不同的参数类型，为特征实现具体的方法：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Converter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyInt</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span>&lt;<span class="type">f32</span>&gt; <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span> <span class="keyword">as</span> <span class="type">f32</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_int</span> = <span class="title function_ invoke__">MyInt</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span>: <span class="type">String</span> = my_int.<span class="title function_ invoke__">convert</span>();  <span class="comment">//需要显式标出output的类型</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;output is: &#123;&#125;&quot;</span>, output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span>: <span class="type">f32</span> = my_int.<span class="title function_ invoke__">convert</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;output is: &#123;&#125;&quot;</span>, output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
需要注意的是，在这里是带泛型的trait，而在上一节中我们实现过带泛型的方法，其语法是：<code>impl&lt;T&gt; Struct&lt;T&gt; &#123;&#125;</code>，这里我们需要注意区分。</p>
<h2 id="关联类型">关联类型</h2>
<p>关联类型是trait定义中的类型占位符。定义的时候，并不定义它的具体类型是什么。当我们使用<code>impl</code>实现该trait的时候，才为这个关联类型赋予了确定的类型。同时，关联类型的方式只允许对目标类型实现一次。</p>
<p>让我们来看如下的代码示例： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Converter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyInt</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span> <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;   <span class="comment">//赋予具体的String类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Converter</span> <span class="keyword">for</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">f32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">convert</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>::Output &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span> <span class="keyword">as</span> <span class="type">f32</span></span><br><span class="line">    &#125;       <span class="comment">//无法实现，因为关联类型的方式只允许对目标类型实现一次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="默认泛型类型参数">默认泛型类型参数</h2>
<p>让我们回顾上一节泛型的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">2i8</span>, <span class="number">3i8</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">1.23</span>, <span class="number">1.23</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码示例中，实际上传入该函数的参数有限制：<code>add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;</code>。即该泛型<code>T</code>需要实现Add这个特征：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;Rhs = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span>: Output;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Rhs) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在实现<code>Add</code>trait时如果我们不指定<code>Rhs</code>的具体类型，<code>Rhs</code>的类型将是默认的<code>Self</code>类型，也就是在其上实现<code>Add</code>的类型。实际上，<code>Rhs</code>就是一个泛型类型参数，代表了<code>Add</code>trait中的<strong>右操作数类型</strong>（Right-hand
side type）。</p>
<p>有如下的代码示例： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>;</span><br><span class="line">    y: <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = <span class="title function_ invoke__">add</span>(Point&#123;x:<span class="number">1</span>, y:<span class="number">0</span>&#125;, <span class="title function_ invoke__">Point</span>(x:<span class="number">2</span>, y:<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;p3.x&#125;, y: &#123;p3.y&#125;&quot;</span>);   <span class="comment">//x: 3, y: 3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码示例中，我们在实现<code>Add</code>trait的方法时并没有指定<code>Rhs</code>的类型，因此，<code>Rhs</code>的类型就是默认的<code>Self</code>类型，即<code>Point</code>。</p>
<p>自定义<code>Rhs</code>类型而不是使用默认类型的例子如下：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meters&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Meters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> + (other.<span class="number">0</span> * <span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
而在上面的代码示例中，我们通过<code>impl Add&lt;Meters&gt; for Millimeters &#123;&#125;</code>来指定了<code>Rhs</code>类型为新的类型<code>Meters</code>，从而实现了两个不同类型<code>Millimeters</code>和<code>Meters</code>之间的相加。</p>
<h2 id="使用特征作为函数参数">使用特征作为函数参数</h2>
<p>特征不仅仅可以用来实现方法，它还可以作为函数参数的特征使用：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用<code>impl Summary</code>来表示：<strong>实现了<code>Summary</code>特征</strong>的<code>item</code>参数。</p>
<p>此时，我们可以使用任何实现了<code>Summary</code>特征的类型作为该函数的参数，同时在函数体内，还可以调用该特征的方法。例如<code>summarize</code>方法。具体的说，可以传递<code>Post</code>或<code>Weibo</code>的实例来作为参数，而其它类如
<code>String</code>或者<code>i32</code>的类型则不能用做该函数的参数，因为它们没有实现<code>Summary</code>特征。</p>
<h2 id="特征约束trait-bound">特征约束（trait bound）</h2>
<p>虽然上面的<code>impl trait</code>这种语法十分好理解，但是它实际上只是一个语法糖：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
真正的完整书写形式如上所述。而上面形如<code>T: Summary</code>的表达被称为<strong>特征约束</strong>。</p>
<p>在简单的场景下<code>impl Trait</code>这种语法糖就足够使用，但是对于复杂的场景，特征约束可以让我们拥有更大的灵活性和语法表现能力，例如一个函数接受两个<code>impl Summary</code>的参数：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item1: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
如果函数两个参数是不同的类型，那么上面的方法很好，只要这两个类型都实现了<code>Summary</code>特征即可。但是如果我们想要强制函数的两个参数是同一类型呢？上面的语法就无法做到这种限制，此时我们只能使特征约束来实现：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
泛型类型<code>T</code>说明了<code>item1</code>和<code>item2</code>必须拥有同样的类型，同时<code>T: Summary</code>说明了<code>T</code>必须实现<code>Summary</code>特征。</p>
<h3 id="多重约束">多重约束</h3>
<p>除了单个约束条件，我们还可以指定多个约束条件，例如除了让参数实现<code>Summary</code>特征外，还可以让参数实现<code>Display</code>特征以控制它的格式化输出：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;&#125;</span><br></pre></td></tr></table></figure> 除了上述的语法糖形式，还能使用特征约束的形式：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
通过这两个特征，就可以使用<code>item.summarize</code>方法，以及通过<code>println!("&#123;&#125;", item)</code>来格式化输出<code>item</code>。</p>
<h3 id="where约束">Where约束</h3>
<p>当特征约束变得很多时，函数的签名将变得很复杂： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
严格来说，上面的例子还是不够复杂，但是我们还是能对其做一些形式上的改进，通过<code>where</code>：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3
id="使用特征约束有条件地实现方法或特征">使用特征约束有条件地实现方法或特征</h3>
<p>特征约束，可以让我们在指定类型 + 指定特征的条件下去实现方法，例如：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;   <span class="comment">//为所有Pair&lt;T实现了new方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;     <span class="comment">//仅为满足T：Display + PartialOrd的Pair&lt;T实现了cmd_display方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，我们可以发现，<code>cmp_display</code>方法，并不是所有的<code>Pair&lt;T&gt;</code>结构体对象都可以拥有，只有<code>T</code>同时实现了<code>Display + PartialOrd</code>的<code>Pair&lt;T&gt;</code>才可以拥有此方法。该函数可读性会更好，因为泛型参数、参数、返回值都在一起，可以快速的阅读，同时每个泛型参数的特征也在新的代码行中通过特征约束进行了约束。</p>
<p>也可以有条件地实现特征，例如，标准库为任何实现了<code>Display</code>特征的类型实现了<code>ToString</code>特征：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们可以对任何实现了<code>Display</code>特征的类型调用由<code>ToString</code>定义的<code>to_string</code>方法。例如，可以将整型转换为对应的<code>String</code>值，因为整型实现了<code>Display</code>：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="number">3</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure></p>
<h2 id="函数返回中的impl-trait">函数返回中的impl Trait</h2>
<p>在上面我们讲述了trait在函数入参中的使用。实际上我们还可以通过<code>impl Trait</code>
来说明一个函数返回了实现了某个特征的类型： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Weibo &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sunface&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">&quot;m2 air也不错&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为<code>Weibo</code>实现了<code>Summary</code>，因此这里可以用它来作为返回值。要注意的是，虽然我们知道这里是一个<code>Weibo</code>类型，但是对于<code>returns_summarizable</code>的调用者而言，他只知道返回了一个实现了<code>Summary</code>特征的对象，但是并不知道返回了一个<code>Weibo</code>类型。</p>
<p>这种<code>impl Trait</code>形式的返回值，在一种场景下非常非常有用，那就是返回的真实类型非常复杂，你不知道该怎么声明时（毕竟<code>Rust</code>要求你必须标出所有的类型），此时就可以用<code>impl Trait</code>的方式简单返回。例如，闭包和迭代器就是很复杂，只有编译器才知道那玩意的真实类型，如果让你写出来它们的具体类型，估计内心有一万只草泥马奔腾，好在你可以用<code>impl Iterator</code>来告诉调用者，返回了一个迭代器，因为所有迭代器都会实现<code>Iterator</code>特征。</p>
<p>但是这种返回值方式有一个很大的限制：只能有一个具体的类型，例如：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        Post &#123;</span><br><span class="line">            title: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">            author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;The Pittsburgh Penguins once again are the best \</span></span><br><span class="line"><span class="string">                 hockey team in the NHL.&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Weibo &#123;</span><br><span class="line">            username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上的代码就无法通过编译，因为它返回了两个不同的类型<code>Post</code>和<code>Weibo</code>。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`if` and `else` have incompatible types</span><br><span class="line">expected struct `Post`, found struct `Weibo`</span><br></pre></td></tr></table></figure>
报错提示我们<code>if</code>和<code>else</code>返回了不同的类型。如果想要实现返回不同的类型，需要<strong>特征对象</strong>：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Summary&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">       <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Post &#123;</span><br><span class="line">            title: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">            author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;The Pittsburgh Penguins once again are the best \</span></span><br><span class="line"><span class="string">                 hockey team in the NHL.&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Weibo &#123;</span><br><span class="line">            username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="通过dereive派生特征">通过<code>dereive</code>派生特征</h2>
<p>在先前的Rust学习过程中，形如<code>#[derive(Debug)]</code>的代码已经出现了很多次，这种是一种特征派生语法，被<code>derive</code>标记的对象会自动实现对应的默认特征代码，继承相应的功能。</p>
<p>例如<code>Debug</code>trait，它用于开启格式化字符串中的调试格式，其通过在<code>&#123;&#125;</code>占位符中增加<code>:?</code>表明。<code>Debug</code>trait允许以调试目的来打印一个类型的实例，所以使用该类型的程序员可以在程序执行的特定时间点观察其实力。例如，在使用<code>assert_eq!</code>宏的时候，<code>Debug</code>trait是必须的，如果等式断言失败，这个宏就需要把给定实例的值作为参数打印出来，如此程序员可以看到两个实例为什么不相等。</p>
<p>还有<code>Default</code>trait，它可以使你创建一个类型的默认值。派生<code>Default</code>实现了<code>default</code>函数。<code>default</code>函数的派生实现调用了类型每部分的<code>default</code>函数，这意味着只有类型中所有的字段或值实现了<code>Dafault</code>时，才能够为该类型派生<code>Default</code>。
<code>Default::default</code>函数通常结合结构体更新语法一起使用，可以自定义一个结构体的小部分字段而剩余字段则使用<code>..Default::default()</code>设置为默认值。</p>
<p>再如<code>Copy</code>特征，它也有一套自动实现的默认代码，当标记到一个类型上时，可以让这个类型自动实现<code>Copy</code>特征，进而可以调用<code>copy</code>方法，进行自我复制。</p>
<p>总之，<code>derive</code>派生出来的是Rust默认给我们提供的特征，在开发过程中极大的简化了自己手动实现相应特征的需求，当然，如果你有特殊的需求，还可以自己手动重载该实现。</p>
<p>详细的<code>derive</code>列表参见附录-<a href="">派生特征</a>。</p>
<h2 id="课后习题">课后习题</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要更改Item的定义</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Item</span>&lt;T = <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>: Display;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apple结构的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;   <span class="comment">// 需要指定Output为String类型，否则会报错</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Weibo结构的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Item</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;   <span class="comment">// 需要指定Output为String类型，否则会报错   </span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;:&#123;&#125;&quot;</span>, <span class="keyword">self</span>.author, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    items: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Item&lt;Output = <span class="type">String</span>&gt;&gt;&gt;,  <span class="comment">// 将原先的Vec&lt;Item&gt;改为Vec&lt;Box&lt;dyn Item&lt;Output = String&gt;&gt;&gt;，因为Rust不支持直接在向量中存储动态大小的类型DST</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iterator</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> <span class="keyword">self</span>.items.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">apple</span> = Apple &#123;</span><br><span class="line">        name: <span class="string">&quot;Apple&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = Weibo &#123;</span><br><span class="line">        author: <span class="string">&quot;Weibo&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">container</span> = Container &#123;</span><br><span class="line">        items: <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(apple), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(w)], <span class="comment">// 将原先的vec![apple, w]改为vec![Box::new(apple), Box::new(w)]，因为Rust不支持直接在向量中存储动态大小的类型DST</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    container.<span class="title function_ invoke__">iterator</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/26/rust-generics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/26/rust-generics/" class="post-title-link" itemprop="url">十七、Rust进阶-泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-26 14:08:57 / Modified: 23:16:25" itemprop="dateCreated datePublished" datetime="2024-10-26T14:08:57+08:00">2024-10-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="泛型generics">泛型Generics</h1>
<p>在Rust中，泛型和特征是Rust中最最重要的抽象类型。</p>
<p>我们在编程中，经常有这样的需求：用同一功能的函数处理不同类型的数据，例如两个数的加法，无论是整数还是浮点数，甚至是自定义类型，都能进行支持。在不支持泛型的编程语言中，通常需要为每一种类型编写一个函数：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_i8</span>(a:<span class="type">i8</span>, b:<span class="type">i8</span>) <span class="punctuation">-&gt;</span> <span class="type">i8</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_i32</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_f64</span>(a:<span class="type">f64</span>, b:<span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_i8</span>(<span class="number">2i8</span>, <span class="number">3i8</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_i32</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_f64</span>(<span class="number">1.23</span>, <span class="number">1.23</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述的代码可以正常运行，但是十分啰嗦。但当我们有了<strong>泛型</strong>之后，事情就变得不太一样了。</p>
<p>当使用<strong>泛型</strong>定义函数时，本来在函数签名中指定参数类型和返回值类型的地方，会改用泛型来表示。采用这种技术，可以使得代码的适应性更强，从而为函数的调用者提供更多的功能，同时也避免了代码的重复。</p>
<p>我们可以来看下面的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">2i8</span>, <span class="number">3i8</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">1.23</span>, <span class="number">1.23</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型详解">泛型详解</h2>
<p>在上面的代码示例中，<code>T</code>就是<strong>泛型参数</strong>，实际上在Rust中，泛型参数的名称你可以任意起，但是出于惯例，我们都用<code>T</code>（<code>T</code>是<code>type</code>的首字母）来作为首选，这个名称越短越好，除非需要表达含义，否则一个字母是最完美的。</p>
<p>使用泛型参数有一个先决条件，就是必须要在使用前对其进行声明：<code>fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) -&gt; T &#123;</code></p>
<p>同时，在上面的代码示例中，我们可以发现，我们使用<code>T: std::ops::Add&lt;Output = T</code>对类型<code>T</code>进行了限制，因为不是所有的<code>T</code>类型都能进行相加操作。通过如上的代码我们告诉编译器传入的参数可以进行相加操作。</p>
<h2 id="在函数定义中使用泛型">在函数定义中使用泛型</h2>
<p>让我们再来看一下下面这个函数定义的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行之后会报错： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0369]: binary operation `&gt;` cannot be applied to type `T` // `&gt;`操作符不能用于类型`T`</span><br><span class="line"> --&gt; src/main.rs:5:17</span><br><span class="line">  |</span><br><span class="line">5 |         if item &gt; largest &#123;</span><br><span class="line">  |            ---- ^ ------- T</span><br><span class="line">  |            |</span><br><span class="line">  |            T</span><br><span class="line">  |</span><br><span class="line">help: consider restricting type parameter `T` // 考虑对T进行类型上的限制 :</span><br><span class="line">  |</span><br><span class="line">1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">  |             ++++++++++++++++++++++</span><br></pre></td></tr></table></figure>
通过报错信息，我们可以发现，由于<code>T</code>可以是任何类型，但并不是任何类型都可以相比较，因此，我们需要使用<code>fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T &#123;</code>对<code>T</code>的类型进行限制。</p>
<h2 id="结构体定义中的泛型">结构体定义中的泛型</h2>
<p><strong>声明</strong>：结构体名称后面的尖括号中声明泛型参数的名称，结构体定义中可以指定具体数据类型的位置。</p>
<p>在下面的例子中，将展示一个结构体： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的例子中，<code>x</code>和<code>y</code>必须得是相同的类型，如果使用不同的类型，那么就会导致下面代码的报错：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point&#123;x: <span class="number">1</span>, y :<span class="number">1.1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 报错如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types //类型不匹配</span><br><span class="line"> --&gt; src/main.rs:7:28</span><br><span class="line">  |</span><br><span class="line">7 |     let p = Point&#123;x: 1, y :1.1&#125;;</span><br><span class="line">  |                            ^^^ expected integer, found floating-point number //期望y是整数，但是却是浮点数</span><br></pre></td></tr></table></figure>
这是因为当我们把<code>1</code>赋值给<code>x</code>时，变量<code>p</code>的<code>T</code>类型就被确定为整数类型，因此<code>y</code>也必须是整数类型，但是我们却给它赋予了浮点数，因此导致报错。</p>
<p>但如果我们偏偏想要<code>x</code>和<code>y</code>既能类型相同，又能类型不同时，应该怎么办呢？
————&gt; 使用不同的泛型参数： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T,U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point&#123;x: <span class="number">1</span>, y :<span class="number">1.1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在方法中使用泛型">在方法中使用泛型</h2>
<p>在方法中，我们也可以使用泛型： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用泛型参数前，依然需要提前声明：<code>impl&lt;T&gt;</code>，只有提前声明了，我们才能在<code>Point&lt;T&gt;</code>中使用它，这样Rust就知道<code>Point</code>的尖括号中的类型是泛型而不是具体类型。需要注意的是，这里的<code>Point&lt;T&gt;</code>不再是泛型声明，而是一个完整的结构体类型，因为我们定义的结构体就是<code>Point&lt;T&gt;</code>而不再是<code>Point</code>。</p>
<p>除了结构体中的泛型参数，我们还能在该结构体的方法中定义额外的泛型参数，就跟泛型函数一样：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y); <span class="comment">//p3.x = 5, p3.y = c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个例子中，<code>T,U</code>是定义在结构体<code>Point</code>上的泛型参数，<code>V,W</code>是单独定义在方法<code>mixup</code>上的泛型参数，它们并不冲突，说白了，你可以理解为，一个是结构体泛型，一个是函数泛型。</p>
<h3 id="为具体的泛型实现方法">为具体的泛型实现方法</h3>
<p>对于<code>Point&lt;T&gt;</code>类型，你不仅能定义基于<code>T</code>的方法，还能针对特定的具体类型，进行方法定义：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码意味着<code>Point&lt;f32&gt;</code>类型会有一个方法<code>distance_from_origin</code>，而其他<code>T</code>不是<code>f32</code>类型的<code>Point&lt;T&gt;</code>实例则没有定义此方法。这个方法计算点实例与坐标<code>(0.0, 0.0)</code>之间的距离，并使用了只能用于浮点型的数学运算符。</p>
<p>这样我们就能针对特定的泛型类型实现某个特定的方法，对于其它泛型类型则没有定义该方法。</p>
<h2 id="const泛型">const泛型</h2>
<p>在之前的泛型中，可以抽象为一句话：针对<strong>类型</strong>实现的泛型，所有的泛型都是为了抽象不同的类型，那有没有针对<strong>值</strong>的泛型？可能很多同学感觉很难理解，值怎么使用泛型？不急，我们先从数组讲起。</p>
<p>在数组中：<code>[i32; 2]</code>和<code>[i32; 3]</code>是不同的数组类型，比如下面的代码：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>(arr: [<span class="type">i32</span>; <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行后不通过，因为最后一个<code>arr</code>是<code>[i32; 2]</code>类型，而函数显然期望一个<code>[i32; 3]</code>类型的数组。</p>
<p>为了解决这一问题，我们可以采用数组的切片来解决这一问题：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>(arr: &amp;[<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
同时，更近一步，我们可以使用泛型参数<code>T</code>来替换<code>i32</code>，实现所有类型的数组：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>&gt;(arr: &amp;[T]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但需要注意的是吗，在上面的代码示例中有序我们需要使用Debug打印<code>arr</code>，因而我们期望传入的参数拥有<code>Debug</code>的特性。</p>
<p>通过上面的数组切片(引用)，显然我们解决了处理任何类型数组的问题。但是在某些不能使用引用的场景下我们应该怎么办呢？Rust给了我们答案：<code>const</code>泛型，也就是针对值的泛型，正好可以用于处理数组长度的问题：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt;(arr: [T; N]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如上所示，我们定义了一个类型为<code>[T; N]</code>的数组，其中<code>T</code>是一个基于类型的泛型参数，这个和之前讲的泛型没有区别，而重点在于<code>N</code>这个泛型参数，它是一个基于值的泛型参数！因为它用来替代的是数组的长度。</p>
<p><code>N</code>就是<code>const</code>泛型，定义的语法是<code>const N: usize</code>，表示<code>const</code>泛型<code>N</code>，它基于的值类型是<code>usize</code>。</p>
<h2 id="泛型的性能">泛型的性能</h2>
<p>在Rust中泛型是零成本的抽象，意味着你在使用泛型时，完全不用担心性能上的问题。这是因为Rust通过在编译时进行泛型代码的<strong>单态化(monomorphization)</strong>来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p>
<p>让我们来看下面的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">integer</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">float</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br></pre></td></tr></table></figure>
当Rust编译这些代码的时候，它会进行单态化。编译器会读取传递给<code>Option&lt;T&gt;</code>的值并发现有两种<code>Option&lt;T&gt;</code>：一种对应<code>i32</code>另一种对应<code>f64</code>。为此，它会将泛型定义<code>Option&lt;T&gt;</code>展开为<code>Option_i32</code>和<code>Option_f64</code>，接着将泛型定义替换为这两个具体的定义。</p>
<p>编译器生成的单态化版本的代码看起来像这样： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_f64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Option_i32::<span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Option_f64::<span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们可以使用泛型来编写不重复的代码，而Rust将会为每一个实例编译其特定类型的代码。这意味着在使用泛型时没有运行时开销；当代码运行，它的执行效率就跟好像手写每个具体定义的重复代码一样。这个单态化过程正是Rust泛型在运行时极其高效的原因。</p>
<p>但是，Rust是在编译期为泛型对应的多个类型，生成各自的代码，因此损失了编译速度和增大了最终生成文件的大小。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/26/rust-smaet-pointer-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/26/rust-smaet-pointer-2/" class="post-title-link" itemprop="url">二十、Rust进阶-智能指针2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-26 14:07:10" itemprop="dateCreated datePublished" datetime="2024-10-26T14:07:10+08:00">2024-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:46:11" itemprop="dateModified" datetime="2024-11-14T07:46:11+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="智能指针2">智能指针2</h1>
<p>在智能指针1中，我们讲到了<code>Box&lt;T&gt;</code>，它是一种在堆上分配内存的智能指针。还讲到了<code>Deref</code>和<code>Drop</code>特征，它们允许我们自定义智能指针的行为。</p>
<p>在本节中，我们将介绍几种其他常见的智能指针，包括<code>Rc&lt;T&gt;</code>、<code>Arc&lt;T&gt;</code>、<code>Mutex&lt;T&gt;</code>和<code>RwLock&lt;T&gt;</code>。</p>
<h2 id="rct"><code>Rc&lt;T&gt;</code></h2>
<p><code>Rc&lt;T&gt;</code>是<strong>引用计数指针</strong>，其中Rc是Reference
count的缩写，允许用于在多个地方共享所有权。它允许多个所有者共享同一个对象，而不会增加引用计数。</p>
<h3 id="为什么需要rct">为什么需要<code>Rc&lt;T&gt;</code></h3>
<p>Rust所有权机制要求一个值只能有一个所有者。在大多数情况下都没有问题，但是我们需要考虑以下情况：</p>
<ul>
<li><strong>一个值被多个变量使用</strong>：在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理</li>
<li><strong>一个值被多个线程使用</strong>：在多线程中，多个线程可能会持有同一个数据，但是你受限于
Rust 的安全机制，无法同时获取该数据的可变引用</li>
</ul>
<p>这时候，为了解决此类问题，Rust
在所有权机制之外又引入了额外的措施来简化相应的实现：通过引用计数的方式，允许一个数据资源在同一时刻拥有多个所有者。</p>
<p>这种实现机制就是<code>Rc</code>和<code>Arc</code>，前者适用于单线程，后者适用于多线程。由于二者大部分情况下都相同，因此本章将以<code>Rc</code>作为讲解主体，对于<code>Arc</code>的不同之处，另外进行单独讲解。</p>
<h3 id="rc的使用">Rc<T>的使用</h3>
<p>引用计数(reference
counting)，顾名思义，通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放。</p>
<p>而<code>Rc</code>正是引用计数的英文缩写。当我们希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用<code>Rc</code>成为数据值的所有者.</p>
<p>让我们使用之前用<code>Box&lt;T&gt;</code>实现的链表的例子：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在以上的代码中我们创建了两个共享第三个链表所有权的链表。它的数据结构如下图所示：
<img src="images/20-1.png" alt="" width="500"></p>
<p>我们可以发现此时代码报错如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: use of moved value: `a`</span><br></pre></td></tr></table></figure>
因为在为变量<code>b</code>进行赋值时，变量<code>a</code>的所有权被转移给了<code>b</code>，因此变量<code>a</code>不再拥有任何值，所以变量<code>c</code>尝试获取变量<code>a</code>的所有权时，会导致所有权错误。</p>
<p>那我们应该如何解决这个问题呢？可以先考虑一下我们之前学过的生命周期与引用：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, &amp;<span class="symbol">&#x27;a</span> List&lt;<span class="symbol">&#x27;a</span>&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::*;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, &amp;List::<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, &amp;Nil));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, &amp;a);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, &amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，我们为<code>List</code>的每个元素添加了生命周期，这样就可以让<code>List</code>的每个元素共享同一个生命周期，从而避免所有权问题。</p>
<p>当然，由于本节课程我们学习的是引用计数<code>Rc&lt;T&gt;</code>，因此我们当然再需要使用<code>Rc&lt;T&gt;</code>来解决这个问题：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> crate::List::*;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));  </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));     <span class="comment">// 使用Rc::clone(&amp;a)克隆a的引用计数, 引用计数+1</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));     <span class="comment">// 引用计数再+1</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，我们使用<code>Rc::clone(&amp;a)</code>来克隆<code>a</code>的引用计数，同时<code>a</code>的引用计数+1，最终打印出来的引用计数如下：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count after creating a = 1</span><br><span class="line">count after creating b = 2</span><br><span class="line">count after creating c = 3</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中出现了很多关于<code>Rc</code>的方法，接下来我们一一进行讲解。</p>
<p>首先，在使用<code>Rc&lt;T&gt;</code>之前，我们需要在文件头部添加<code>use std::rc::Rc;</code>来引入<code>Rc</code>模块。随后，我们使用<code>Rc::new(T)</code>来创建一个<code>Rc&lt;T&gt;</code>类型的值。具体在代码中我们首先定义了<code>Rc&lt;List&gt;</code>类型,
然后使用<code>Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))))</code>来创建一个<code>Rc&lt;List&gt;</code>类型的<strong>指针</strong>，并赋值给变量<code>a</code>。</p>
<p>智能指针<code>Rc&lt;T&gt;</code>在创建时，会将引用计数+1，此时获取引用计数的关联函数<code>Rc::strong_count</code>返回的值将是<code>1</code>。</p>
<p>接着，在赋值给变量<code>b</code>时，我们使用<code>Rc::clone(&amp;a)</code>克隆了一份智能指针<code>Rc&lt;List&gt;</code>，此时<code>a</code>的引用计数+1，此时获取引用计数的关联函数<code>Rc::strong_count</code>返回的值将是<code>2</code>。同理在赋值<code>c</code>的操作中也是如此。</p>
<p>需要注意的是，<code>Rc::clone(&amp;a)</code>只是克隆了智能指针<code>Rc&lt;List&gt;</code>，而没有克隆<code>a</code>指向的值<code>Cons(5, Rc::new(Cons(10, Rc::new(Nil))))</code>。简而言之这里的<code>Rc::clone(&amp;a)</code><strong>只是浅拷贝，而不是深拷贝</strong>，仅仅复制了智能指针并增加了引用计数，因此<code>a</code>、<code>b</code>、<code>c</code>都共享同一个值。</p>
<h3 id="观察引用计数的变化">观察引用计数的变化</h3>
<p>让我们接着上面的代码示例： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));  </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));     </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)); </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 该代码输出结果如下：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count after creating a = 1</span><br><span class="line">count after creating b = 2</span><br><span class="line">count after creating c = 3</span><br><span class="line">count after c goes out of scope = 2</span><br></pre></td></tr></table></figure> 通过上面的代码以及对应的输出，我们可以发现： -
由于变量<code>c</code>在语句块内部声明，当离开语句块时它会因为超出作用域而被释放，所以引用计数会减少<code>1</code>，事实上这个得益于<code>Rc&lt;T&gt;</code>实现了<code>Drop</code>特征
-
变量<code>a</code>、<code>b</code>、<code>c</code>三个智能指针引用计数都是同样的，并且共享底层的数据，因此打印计数时用哪个都行
-
无法看到的是：当<code>a</code>、<code>b</code>超出作用域后，引用计数会变成<code>0</code>，最终智能指针和它指向的底层字符串都会被清理释放</p>
<h3 id="使用rct的限制">使用<code>Rc&lt;T&gt;</code>的限制</h3>
<p>事实上，<code>Rc&lt;T&gt;</code>是指向底层数据的不可变的引用，因此你无法通过它来修改数据，这也符合Rust的借用规则：要么存在多个不可变借用，要么只能存在一个可变借用。</p>
<p>但是实际开发中我们往往需要对数据进行修改，这时单独使用<code>Rc&lt;T&gt;</code>无法满足我们的需求，需要配合其它数据类型来一起使用，例如内部可变性的<code>RefCell&lt;T&gt;</code>类型以及互斥锁<code>Mutex&lt;T&gt;</code>。事实上，在多线程编程中，<code>Arc</code>跟<code>Mutex</code>锁的组合使用非常常见，它们既可以让我们在不同的线程中共享数据，又允许在各个线程中对其进行修改。</p>
<h2 id="refcellt"><code>RefCell&lt;T&gt;</code></h2>
<p><code>RefCell&lt;T&gt;</code>是Rust标准库中的一个智能指针类型，它提供了内部可变性，允许在不可变引用的情况下修改数据。这种特性是的我们可以在编译时保证安全的情况下动态的借用和修改数据。</p>
<h3 id="主要特征">主要特征</h3>
<p><code>RefCell&lt;T&gt;</code>的主要特征如下： -
<code>RefCell&lt;T&gt;</code>使用动态借用检查，允许在运行时检查借用规则，而不是在编译时检查。同时，<code>RefCell&lt;T&gt;</code>需要遵循Rust的借用规则，在任何时刻，<code>RefCell&lt;T&gt;</code>只允许存在一个可变引用或多个不可变引用，否则就会导致编译错误.
-
<code>RefCell&lt;T&gt;</code>提供了内部可变性允许你在其拥有的<code>T</code>内部进行修改，即使<code>RefCell&lt;T&gt;</code>本身是不可变的，这是通过在运行时进行借用检查实现的。
- <code>borrow</code>和<code>borrow_mut</code>方法： -
<code>borrow</code>方法用于获取<code>RefCell&lt;T&gt;</code>的不可变引用，返回<code>Ref&lt;T&gt;</code>类型的智能指针，同一时间可以有多个不可变引用
-
<code>borrow_mut</code>方法用于获取<code>RefCell&lt;T&gt;</code>的可变引用，返回<code>RefMut&lt;T&gt;</code>类型的智能指针，同一时间只能有一个可变引用</p>
<h4 id="关键点">关键点</h4>
<p>借用规则： -
<code>RefCell&lt;T&gt;</code>在运行时检查借用规则，以防止数据竞争和未定义行为，编译器不进行这些检查。
运行时开销： -
由于<code>RefCell&lt;T&gt;</code>在运行时检查借用规则，因此会带来一定的性能开销。这在需要在编译时确定所有借用规则的场景中不可替代。
错误处理： -
在任何时刻，<code>RefCell&lt;T&gt;</code>只允许存在一个可变引用或多个不可变引用，否则<code>RefCell&lt;T&gt;</code>会在运行时引发<code>panic!</code>异常。</p>
<h3 id="使用场景">使用场景</h3>
<p><code>RefCell&lt;T&gt;</code>通常用于以下场景： - 数据结构：
在需要可变性但又受限于Rsut的所有权系统是，<code>RefCell</code>允许在数据结构中使用内部可变性。例如，实现需要共享但又需要修改的数据结构（如图、树等）
- 单线程环境：
<code>RefCell</code>在单线程环境中非常有效，因为它不涉及线程安全问题，可以提供高效的内部可变性。但如果我们需要在多线程环境中使用处理内部可变性，则需要使用<code>Mutex</code>或<code>RwLock</code>来替代。</p>
<h3 id="举个例子">举个例子</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">study</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">study</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 获取不可变引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref1</span> = value.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ref1: &#123;&#125;&quot;</span>, ref1); <span class="comment">// 输出: ref1: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取可变引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ref2</span> = value.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">    *ref2 += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ref2: &#123;&#125;&quot;</span>, ref2); <span class="comment">// 输出: ref2: 6</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再次获取不可变引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref3</span> = value.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ref3: &#123;&#125;&quot;</span>, ref3); <span class="comment">// 输出: ref3: 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们首先创建了一个<code>RefCell&lt;i32&gt;</code>类型的智能指针，并赋值给变量<code>value</code>。接着，我们使用<code>value.borrow()</code>方法获取了<code>value</code>的不可变引用，并赋值给变量<code>ref1</code>。然后，我们使用<code>value.borrow_mut()</code>方法获取了<code>value</code>的可变引用，并赋值给变量<code>ref2</code>。最后，我们再次使用<code>value.borrow()</code>方法获取了<code>value</code>的不可变引用，并赋值给变量<code>ref3</code>。
可以发现，代码成功运行，并且没有报错。</p>
<p>但我们再尝试运行以下代码： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skip</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ref3</span> = value.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;ref3: &#123;&#125;&quot;</span>, ref3);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ref4</span> = value.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">*ref4 += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;ref4: &#123;&#125;&quot;</span>, ref4);</span><br></pre></td></tr></table></figure> 此时代码会报错：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `value` as mutable because it is also borrowed as immutable</span><br></pre></td></tr></table></figure>
因为我们再一个作用域内同时获取了<code>value</code>的不可变引用和可变引用，因此报错。</p>
<h2 id="引用循环与内存泄漏">引用循环与内存泄漏</h2>
<p>在Rust中，引用计数<code>Rc&lt;T&gt;</code>和原子引用计数<code>Arc&lt;T&gt;</code>可以让多个所有者共享同一个数据。然而，这种共享机制如果使用不当，就会导致引用循环。引用循环（reference
cycle）会导致内存泄漏，因为<code>Rc&lt;T&gt;</code>无法检测到循环引用，因此无法释放内存，造成内存泄漏。</p>
<p>让我们来看一个引用循环的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    next : <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">node1</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">1</span>, next: <span class="literal">None</span> &#125;));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">node2</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">2</span>, next: <span class="literal">None</span> &#125;));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建引用循环</span></span><br><span class="line">    node1.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;node2));</span><br><span class="line">    node2.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;node1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印引用计数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;strong_count: &#123;:?&#125;, weak_count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;node1), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;node1));     <span class="comment">// 输出: strong_count: 2, weak_count: 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;strong_count: &#123;:?&#125;, weak_count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;node2), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;node2));     <span class="comment">// 输出: strong_count: 2, weak_count: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印节点值</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;node1: &#123;:?&#125;&quot;</span>, node1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;node2: &#123;:?&#125;&quot;</span>, node2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码示例中，我们创建了两个<code>Node</code>结构体，并使用<code>Rc&lt;RefCell&lt;Node&gt;&gt;</code>类型来共享它们。接着，我们创建了一个引用循环，使得<code>node1</code>和<code>node2</code>互相引用对方，从而导致了引用计数无法归零，最终内存泄漏。实际上，编译器并不知道<code>node1</code>和<code>node2</code>互相引用对方，因此无法在编译时报错，直到我们运行代码时，才会因为内存泄漏而报错。</p>
<p>那我们应该如何解决这个问题呢？</p>
<h2 id="weakt"><code>Weak&lt;T&gt;</code></h2>
<p><code>Weak&lt;T&gt;</code>是Rust标准库中的另一个智能指针类型，它提供了弱引用，允许在引用循环中打破循环引用。它的特点如下：
-
非所有权引用：<code>Weak&lt;T&gt;</code>并不拥有数据的所有权，它不会增加<code>Rc&lt;T&gt;</code>的引用计数
-
不会引发内存泄漏：<code>Weak&lt;T&gt;</code>不会增加<code>Rc&lt;T&gt;</code>的引用计数，因此不会引发内存泄漏
-
必须升级：<code>Weak&lt;T&gt;</code>无法直接访问它所引用的数据，必须先通过<code>Rc::upgrade</code>方法将其升级为<code>Rc&lt;T&gt;</code>。如果所引用的<code>Rc&lt;T&gt;</code>已经被释放，则<code>Rc::upgrade</code>会返回<code>None</code>。</p>
<p>那么，有了弱引用之后，我们就可以解决引用循环的问题了：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::rc::Weak;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    next: <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">    prev: <span class="type">Option</span>&lt;Weak&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">node1</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">1</span>, next: <span class="literal">None</span>, prev: <span class="literal">None</span> &#125;));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">node2</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(Node &#123; value: <span class="number">2</span>, next: <span class="literal">None</span>, prev: <span class="literal">None</span> &#125;));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建引用循环</span></span><br><span class="line">    node1.<span class="title function_ invoke__">borrow_mut</span>().next = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;node2));</span><br><span class="line">    node2.<span class="title function_ invoke__">borrow_mut</span>().prev = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">downgrade</span>(&amp;node1));  <span class="comment">// 使用Rc::downgrade(&amp;node1)创建一个弱引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印引用计数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;strong_count: &#123;:?&#125;, weak_count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;node1), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;node1));     <span class="comment">// 输出: strong_count: 1, weak_count: 1</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;strong_count: &#123;:?&#125;, weak_count: &#123;:?&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;node2), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;node2));     <span class="comment">// 输出: strong_count: 2, weak_count: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印节点值</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;node1: &#123;:?&#125;&quot;</span>, node1);     </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;node2: &#123;:?&#125;&quot;</span>, node2);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="强引用与弱引用的区别">强引用与弱引用的区别</h3>
<ol type="1">
<li>所有权：
<ul>
<li>强引用：强引用是所有权引用，拥有对象的所有权，保证数据在作用域内不会被释放。</li>
<li>弱引用：弱引用是非所有权引用，不拥有对象的所有权，不影响数据的生命周期。</li>
</ul></li>
<li>引用计数：
<ul>
<li>强引用：强引用会增加引用计数，数据被多个所有权共享。</li>
<li>弱引用：弱引用不会增加引用计数，不干扰<code>Rc&lt;T&gt;</code>的生命周期管理。</li>
</ul></li>
<li>内存管理：
<ul>
<li>强引用：只用当所有强引用都被丢弃，引用计数为0时，对象会被释放。</li>
<li>弱引用：只能通过升级（<code>Rc::upgrade</code>）来访问数据<code>Rc&lt;T&gt;</code>，如果所引用的数据<code>Rc&lt;T&gt;</code>已经被释放，则<code>Rc::upgrade</code>会返回<code>None</code>。</li>
</ul></li>
<li>使用场景：
<ul>
<li>强引用：通常用于需要共享数据所有权的场景，例如在多个部分之间共享数据，并确保数据在至少一个强引用存在时不会被释放。</li>
<li>弱引用：通常用于避免引用循环或只需要偶尔访问数据（不想持有所有权）的场景，例如在树结构中，父节点和子节点互相引用，形成循环引用，导致内存泄漏。</li>
</ul></li>
</ol>
<h2 id="课后作业">课后作业</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务：</span></span><br><span class="line"><span class="comment">// 实现一个简单的社交网络系统，包含用户和朋友关系，使用Rc&lt;T&gt;,RefCell&lt;T&gt;,Weak&lt;T&gt;来处理用户和朋友之间的关系，并避免循环引用导致的内存泄漏。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求：</span></span><br><span class="line"><span class="comment">// 用户结构：每个用户拥有一个名字和一个朋友列表。</span></span><br><span class="line"><span class="comment">// 添加朋友：支持在两个用户之间建立朋友关系。</span></span><br><span class="line"><span class="comment">// 展示朋友关系：能够展示每个用户的朋友列表。</span></span><br><span class="line"><span class="comment">// 循环引用：处理用户之间的双向引用，确保不产生循环引用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    friends: RefCell&lt;<span class="type">Vec</span>&lt;Weak&lt;User&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        User &#123;</span><br><span class="line">            name,</span><br><span class="line">            friends: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加朋友关系</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_friend</span>(user1: &amp;Rc&lt;User&gt;, user2: &amp;Rc&lt;User&gt;) &#123;</span><br><span class="line">        user1.friends.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(Rc::<span class="title function_ invoke__">downgrade</span>(user2));</span><br><span class="line">        user2.friends.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(Rc::<span class="title function_ invoke__">downgrade</span>(user1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示朋友列表</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">show_friends</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;的朋友列表:&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">friend</span> <span class="keyword">in</span> <span class="keyword">self</span>.friends.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(friend) = friend.<span class="title function_ invoke__">upgrade</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;- &#123;&#125;&quot;</span>, friend.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建用户</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">alice</span> = Rc::<span class="title function_ invoke__">new</span>(User::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bob</span> = Rc::<span class="title function_ invoke__">new</span>(User::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Bob&quot;</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">charlie</span> = Rc::<span class="title function_ invoke__">new</span>(User::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Charlie&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立朋友关系</span></span><br><span class="line">    User::<span class="title function_ invoke__">add_friend</span>(&amp;alice, &amp;bob);</span><br><span class="line">    User::<span class="title function_ invoke__">add_friend</span>(&amp;bob, &amp;charlie);</span><br><span class="line">    User::<span class="title function_ invoke__">add_friend</span>(&amp;alice, &amp;charlie);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示所有用户的朋友列表</span></span><br><span class="line">    alice.<span class="title function_ invoke__">show_friends</span>();</span><br><span class="line">    bob.<span class="title function_ invoke__">show_friends</span>();</span><br><span class="line">    charlie.<span class="title function_ invoke__">show_friends</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/23/rust-smart-pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/23/rust-smart-pointer/" class="post-title-link" itemprop="url">十六、Rust进阶-智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-23 22:53:58" itemprop="dateCreated datePublished" datetime="2024-10-23T22:53:58+08:00">2024-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-14 07:45:31" itemprop="dateModified" datetime="2024-11-14T07:45:31+08:00">2024-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="智能指针概述">智能指针概述</h2>
<p>在各个编程语言中，指针的概念几乎都是相同的：指针是一个包含了内存地址的变量，该内存地址引用或者指向了另外的数据。而在Rust中，最常见的指针类型就是<strong>引用</strong>。</p>
<p>而智能指针（Smart
Pointer）虽然也叫做指针，但是它实际上是一类<strong>数据结构</strong>，不仅包含一个指针，还附带一些额外的元数据和功能，与普通指针不同，智能指针在Rust中往往基于结构体实现，并且实现了<code>Deref</code>和<code>Drop</code>两个特征：
<code>Deref</code>可以让智能指针像引用那样工作，这样可以写出同时支持智能指针和引用的代码。
<code>Drop</code>允许智能指针在离开作用域时自动清理资源。</p>
<h2 id="为什么存在智能指针">为什么存在智能指针？</h2>
<p><strong>·资源管理</strong> 自动管理资源的分配和释放，避免内存泄漏
<strong>·所有权与借用</strong>
Rust的所有权系统通过智能指针来确保内存安全，避免数据竞争和悬垂指针
<strong>·复杂数据结构</strong>
通过智能指针可以构建复杂的数据结构，例如递归结构、共享数据等</p>
<h1 id="box-堆对象分配">Box<T> 堆对象分配</h1>
<p><code>Box&lt;T&gt;</code>是Rust中最常见的智能指针，它允许你将类型<code>T</code>的值分配在堆上，然后在栈上保留一个智能指针指向堆上的数据。当Box被销毁时，堆上的数据也会被销毁。</p>
<h2 id="box的底层实现">Box的底层实现</h2>
<p>·Box的底层原理
<code>Box&lt;T&gt;</code>是一个智能指针，内部包含一个指向堆上分配内存的裸指针。当<code>Box&lt;T&gt;</code>被销毁时，其Drop
trait会被调用，释放堆上的内存。 ·内存分配
Rust使用系统的全局分配器(<code>malloc</code>和<code>free</code>)来管理内存。
<code>Box::new</code>分配内存，<code>Drop</code>释放内存 ·安全性
Rust的所有权系统确保<code>Box&lt;T&gt;</code>的内存安全。当所有权发生转移时，堆内存的生命周期也会随之变化</p>
<h2 id="box的使用场景">Box的使用场景</h2>
<p>由于Box是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。而性能和功能往往是鱼和熊掌，因此Box相比其它智能指针，功能较为单一，可以在以下场景中使用它：</p>
<p>·特意的将数据分配在堆上 ·数据较大时，又不想在转移所有权时进行数据拷贝
·类型的大小在编译期无法确定，但是我们又需要固定大小的类型时
·特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</p>
<h3
id="使用boxt将数据存储在堆上">使用<code>Box&lt;T&gt;</code>将数据存储在堆上</h3>
<p>Box最常见的用途是将数据分配在堆上而非栈上，这在处理较大的数据结构或数据结构的大小在编译时不确定的情况下尤为重要：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a); <span class="comment">// a = 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面一行代码将报错</span></span><br><span class="line">    <span class="comment">// let b = a + 1; // cannot add `&#123;integer&#125;` to `Box&lt;&#123;integer&#125;&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="处理动态大小类型dst">处理动态大小类型（DST）</h3>
<p>Rust需要在编译时知道类型占用多少空间，如果一种类型在编译时无法知道具体的大小，那么被称为动态大小类型DST。Box允许我们处理动态大小的类型，如<code>str</code>和<code>[T]</code>：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;Hello,world!&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;s&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: <span class="type">Box</span>&lt;[<span class="type">i32</span>]&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].<span class="title function_ invoke__">into_boxed_slice</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;arr = &#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="递归数据结构">递归数据结构</h3>
<p>其中另一种无法在编译时知道大小的类型是<strong>递归类型</strong>：它在类型定义中又使用到了自身，或者说该类型的值的一部分可以是相同类型的其它值，这种值的嵌套理论上可以无限进行下去，所以
Rust 不知道递归类型需要多少空间： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的例子中就是函数式语言中常见的<code>Cons List</code>，它的每个节点包含一个<code>i32</code>值，还包含了一个新的<code>List</code>，因此这种嵌套可以无限进行下去，Rust认为该类型是一个DST类型，并给予报错：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0072]: recursive type `List` has infinite size //递归类型 `List` 拥有无限长的大小</span><br><span class="line"> --&gt; src/main.rs:3:1</span><br><span class="line">  |</span><br><span class="line">3 | enum List &#123;</span><br><span class="line">  | ^^^^^^^^^ recursive type has infinite size</span><br><span class="line">4 |     Cons(i32, List),</span><br><span class="line">  |               ---- recursive without indirection</span><br></pre></td></tr></table></figure></p>
<p>如果想要解决这个问题，我们可以使用智能指针类型来引用自身：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，我们将<code>List</code>存储到了堆上，并且使用一个智能指针指向它，完成了从DST到Sized类型（固定大小类型）的转变。</p>
<h3 id="类型擦除">类型擦除</h3>
<p>在 Rust
中，想实现不同类型组成的数组只有两个办法：枚举和特征对象，前者限制较多，因此后者往往是最常用的解决办法，而<code>Box&lt;dyn Trait&gt;</code>可以用于类型擦除，允许在运行时决定类型：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">speak</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cat</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">speak</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Woo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">speak</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Meow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">animals</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Animal&gt;&gt; = <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Dog), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Cat)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">animal</span> <span class="keyword">in</span> animals.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        animal.<span class="title function_ invoke__">speak</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，我们使用了<code>Box&lt;dyn Animal&gt;</code>的智能指针类型，来把<code>Dog</code>和<code>Cat</code>都塞进了<code>animals</code>的向量中。</p>
<h4 id="dyn解释"><code>dyn</code>解释</h4>
<p><code>dyn</code>关键字用于指定动态分发的类型，它允许在运行时决定具体类型。在Rust中，<code>dyn</code>关键字用于实现动态分发的<code>trait</code>对象。</p>
<h3 id="内存管理和性能优化">内存管理和性能优化</h3>
<p>通过使用Box，可以控制内存的分配和释放，从而优化性能和内存使用。例如，将大型数据结构放在堆上，而不是栈上，可以减少栈的使用量，从而避免<strong>栈溢出</strong>：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">large_array</span>: <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">0u8</span>; <span class="number">1_000_000</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Large array allocated on the heap.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="box的优缺点">Box的优缺点</h2>
<p><strong>·优点</strong> 提供堆内存分配，支持复杂数据结构
与Rust的所有权系统完美集成，确保内存安全 动态分配对象，实现类型擦除</p>
<p><strong>·缺点</strong> 需要堆内存分配和释放，可能带来性能开销
不适合需要频繁分配和释放的场景</p>
<h2 id="drop和deref">Drop和Deref</h2>
<h3 id="drop">Drop</h3>
<p><code>Drop</code>trait用于自定义当值离开作用域时执行的代码，通常用于释放资源（例如内存、文件句柄、网络连接等）。
<code>Drop</code>trait定义了一个drop方法，当值被释放时，Rust会自动调用这个方法：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Drop</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="deref">Deref</h3>
<p><code>Deref</code>
trait用于重载解引用运算符（*），它允许你自定义指针类型的解引用行为。
<code>Deref</code>
trait定义了一个deref方法，该方法返回指向目标类型的引用：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Deref</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span>: ?Size;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面再举一个例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">use::ste::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mybox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Mybox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> Mybox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">Mybox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Mybox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        <span class="title function_ invoke__">println</span>(<span class="string">&quot;deref called!&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = Mybox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 最终输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deref called!</span><br><span class="line">y = 5</span><br></pre></td></tr></table></figure></p>
<h3 id="derefmut">DerefMut</h3>
<p>与<code>Deref</code>相似，<code>DerefMut</code>用于重载可变解引用运算符（*），允许对自定义类型进行可变解引用：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">DerefMut</span>: Deref &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="课后作业">课后作业</h2>
<p><img src="/images/16-1.png" alt="" width="1000"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stack_alloc_start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>; <span class="number">1_000_000</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stack_alloc_duration</span> = stack_alloc_start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heap_alloc_start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr_box</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">1</span>; <span class="number">1_000_000</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heap_alloc_duration</span> = heap_alloc_start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stack_access_start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;arr &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stack_access_duration</span> = stack_access_start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heap_access_start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// arr_box.iter() 返回一个迭代器,不能使用for i in &amp;arr_box</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;*arr_box &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heap_access_duration</span> = heap_access_start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Stack allocation duration: &#123;:?&#125;&quot;</span>, stack_alloc_duration);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Heap allocation duration: &#123;:?&#125;&quot;</span>, heap_alloc_duration);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Stack access duration: &#123;:?&#125;&quot;</span>, stack_access_duration);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Heap access duration: &#123;:?&#125;&quot;</span>, heap_access_duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">File</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Folder</span>(FolderNode),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_file</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: &amp;<span class="type">str</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_folder</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: &amp;<span class="type">str</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">list_contents</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FolderNode</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    contents: HashMap&lt;<span class="type">String</span>, <span class="type">Box</span>&lt;Node&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FileSystem</span> <span class="keyword">for</span> <span class="title class_">FolderNode</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_file</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.contents.<span class="title function_ invoke__">insert</span>(path.<span class="title function_ invoke__">to_string</span>(), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">File</span>(path.<span class="title function_ invoke__">to_string</span>())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_folder</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.contents.<span class="title function_ invoke__">insert</span>(</span><br><span class="line">            path.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                Node::<span class="title function_ invoke__">Folder</span>( FolderNode</span><br><span class="line">                    &#123;</span><br><span class="line">                    name: path.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">                    contents: HashMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">list_contents</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents_list</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (name, node) <span class="keyword">in</span> &amp;<span class="keyword">self</span>.contents &#123;</span><br><span class="line">            <span class="keyword">match</span> node.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">                Node::<span class="title function_ invoke__">File</span>(file) =&gt; contents_list.<span class="title function_ invoke__">push</span>(file.<span class="title function_ invoke__">clone</span>()),</span><br><span class="line">                Node::<span class="title function_ invoke__">Folder</span>(folder) =&gt; &#123;</span><br><span class="line">                    contents_list.<span class="title function_ invoke__">push</span>(folder.name.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">sub_contents</span> = folder.<span class="title function_ invoke__">list_contents</span>();</span><br><span class="line">                    <span class="comment">// 将子文件夹内容路径化</span></span><br><span class="line">                    <span class="keyword">for</span> <span class="variable">sub_item</span> <span class="keyword">in</span> sub_contents &#123;</span><br><span class="line">                        contents_list.<span class="title function_ invoke__">push</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;/&#123;&#125;&quot;</span>, name, sub_item));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        contents_list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display_list_as_tree</span>(contents_list: &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> contents_list &#123;</span><br><span class="line">        <span class="comment">// 计算当前路径中的层级，通过&#x27;/&#x27;分割来确定缩进层次</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">level</span> = item.<span class="title function_ invoke__">matches</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_ invoke__">count</span>();</span><br><span class="line">        <span class="comment">// 添加适当数量的空格来表示缩进</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">indent</span> = <span class="string">&quot;  &quot;</span>.<span class="title function_ invoke__">repeat</span>(level);</span><br><span class="line">        result.<span class="title function_ invoke__">push_str</span>(&amp;<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;\n&quot;</span>, indent, item.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">root</span> = FolderNode &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;root&quot;</span>),</span><br><span class="line">        contents: HashMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    root.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;file1.txt&quot;</span>);</span><br><span class="line">    root.<span class="title function_ invoke__">create_folder</span>(<span class="string">&quot;folder1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(folder) = root.contents.<span class="title function_ invoke__">get_mut</span>(<span class="string">&quot;folder1&quot;</span>) &#123;    <span class="comment">//get_mut()是HashMap的方法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Node</span>::<span class="title function_ invoke__">Folder</span>(folder1) = folder.<span class="title function_ invoke__">as_mut</span>() &#123;    <span class="comment">//使用as_mut()获取Box&lt;T&gt;中的T</span></span><br><span class="line">            folder1.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;file2.txt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Contents: &#123;:?&#125;&quot;</span>, root.<span class="title function_ invoke__">list_contents</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">display_list_as_tree</span>(&amp;root.<span class="title function_ invoke__">list_contents</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/22/rust-module-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/22/rust-module-system/" class="post-title-link" itemprop="url">十五、Rust基础-模块化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-22 21:21:27" itemprop="dateCreated datePublished" datetime="2024-10-22T21:21:27+08:00">2024-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-23 08:11:46" itemprop="dateModified" datetime="2024-10-23T08:11:46+08:00">2024-10-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模块化">模块化</h1>
<p>我们首先从以下四个名词出发来了解Rust中的模块：</p>
<h1 id="项目package">项目Package</h1>
<p>在Rust中，由于Rust团队标新立异的起名传统，以及包的名称被<code>crate</code>占用，库的名称被<code>library</code>占用，经过斟酌，
我们决定将<code>Package</code>翻译成项目，你也可以理解为工程、软件包。
由于<code>Package</code>就是一个项目，因此它包含有独立的<code>Cargo.toml</code>文件，以及因为功能性被组织在一起的一个或多个包。一个<code>Package</code>只能包含一个库(library)类型的包，但是可以包含多个二进制可执行类型(binary
crates)的包。</p>
<h1 id="包crate">包Crate</h1>
<p>对于Rust而言，包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库。</p>
<p>一个包会将相关联的功能打包在一起，使得该功能可以很方便的在多个项目中分享。例如标准库中没有提供但是在三方库中提供的<code>rand</code>包，它提供了随机数生成的功能，我们只需要将该包通过<code>use rand</code>;
引入到当前项目的作用域中，就可以在项目中使用<code>rand</code>的功能：<code>rand::XXX</code>。</p>
<p>同一个包中不能有同名的类型，但是在不同包中就可以。例如，虽然<code>rand</code>包中，有一个<code>Rng</code>特征，可是我们依然可以在自己的项目中定义一个<code>Rng</code>，前者通过<code>rand::Rng</code>访问，后者通过<code>Rng</code>访问，对于编译器而言，这两者的边界非常清晰，不会存在引用歧义。</p>
<h2 id="二进制package">二进制Package</h2>
<p>我们可以通过如下命令来创建一个二进制<code>Package</code>：
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-project</span><br><span class="line">     Created binary (application) `my-project` package</span><br><span class="line">$ <span class="built_in">ls</span> my-project</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ <span class="built_in">ls</span> my-project/src</span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>
这里，<code>Cargo</code>为我们创建了一个名称是<code>my-project</code>的<code>Package</code>，同时在其中创建了<code>Cargo.toml</code>文件，可以看一下该文件，里面并没有提到<code>src/main.rs</code>作为程序的入口，原因是<code>Cargo</code>有一个惯例：<code>src/main.rs</code>是二进制包的根文件，该二进制包的包名跟所属<code>Package</code>相同，在这里都是<code>my-project</code>，所有的代码执行都从该文件中的<code>fn main()</code>函数开始。</p>
<p>使用<code>cargo run</code>可以运行该项目，输出：<code>Hello, world!</code>。</p>
<h2 id="库package">库Package</h2>
<p>再来创建一个库类型的<code>Package</code>: <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-lib --lib</span><br><span class="line">     Created library `my-lib` package</span><br><span class="line">$ ls my-lib</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ ls my-lib/src</span><br><span class="line">lib.rs</span><br></pre></td></tr></table></figure>
首先，如果你试图运行<code>my-lib</code>，会报错： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">error: a bin target must be available <span class="keyword">for</span> `cargo run`</span><br></pre></td></tr></table></figure>
原因是库类型的<code>Package</code>只能作为三方库被其它项目引用，而不能使用<code>Cargo run</code>等命令独立运行，只有之前的二进制<code>Package</code>才可以运行。</p>
<p>与<code>src/main.rs</code>一样，<code>Cargo</code>知道，如果一个<code>Package</code>包含有<code>src/lib.rs</code>，意味它包含有一个库类型的同名包<code>my-lib</code>，该包的根文件是<code>src/lib.rs</code>。</p>
<h2 id="易混淆的package和包">易混淆的Package和包</h2>
<p>看完上面，相信大家看出来为何<code>Package</code>和包容易被混淆了吧？因为你用<code>cargo new</code>创建的<code>Package</code>和它其中包含的包是同名的！</p>
<p>不过，只要你牢记<code>Package</code>是一个项目工程，而包只是一个编译单元，也就不会再混淆这两个概念<code>src/main.rs</code>和<code>src/lib.rs</code>都是编译单元，因此它们都是包。</p>
<h2 id="典型的package结构">典型的Package结构</h2>
<p>上面创建的<code>Package</code>中仅包含<code>src/main.rs</code>文件，意味着它仅包含一个二进制同名包<code>my-project</code>。如果一个<code>Package</code>同时拥有<code>src/main.rs</code>和<code>src/lib.rs</code>，那就意味着它包含两个包：库包和二进制包，这两个包名也都是<code>my-project</code>——
都与<code>Package</code>同名。</p>
<p>一个真实项目中典型的<code>Package</code>，会包含多个二进制包，这些包文件被放在<code>src/bin</code>目录下，每一个文件都是独立的二进制包，同时也会包含一个库包，该包只能存在一个<code>src/lib.rs</code>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── src</span><br><span class="line">│   ├── main.rs</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   └── bin</span><br><span class="line">│       └── main1.rs</span><br><span class="line">│       └── main2.rs</span><br><span class="line">├── tests</span><br><span class="line">│   └── some_integration_tests.rs</span><br><span class="line">├── benches</span><br><span class="line">│   └── simple_bench.rs</span><br><span class="line">└── examples</span><br><span class="line">    └── simple_example.rs</span><br></pre></td></tr></table></figure> ·唯一库包：<code>src/lib.rs</code>
·默认二进制包：<code>src/main.rs</code>，编译后生成的可执行文件与<code>Package</code>同名
·其余二进制包：<code>src/bin/main1.rs</code>和<code>src/bin/main2.rs</code>，它们会分别生成一个文件同名的二进制可执行文件。
·集成测试文件：<code>tests</code>目录下
·基准性能测试<code>benchmark</code>文件：<code>benches</code>目录下
·项目示例：<code>examples</code>目录下</p>
<p>这种目录结构基本上是Rust的标准目录结构，在GitHub的大多数项目上，你都将看到它的身影。</p>
<h1 id="模块module">模块Module</h1>
<p>在这里，我们将讨论Rust的代码构成单元：模块。使用模块可以将包中的代码按照功能性进行重组，最终实现更好的可读性及易用性。同时，我们还能非常灵活地去控制代码的可见性，进一步强化Rust的安全性。</p>
<h2 id="创建嵌套模块">创建嵌套模块</h2>
<p>在Rust中，我们可以通过<code>mod</code>关键字来创建新模块：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 餐厅前厅，用于吃饭</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 以上的代码创建了三个模块，有几点需要注意的：</p>
<p>·使用<code>mod</code>关键字来创建新模块，后面紧跟着模块名称
·模块可以嵌套，这里嵌套的原因是招待客人和服务都发生在前厅，因此我们的代码模拟了真实场景
·模块中可以定义各种Rust类型，例如函数、结构体、枚举、特征等
·所有模块均定义在同一个文件中</p>
<p>类似上述代码中所做的，使用模块，我们就能将功能相关的代码组织到一起，然后通过一个模块名称来说明这些代码为何被组织在一起。这样其它程序员在使用你的模块时，就可以更快地理解和上手。</p>
<h2 id="模块树">模块树</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure>
<p>这颗树展示了模块之间彼此的嵌套关系，因此被称为模块树。其中<code>crate</code>包根是<code>src/lib.rs</code>文件，包根文件中的三个模块分别形成了模块树的剩余部分。</p>
<h3 id="父子模块">父子模块</h3>
<p>如果模块<code>A</code>包含模块<code>B</code>，那么<code>A</code>是<code>B</code>的父模块，<code>B</code>是<code>A</code>的子模块。在上例中，<code>front_of_house</code>是<code>hosting</code>和<code>serving</code>的父模块，反之，后两者是前者的子模块。</p>
<h2 id="用路径引用模块">用路径引用模块</h2>
<p>想要调用一个函数，我们就需要知道它的路径，在Rust中，这种路径有两种形式：
·
<strong>绝对路径</strong>，从包根开始，路径名以包名或者<code>crate</code>开头
·
<strong>相对路径</strong>，从当前模块开始，以<code>self</code>、<code>super</code>或当前模块的标识符作为开头</p>
<p>让我们继续上面的代码示例： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="绝对路径引用">绝对路径引用</h3>
<p>在上面的例子中，由于<code>eat_at_restaurant</code>和<code>add_to_waitlist()</code>都定义在一个包（crate）中，因此在使用绝对路径引用时，可以直接用<code>crate</code>开头，随后逐层引用，每一层之间以<code>::</code>分隔：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crate::front_of_house::hosting::add_to_waitlist();</span><br></pre></td></tr></table></figure></p>
<h3 id="相对路径引用">相对路径引用</h3>
<p>由于<code>eat_at_restaurant</code>和<code>add_to_waitlist()</code>都定义在一个包（crate）中，因此相对路径引用可以使用<code>front_of_house</code>作为开头：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">front_of_house::hosting::add_to_waitlist();</span><br></pre></td></tr></table></figure> #### 使用super引用模块
<code>super</code>代表的是父模块为开始的引用方式，非常类似于文件系统中的<code>..</code>语法：<code>../a/b</code></p>
<p>让我们来看下面的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 厨房模块</span></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
在上面的例子中，我们使用<code>super::serve_order()</code>语法，调用了父模块中的<code>serve_order</code>函数
#### 使用self引用模块
<code>self</code>其实就是引用自身模块中的项，也就是说和我们之前章节的代码类似，都调用同一模块中的内容，区别在于之前章节中直接通过名称调用即可，而<code>self</code>，你得多此一举：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;</span><br><span class="line">    self::back_of_house::<span class="title function_ invoke__">cook_order</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        crate::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的例子中，实际上我们完全可以使用<code>back_of_house::cook_order()</code>来直接跳用函数，但是<code>self</code>在接下来还有一个大用处。</p>
<h2 id="代码可见性">代码可见性</h2>
<p>让我们运行下面的代码： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在运行<code>cargo bulid</code>编译此库类型的 Package，意料之外的报错了：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line"> --&gt; src/lib.rs:9:28</span><br><span class="line">  |</span><br><span class="line">9 |     crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line">  |                            ^^^^^^^ private module</span><br></pre></td></tr></table></figure>
错误信息提示我们:<code>hosting</code>模块是私有的，无法在包根进行访问，那么为何<code>front_of_house</code>模块就可以访问？因为它和<code>eat_at_restaurant</code>同属于一个包根作用域内，同一个模块内的代码自然不存在私有化问题.</p>
<p>Rust出于安全的考虑，默认情况下，所有的类型都是私有化的，包括函数、方法、结构体、枚举、常量，是的，就连模块本身也是私有化的。在中国，父亲往往不希望孩子拥有小秘密，但是在Rust中，父模块完全无法访问子模块中的私有项，但是子模块却可以访问父模块、父父..模块的私有项。</p>
<h3 id="pub关键字">pub关键字</h3>
<p>在Rust中提供了<code>pub</code>关键字，通过它你可以控制模块和模块中指定项的可见性。如果我们想要修复上面的报错，按道理只需要将<code>hosting</code>模块标记为对外可见即可：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--- snip ----*/</span></span><br></pre></td></tr></table></figure> 但不幸的是，在执行上述代码时，又发生了报错：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error[E0603]: function `add_to_waitlist` is private</span><br><span class="line">  --&gt; src/lib.rs:12:30</span><br><span class="line">   |</span><br><span class="line">12 |     front_of_house::hosting::add_to_waitlist();</span><br><span class="line">   |                              ^^^^^^^^^^^^^^^ private function</span><br></pre></td></tr></table></figure>
通过报错信息，我们可以发现，编译器提示我们还需要对函数<code>add_to_waitlist</code>标记为可见。
是的，没错，模块可见性不代表模块内部项的可见性，模块的可见性仅仅是允许其它模块去引用它，但是想要引用它内部的项，还得继续将对应的项标记为<code>pub</code>。</p>
<p>因此，既然知道了如何解决，那么我们为函数也标记上<code>pub</code>：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--- snip ----*/</span></span><br></pre></td></tr></table></figure>
值得注意的是，如果需要在模块内部调用函数，那么不需要为使用<code>pub</code>关键字将调用的函数标记为对外可见。</p>
<h2 id="使用use引入模块">使用use引入模块</h2>
<p>在上面，我们使用绝对路径和相对路径引入了模块中的函数。但是如果我们需要调用的函数数量增加，或者某些函数在模块中嵌套及其深时，我们就需要换一种方式来引入函数或模块：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting::add_to_waitlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的例子中，我们使用<code>use</code>和相对路径的方式，直接引入了该模块中的<code>add_to_waitlist</code>函数。通过该方法，我们简化了函数的调用过程。</p>
<h3 id="思考引入函数还是引入模块">思考引入函数还是引入模块</h3>
<p>从使用简洁性来说，引入函数自然是更甚一筹，但是在某些时候，引入模块会更好：
·需要引入同一个模块的多个函数 ·作用域中存在同名函数</p>
<h2 id="避免同名引用">避免同名引用</h2>
<p>有时候，我们会发现模块之间、包之间会存在同名。此时，遇到同名的情况我们应该如何处理呢？</p>
<h3 id="模块函数">模块::函数</h3>
<p>让我们来看下面的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的例子给出了很好的解决方案，使用模块引入的方式，具体的 Result 通过
模块::Result 的方式进行调用。</p>
<p>可以看出，避免同名冲突的关键，就是使用父模块的方式来调用，除此之外，还可以给予引入的项起一个别名。</p>
<h3 id="as别名引用">as别名引用</h3>
<p>对于同名冲突问题，还可以使用<code>as</code>关键字来解决，它可以赋予引入项一个全新的名称：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如上所示，首先通过<code>use std::io::Result</code>将<code>Result</code>引入到作用域，然后使用<code>as</code>给予它一个全新的名称<code>IoResult</code>，这样就不会再产生冲突：
·<code>Result</code>代表<code>std::fmt::Result</code>
·<code>IoResult</code>代表<code>std:io::Result</code></p>
<h3 id="使用简化引入方式">使用{}简化引入方式</h3>
<p>对于一下一行一行的引入方式： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br></pre></td></tr></table></figure>
可以使用<code>&#123;&#125;</code>来一起引入进来，在大型项目中，使用这种方式来引入，可以减少大量<code>use</code>的使用：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::&#123;HashMap,BTreeMap,HashSet&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于下面的同时引入模块和模块中的项： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br></pre></td></tr></table></figure>
我们也可以使用<code>&#123;&#125;</code>的方式来进行简化： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="受限的可见性">受限的可见性</h2>
<p>· <strong>private(default)</strong> · <strong>pub(crate)</strong>
在当前的crate中可见 还有pub(self)、pub(super) · <strong>pub(in
path)</strong> 例如pub(in crate::a),只在模块a中可见</p>
<h2 id="引入项再导出">引入项再导出</h2>
<p>当外部的模块项<code>A</code>被引入到当前模块中时，它的可见性自动被设置为私有的，如果你希望允许其它外部代码引用我们的模块项<code>A</code>，那么可以对它使用<code>pub use</code>进行再导出：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如上，使用<code>pub use</code>即可实现。这里<code>use</code>代表引入<code>hosting</code>模块到当前作用域，<code>pub</code>表示将该引入的内容再度设置为可见。</p>
<p>当你希望将内部的实现细节隐藏起来或者按照某个目的组织代码时，可以使用<code>pub use</code>再导出，例如统一使用一个模块来提供对外的API，那该模块就可以引入其它模块中的API，然后进行再导出，最终对于用户来说，所有的API都是由一个模块统一提供的。</p>
<h2 id="使用第三方包">使用第三方包</h2>
<p>之前我们一直在引入标准库模块或者自定义模块。但是当我们的项目越来越大时，一个lib
crate无法支撑，此时我们需要引入下第三方包中的模块： 1.
修改<code>Cargo.toml</code>文件，在<code>[dependencies]</code>区域添加一行：<code>rand = "0.8.3"</code>
2.
此时，如果你用的是VSCode和rust-analyzer插件，该插件会自动拉取该库，你可能需要等它完成后，再进行下一步（VSCode
左下角有提示） 3.
此时，<code>rand</code>包已经被我们添加到依赖中，我们可以在代码中使用</p>
<p>同时，<code>Cargo</code>还支持我们在<code>Cargo.toml</code>中自己在<code>workspace</code>中手动添加一些自己创建的依赖。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/22/rust-return-value-and-error-handling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/22/rust-return-value-and-error-handling/" class="post-title-link" itemprop="url">十四、Rust基础-返回值与错误处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-22 11:52:10" itemprop="dateCreated datePublished" datetime="2024-10-22T11:52:10+08:00">2024-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-24 03:10:58" itemprop="dateModified" datetime="2024-10-24T03:10:58+08:00">2024-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="匹配option">匹配<code>Option</code></h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="title function_ invoke__">Some</span>(x+<span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="option">Option</h1>
<h2 id="optiont的辅助函数"><code>Option&lt;T&gt;</code>的辅助函数</h2>
<p>关于<code>Option</code>的所有辅助函数，我们可以在Rust<a
target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/index.html">官方文档</a>中进行查阅。下面列举几个常用的函数。</p>
<h3 id="使用unwarp">使用<code>unwarp()</code></h3>
<p>如果我们确定<code>Option</code>中一定存在值，可以使用<code>unwrap</code>方法直接获取值。反之，如果<code>Option</code>类型的值是<code>None</code>，就会直接触发<code>panic!</code>。
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">pop</span>();    <span class="comment">//返回Some（“h”）</span></span><br><span class="line">    s.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwarp</span>();   <span class="comment">//返回&quot;h&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3
id="使用is_some和is_none">使用<code>is_some</code>和<code>is_none</code></h3>
<p>我们可以通过使用<code>is_some</code>和<code>is_none</code>方法来判断一个<code>Option</code>中是否存在值。
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">10</span>,<span class="number">40</span>,<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">if</span> v.<span class="title function_ invoke__">get</span>(<span class="number">1</span>).<span class="title function_ invoke__">is_some</span>() &#123;     <span class="comment">//使用is_some()判断是否存在值</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3
id="使用unwrap_or来提供默认值">使用<code>unwrap_or()</code>来提供默认值</h3>
<p>我们在使用<code>unwrap</code>方法获取<code>Option</code>中值的时候，如果为<code>None</code>，则会直接触发<code>panic!</code>。实际上，Rust为我们提供了另一种方法<code>unwrap_or</code>，它可以在<code>None</code>时返回我们所设定的默认值：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">div</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b!= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">div</span>(a,b).<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0.0</span>);   <span class="comment">//返回0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="错误处理">错误处理</h1>
<p>Rust 中的错误主要分为两类：
<strong>可恢复错误</strong>，通常用于从系统全局角度来看可以接受的错误，例如处理用户的访问、操作等错误，这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响。
<strong>不可恢复错误</strong>，刚好相反，该错误通常是全局性或者系统性的错误，例如数组越界访问，系统启动时发生了影响启动流程的错误等等，这些错误的影响往往对于系统来说是致命的。
很多编程语言，并不会区分这些错误，而是直接采用异常的方式去处理。Rust
没有异常，<code>Result&lt;T, E&gt;</code>用于可恢复错误，<code>panic!</code>用于不可恢复错误。</p>
<h2 id="被动触发">被动触发</h2>
<p>让我们先来看一段简单的代码： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果有过C语言的经验，即使你越界了，问题不大，我依然尝试去访问，至于这个值是不是你想要的（<code>100</code>号内存地址也有可能有值，只不过是其它变量或者程序的！），抱歉，不归我管，我只负责取，你要负责管理好自己的索引访问范围。上面这种情况被称为<strong>缓冲区溢出</strong>，并可能会导致安全漏洞，例如攻击者可以通过索引来访问到数组后面不被允许的数据。
而在Rust中，为了保护程序远离这些漏洞，如果尝试读取一个索引不存在的元素，Rust会停止执行并拒绝继续，直接抛出<code>panic!</code>.</p>
<h2 id="主动调用">主动调用</h2>
<p>在某些特殊场景中，开发者想要主动抛出一个异常，例如开头提到的在系统启动阶段读取文件失败。</p>
<p>对此，Rust为我们提供了<code>panic!</code>宏，当调用执行该宏时，程序会打印出一个错误信息，<strong>展开报错点往前的函数调用堆栈，最后退出程序</strong>。例如如下示例：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 运行后输出: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;crash and burn&#x27;, src/main.rs:2:5</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure></p>
<h2 id="backtrace-栈展开">backtrace 栈展开</h2>
<p>在上面代码抛出的异常中，编译器提醒我们<code>run with</code>RUST_BACKTRACE=1<code>environment variable to display a backtrace</code>。这就是Rust为我们提供的栈展开技术。在真实场景中，错误往往涉及到很长的调用链甚至会深入第三方库，如果没有栈展开技术，错误将难以跟踪处理。
让我们看下面一个真实的崩溃例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此时我们如果使用<code>RUST_BACKTRACE=1 cargo run</code>运行程序，会得到如下输出：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 3 but the index is 99&#x27;, src/main.rs:4:5</span><br><span class="line">stack backtrace:</span><br><span class="line">   0: rust_begin_unwind</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5</span><br><span class="line">   1: core::panicking::panic_fmt</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14</span><br><span class="line">   2: core::panicking::panic_bounds_check</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5</span><br><span class="line">   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10</span><br><span class="line">   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9</span><br><span class="line">   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9</span><br><span class="line">   6: world_hello::main</span><br><span class="line">             at ./src/main.rs:4:5</span><br><span class="line">   7: core::ops::function::FnOnce::call_once</span><br><span class="line">             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5</span><br><span class="line">note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.</span><br></pre></td></tr></table></figure>
上面的代码就是一次<strong>栈展开</strong>（也称栈回溯），它包含了函数调用的顺序，当然按照逆序排列：最近调用的函数排在列表的最上方。因为咱们的<code>main</code>函数基本是最先调用的函数了，所以排在了倒数第二位，还有一个关注点，排在最顶部最后一个调用的函数是<code>rust_begin_unwind</code>，该函数的目的就是进行栈展开，呈现这些列表信息给我们。</p>
<p>要获取到栈回溯信息，你还需要开启<code>debug</code>标志，该标志在使用<code>cargo run</code>或者<code>cargo build</code>时自动开启（这两个操作默认是<code>Debug</code>运行方式）。同时，栈展开信息在不同操作系统或者Rust版本上也有所不同。</p>
<h2 id="panic-时的两种中止方式">panic 时的两种中止方式</h2>
<p>无论是主动调用还是被动触发，在出现<code>panic!</code>时，Rust为我们提供了两种方式来处理终止流程：<strong>栈展开</strong>（unwinding）和<strong>直接终止</strong>(abort)</p>
<p>其中，默认的方式就是栈展开，这意味着Rust会回溯栈上数据和函数调用，因此也意味着更多的善后工作，好处是可以给出充分的报错信息和栈调用信息，便于事后的问题复盘。
直接终止，顾名思义，不清理数据就直接退出程序，善后工作交与操作系统来负责。</p>
<p>对于绝大多数用户，使用默认选择是最好的，但是当你关心最终编译出的二进制可执行文件大小时，那么可以尝试去使用直接终止的方式，例如下面的配置修改<code>Cargo.toml</code>文件，实现在<code>release</code>模式下遇到<code>panic</code>直接终止：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic = <span class="symbol">&#x27;abort</span>&#x27;</span><br></pre></td></tr></table></figure></p>
<h1 id="可恢复的错误-result">可恢复的错误 Result</h1>
<p>大部分错误并没有严重到需要程序完全停止执行。有时候，一个函数失败仅仅是因为一个容易理解和响应的原因。例如：如果因为打开一个并不存在的文件而失败，此时我们可能想要创建这个文件，而并不是终止进程。此时，我们就可以使用<code>Result</code>来处理这种可恢复的错误。
之前章节提到过，<code>Result&lt;T, E&gt;</code>是一个枚举类型：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
泛型参数<code>T</code>代表成功时存入的正确值的类型，存放方式是<code>Ok(T)</code>，<code>E</code>代表错误时存入的错误值，存放方式是<code>Err(E)</code>。</p>
<p>让我们来看下面一个代码示例： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MathError</span> &#123;</span><br><span class="line">    DivisionByZero,</span><br><span class="line">    NegativeSquareRoot,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">div</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, MathError&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b!= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MathError::DivisionByZero)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">div</span>(a,b).<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0.0</span>);   <span class="comment">//返回0.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sqrt</span>(a:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, MathError&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MathError::NegativeSquareRoot)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a.<span class="title function_ invoke__">sqrt</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码示例中，我们通过定义了一个<code>MathError</code>的枚举，使得我们进行错误运算时的返回值更加简洁易懂，也更方便管理。</p>
<h2 id="对返回的错误进行处理">对返回的错误进行处理</h2>
<p>我们以标准库中对于文件的操作作为示例： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,   <span class="comment">//返回文件句柄</span></span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面代码在匹配出<code>error</code>后，又对<code>error</code>进行了详细的匹配解析，最终结果：
·
如果是文件不存在错误<code>ErrorKind::NotFound</code>，就创建文件，这里创建文件<code>File::create</code>也是返回<code>Result</code>，因此继续用<code>match</code>对其结果进行处理：创建成功，将新的文件句柄赋值给<code>f</code>，如果失败，则
panic。 · 剩下的错误，一律<code>panic</code>。</p>
<h2
id="resultt-e的辅助方法"><code>Result&lt;T, E&gt;</code>的辅助方法</h2>
<p>在对<code>Result</code>的处理中，<code>match</code>可以胜任它的工作，不过他可能有点冗长并且不总是能很好的表明它的意图。<code>Result&lt;T,E&gt;</code>类型定义了很多辅助方法来处理各种情况。我们可以在Rust<a
target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/index.html">官方文档</a>中进行查阅。下面列举几个常用的函数。</p>
<h3 id="unwrap">unwrap</h3>
<p>使用<code>unwrap</code>方法处理<code>Result&lt;T,E&gt;</code>类型时，如果返回成功，就将<code>Ok(T)</code>中的值取出来，但是如果失败，就直接<code>panic!</code>：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="unwrap_or">unwrap_or</h3>
<p>与上面我们在<code>Option</code>中讲到的<code>unwrap_or()</code>类似，我们也可以使用<code>unwrap_or</code>，在返回失败时返回我们设置的默认信息。这里不再举例。</p>
<h3 id="expect">expect</h3>
<p><code>expect</code>跟<code>unwrap</code>很像，也是遇到错误直接<code>panic</code>,
但是会带上自定义的错误提示信息，相当于重载了错误打印的函数：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 报错如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;Failed to open hello.txt: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;, src/main.rs:4:37</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure></p>
<h3 id="map">map</h3>
<p><code>map</code>方法使得我们可以在两个<code>Result</code>类型之间进行相互转换：<code>Result&lt;T, E&gt;</code>
-&gt; <code>Result&lt;U, E&gt;</code>(只转换Ok值的类型)：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">line</span> = <span class="string">&quot;1\n2\n3\n4\n&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> line.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">match</span> num.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map</span>(|i| i*<span class="number">2</span>) &#123;     <span class="comment">//parse方法将字符串转换成i32</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;n&#125;&quot;</span>),      <span class="comment">//依次输出2, 4, 6, 8</span></span><br><span class="line">            <span class="title function_ invoke__">Err</span>(..) =&gt; &#123;&#125;,  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="map_err">map_err</h3>
<p><code>map_err</code>与我们上面介绍的<code>map</code>互补，它使得我们可以将：<code>Result&lt;T, E&gt;</code>转换为<code>Result&lt;T, F&gt;</code>:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">x</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">map_err</span>(|e: std::io::Error| <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123; <span class="built_in">format!</span>(<span class="string">&quot;&#123;e&#125;&quot;</span>) &#125;); <span class="comment">//将错误信息类型转换为String类型</span></span><br><span class="line">    <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(()),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="传播错误">传播错误</h2>
<p>咱们的程序几乎不太可能只有<code>A-&gt;B</code>形式的函数调用，在实际应用中，我们通常会把错误层层上传然后交给调用链的上游函数进行处理，错误传播将极为常见。</p>
<p>例如以下函数从文件中读取用户名，然后将结果进行返回：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 打开文件，f是`Result&lt;文件句柄,io::Error&gt;`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="comment">// 打开文件成功，将file句柄赋值给f</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="comment">// 打开文件失败，将错误返回(向上传播)</span></span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建动态字符串s</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="comment">// 从f文件句柄读取数据并写入s中</span></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="comment">// 读取成功，返回Ok封装的字符串</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="comment">// 将错误向上传播</span></span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="传播错误的简写运算符">传播错误的简写；<code>?</code>运算符</h2>
<p><code>?</code>运算符实际上就是一个宏，它的作用跟上面的<code>match</code>几乎一模一样：
对于<code>Result</code>来说：
·如果结果是<code>Ok(T)</code>，则把<code>T</code>赋值给一个变量
·如果结果是<code>Err(E)</code>，则直接返回该错误</p>
<p>对于<code>Option</code>来说：
·如果值是<code>Some(T)</code>，<code>Some(T)</code>中的值<code>T</code>便作为该表达式的返回值，同时函数继续
·如果值是<code>None</code>，此时<code>None</code>会从函数中提前返回</p>
<p>我们在使用<code>?</code>运算符后，下面的代码示例与上面的代码示例相同：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而实际上，<code>?</code>还能实现链式调用，<code>File::open</code>遇到错误就返回，没有错误就将<code>Ok</code>中的值取出来用于下一个方法调用:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> ## 转换错误类型
想象一下，一个设计良好的系统中，肯定有自定义的错误特征，错误之间很可能会存在上下级关系，例如标准库中的<code>std::io::Error</code>和<code>std::error::Error</code>，前者是<code>IO</code>相关的错误结构体，后者是一个最最通用的标准错误特征，同时前者实现了后者，因此<code>std::io::Error</code>可以转换为<code>std:error::Error</code>。
明白了以上的错误转换，?
的更胜一筹就很好理解了，它可以自动进行类型提升（转换）： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">open_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;File, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面代码中<code>File::open</code>报错时返回的错误是<code>std::io::Error</code>类型，但是<code>open_file</code>函数返回的错误类型是<code>std::error::Error</code>的特征对象，可以看到一个错误类型通过<code>?</code>返回后，变成了另一个错误类型，这就是<code>?</code>的神奇之处。</p>
<p>根本原因是在于标准库中定义的<code>From</code>特征，该特征有一个方法<code>from</code>，用于把一个类型转成另外一个类型，<code>?</code>可以自动调用该方法，然后进行隐式类型转换。因此只要函数返回的错误<code>ReturnError</code>实现了
<code>From&lt;OtherError&gt;</code>特征，那么<code>?</code>就会自动把<code>OtherError</code>转换为<code>ReturnError</code>。</p>
<p>这种转换非常好用，意味着你可以用一个大而全的<code>ReturnError</code>来覆盖所有错误类型，只需要为各种子错误类型实现这种转换即可。</p>
<p>同时，我们也可以使用我们在上面所提到的<code>map_err</code>来手动的修改返回的错误值的类型；
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">x</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">map_err</span>(|e| <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123; <span class="built_in">format!</span>(<span class="string">&quot;&#123;e&#125;&quot;</span>) &#125;)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用时常见的错误">使用?时常见的错误</h2>
<p>初学者在使用<code>?</code>是，经常容易出现错误，比如写出如下的代码：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first</span>(arr: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">   arr.<span class="title function_ invoke__">get</span>(<span class="number">0</span>)?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码无法通过编译，切记<code>?</code>操作符需要一个变量来承载正确的值，这个函数只会返回<code>Some(&amp;i32)</code>或者<code>None</code>，只有错误值能直接返回，正确的值不行，所以如果数组中存在<code>0</code>号元素，那么函数第二行使用<code>?</code>后的返回类型为<code>&amp;i32</code>而不是<code>Some(&amp;i32)</code>。因此<code>?</code>只能用于以下形式：
<code>let v = xxx()?;</code> <code>xxx()?.yyy()?;</code></p>
<p>我们需要修改上述代码： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first</span>(arr: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span> = arr.<span class="title function_ invoke__">get</span>(<span class="number">0</span>)?;</span><br><span class="line">   <span class="title function_ invoke__">Some</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="option和result的相互转换">Option和Result的相互转换</h2>
<p>在枚举那节的笔记中就有详细介绍，这里不再赘述。</p>
<h2 id="课后习题">课后习题</h2>
<p><img src="/images/14-10.png" alt="" width="1000"></p>
<p>修改后的代码如下： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修复calL函数的错误</span></span><br><span class="line"><span class="comment">//当b为None时，按默认值1</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">divide</span>(a,b).<span class="title function_ invoke__">unwrap_or</span>(<span class="number">1</span>);   <span class="comment">//使用unwrap_or()方法设定默认值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">sqrt</span>(r).<span class="title function_ invoke__">map_err</span>(|e| <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123; <span class="built_in">format!</span>(<span class="string">&quot;&#123;e&#125;&quot;</span>) &#125;)?;  <span class="comment">//使用map_err方法转换错误的类型，并使用？传播错误</span></span><br><span class="line">    <span class="title function_ invoke__">OK</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="number">0</span>ption&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b !=<span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(a <span class="keyword">as</span> <span class="type">f64</span> / b <span class="keyword">as</span> <span class="type">f64</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">MathError</span> &#123;</span><br><span class="line">    DivisionByZero,</span><br><span class="line">    NegativeSquareRoot,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sqrt</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, MathError&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> x&lt;<span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MathError::NegativeSquareRoot)</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(x.<span class="title function_ invoke__">sqrt</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/22/rust-collections/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/22/rust-collections/" class="post-title-link" itemprop="url">十三、Rust基础-常见集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-22 03:09:47" itemprop="dateCreated datePublished" datetime="2024-10-22T03:09:47+08:00">2024-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-24 05:47:42" itemprop="dateModified" datetime="2024-10-24T05:47:42+08:00">2024-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常见集合">常见集合</h1>
<p>集合类型在Rust中是一类比较特殊的类型，因为 Rust
中大多数数据类型都只能代表一个特定的值，但是集合却可以代表一大堆值。而且与语言级别的数组、字符串类型不同，标准库里的这些家伙是分配在堆上，因此都可以进行动态的增加和减少。标准库中最最常用的集合类型有：<code>Vector</code>、<code>HashNap</code>、<code>String</code>。</p>
<h1 id="vector">Vector</h1>
<p><code>Vec</code>是一个动态数组，可以根据需要动态增长和缩小。适用于需要按顺序存储数据的场景。</p>
<h3 id="创建和初始化">创建和初始化</h3>
<p>在Rust中，有多种方式可以创建动态数组。</p>
<p>我们可以使用<code>Vec::new</code>来创建动态数组： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>
也可以通过宏<code>vec!</code>来创建数组，同时，使用<code>vec!</code>创建数组时还可以在创建的同时给予初始化的值：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<h3 id="添加元素">添加元素</h3>
<p>当我们想要向数组的尾部添加元素时，我们可以使用<code>push</code>的方法：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
与其它类型一样，必须将<code>v</code>声明为<code>mut</code>后，才能进行修改。</p>
<h3 id="访问元素">访问元素</h3>
<p>从<code>vec</code>中读取指定位置的元素有两种方法可以选择：
·通过下标索引访问 ·通过<code>get</code>方法访问</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The is no third element&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，通过<code>get()</code>方法访问时返回的是<code>Option</code>类型，在索引处有值时返回<code>Some(T)</code>，在数组越界访问时返回<code>None</code>。这是一种相对安全的访问方法，相反，通过下标索引进行访问时，如果出现越界访问，程序会直接<code>panic!</code>.</p>
<h3 id="修改元素">修改元素</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">v[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>);   <span class="comment">// The third element is 10</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历元素">遍历元素</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;       <span class="comment">//推荐使用向量的引用，否则所有权会发生转移</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们可以在迭代过程中，修改<code>v</code>中的元素：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用枚举存储多种类型">使用枚举存储多种类型</h2>
<p><code>Vec</code>中的元素必须类型相同，但我们也可以通过使用枚举类型和特征对象来实现不同类型元素的存储:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V10</span>(<span class="type">i32</span>),   <span class="comment">//随便加的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        IpAddr::<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        IpAddr::<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::1&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        IpAddr::<span class="title function_ invoke__">V10</span>(<span class="number">32</span>)</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ip</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        <span class="title function_ invoke__">show_addr</span>(ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show_addr</span>(ip: IpAddr) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过特征对象实现不同类型元素的存储老师没讲，具体请参照：<a
target="_blank" rel="noopener" href="https://course.rs/basic/collections/vector.html">Rust语言圣经</a></p>
<h2 id="容量与重新分配">容量与重新分配</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">10</span>);     <span class="comment">//创建一个容量为10的数组</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Capacity is: &#123;&#125;&quot;</span>, v.<span class="title function_ invoke__">capacity</span>());  <span class="comment">// Capacity is 10</span></span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Capacity is: &#123;&#125;&quot;</span>, v.<span class="title function_ invoke__">capacity</span>());  <span class="comment">// Capacity is 10, push容量不会扩容，避免内存重新分配</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;value is &#123;:?&#125;&quot;</span>, v);   <span class="comment">//value is [1]  </span></span><br></pre></td></tr></table></figure>
<h2 id="常见陷阱">常见陷阱</h2>
<p>· <strong>不安全的索引访问</strong>
如上所述，直接通过索引对数组进行访问，一旦越界就会直接报错<code>panic!</code>。因此，推荐使用<code>get()</code>方法对数组进行访问，或者在通过索引进行访问前确认所访问的索引未越界（一般通过<code>if</code>）.</p>
<p>· <strong>可变引用与不可变引用的混用</strong> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);  <span class="comment">//可变引用</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The first element is &#123;&#125;&quot;</span>, first);     <span class="comment">//此时会报错，因为Rust不允许可变引用和不可变引用同时存在</span></span><br></pre></td></tr></table></figure></p>
<h1 id="hashmap">HashMap</h1>
<p>和动态数组一样，<code>HashMap</code>也是Rust标准库中提供的集合类型，但是又与动态数组不同，<code>HashMap</code>中存储的是一一映射的<code>KV</code>键值对，并提供了平均复杂度为<code>O(1)</code>的查询方法，当我们希望通过一个<code>Key</code>去查询值时，该类型非常有用，以致于
Go 语言将该类型设置成了语言级别的内置特性。</p>
<p>Rust 中哈希类型（哈希映射）为<code>HashMap&lt;K,V&gt;</code>。</p>
<h3 id="创建和初始化-1">创建和初始化</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;string, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);    <span class="comment">// 插入元素</span></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>从上面的例子中，我们需要注意：在使用<code>HashMap</code>类型时需要手动通过<code>use ...</code>来从标准库中引入到我们当前的作用域中，因为<code>HashMap</code>并没有包含在Rust的<code>prelude</code>中。
同时，跟其它集合类型一致，<code>HashMap</code>也是内聚性的，即所有的<code>K</code>必须拥有同样的类型，<code>V</code>也是如此。</p>
<h3 id="访问元素-1">访问元素</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;string, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);    <span class="comment">// 插入元素</span></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);     <span class="comment">//使用get方法进行访问，返回Option类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> score &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The &#123;&#125; score is &#123;&#125;&quot;</span>, team_name, s),</span><br><span class="line">    <span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历元素-1">遍历元素</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;string, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);    </span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (team, score) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The &#123;&#125; score is &#123;&#125;&quot;</span>, team_name, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新哈希表">更新哈希表</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;string, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);    </span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);       <span class="comment">//&#123;&quot;Blue&quot;: 10, &quot;Yellow&quot;: 25&#125;</span></span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name); </span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> score &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; score is &#123;&#125;&quot;</span>, team_name, s), <span class="comment">// Blue score is 25</span></span><br><span class="line">    <span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">entry</span> = scores.<span class="title function_ invoke__">entry</span>(<span class="string">&quot;Red&quot;</span>).<span class="title function_ invoke__">or_insert</span>(<span class="number">5</span>);    <span class="comment">// entry方法，查询Yellow对应的值，如果不存在则插入新值</span></span><br><span class="line">*entry += <span class="number">10</span>;   <span class="comment">//说明or_insert返回了&amp;mut entry引用，因此可以通过该可变引用直接修改 map 中对应的值</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码示例中，我们可以发现<code>insert</code>不仅可以插入新值，还可以覆盖原有的值。
同时，我们还可以发现<code>entry</code>可以查询HashMap中的键，如果其下没有值，则插入新值。</p>
<h2 id="合并哈希表">合并哈希表</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map1.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map1.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map2</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map2.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;b&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map2.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;c&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k,v) <span class="keyword">in</span> map2 &#123;  <span class="comment">//HashMap的遍历是无序的</span></span><br><span class="line">    map1.<span class="title function_ invoke__">insert</span>(k,v);   <span class="comment">//map2的b值3覆盖map1的b</span></span><br><span class="line">    map1.<span class="title function_ invoke__">entry</span>(k).<span class="title function_ invoke__">or_insert</span>(v);     <span class="comment">//与上面相反</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希冲突">哈希冲突</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use::std::collections::HashMap;</span><br><span class="line">use::std::collections::hash_map::DefaultHasher;</span><br><span class="line">use::std::hash::&#123;Hash,Hasher&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_hash</span>&lt;t: &amp;T&gt; <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = DefaultHasher::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    t.<span class="title function_ invoke__">hash</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">    s.<span class="title function_ invoke__">finish</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Key1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Key2&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hash of key1:&#123;&#125;, hash of key2:&#123;&#125;&quot;</span>, <span class="title function_ invoke__">calculate_hash</span>(&amp;key1), <span class="title function_ invoke__">calculate_hash</span>(&amp;key2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面，我们构建了函数是的我们可以查看对应<code>key</code>的哈希值。我们在编程中需要尽量避免哈希冲突</p>
<h2 id="值的所有权问题">值的所有权问题</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">field_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(field_name, field_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时field_name和field_value的所有权已经发生转移</span></span><br></pre></td></tr></table></figure>
<h2 id="课后习题">课后习题</h2>
<p><img src="/images/13-1.png" alt="" width="1000"></p>
<p>练习1: <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;T&gt; &#123;</span><br><span class="line">    elements: vec&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Stack&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        Stack &#123;</span><br><span class="line">            elements: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, item: T) &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements.<span class="title function_ invoke__">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">pop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements.<span class="title function_ invoke__">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">peek</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements.<span class="title function_ invoke__">last</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = Stack::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Top element is: &#123;:?&#125;&quot;</span>, stack.<span class="title function_ invoke__">peek</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Popped element: &#123;:?&#125;&quot;</span>, stack.<span class="title function_ invoke__">pop</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Top element is: &#123;:?&#125;&quot;</span>, stack.<span class="title function_ invoke__">peek</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>练习2: <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">word_frequency_counter</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> HashMap&lt;<span class="type">String</span>, <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">frequencies</span> = HashMap::<span class="title function_ invoke__">new</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历文本，将其按空格或标点符号分割成单词</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cleaned_word</span> = word</span><br><span class="line">            .<span class="title function_ invoke__">trim_matches</span>(|c: <span class="type">char</span>| !c.<span class="title function_ invoke__">is_alphabetic</span>())</span><br><span class="line">            .<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !cleaned_word.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            *frequencies.<span class="title function_ invoke__">entry</span>(cleaned_word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>) += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frequencies</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;On a quiet night, the city lights reflected on the rippling river, and the distant sound of a bell echoed softly. Eileen stood by the bridge, pondering her upcoming journey. Her backpack was filled with maps, a compass, and an unsent letter. She had rewritten the letter countless times but had never mustered the courage to deliver it to that person.&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word_frequencies</span> = <span class="title function_ invoke__">word_frequency_counter</span>(text);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (word, count) <span class="keyword">in</span> word_frequencies &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27;: &#123;&#125;&quot;</span>, word, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>练习3: <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    title: <span class="type">String</span>,</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    quantity: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Inventory</span> &#123;</span><br><span class="line">    books: HashMap&lt;<span class="type">String</span>, Book&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Inventory</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Inventory &#123;</span><br><span class="line">        Inventory &#123;</span><br><span class="line">            books: HashMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_book</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, title: <span class="type">String</span>, author: <span class="type">String</span>, quantity: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">book</span> = Book &#123;</span><br><span class="line">            title: title.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            author,</span><br><span class="line">            quantity,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">self</span>.books.<span class="title function_ invoke__">insert</span>(title, book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">query_inventory</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">book</span> <span class="keyword">in</span> <span class="keyword">self</span>.books.<span class="title function_ invoke__">values</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Title: &#123;&#125;, Author: &#123;&#125;, Quantity: &#123;&#125;&quot;</span>, book.title, book.author, book.quantity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update_quantity</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, title: &amp;<span class="type">str</span>, quantity: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(book) = <span class="keyword">self</span>.books.<span class="title function_ invoke__">get_mut</span>(title) &#123;</span><br><span class="line">            book.quantity = quantity;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Updated &#123;&#125; quantity to &#123;&#125;&quot;</span>, title, quantity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Book not found: &#123;&#125;&quot;</span>, title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">delete_book</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, title: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.books.<span class="title function_ invoke__">remove</span>(title).<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Deleted book: &#123;&#125;&quot;</span>, title);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Book not found: &#123;&#125;&quot;</span>, title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/22/rust-pattern-matching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wobujiaoxyy3">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/22/rust-pattern-matching/" class="post-title-link" itemprop="url">十二、Rust-模式匹配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-22 01:21:56" itemprop="dateCreated datePublished" datetime="2024-10-22T01:21:56+08:00">2024-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-24 03:56:54" itemprop="dateModified" datetime="2024-10-24T03:56:54+08:00">2024-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模式匹配">模式匹配</h1>
<p>模式匹配是一种强大的功能，可以检查拘束的结构并进行相应操作。同时，使用模式匹配可以提高代码的可读性和简洁性，减少错误，尤其是在处理复杂数据结构时。</p>
<h2 id="match表达式"><code>match</code>表达式</h2>
<p>让我们先来看一下 <code>match</code>表达式的通用形式：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> target &#123;</span><br><span class="line">    模式<span class="number">1</span> =&gt; 表达式<span class="number">1</span>,</span><br><span class="line">    模式<span class="number">2</span> =&gt; &#123;</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        表达式<span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    _ =&gt; 表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>match</code>允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行对应的代码，下面让我们来一一详解，先看一个例子：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">match</span> number &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One!&quot;</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Two!&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Other!&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
需要注意的，使用<code>match</code>进行模式匹配时必须遍历所有可能的值，在上述的例子中，我们使用通配符<code>_</code>来匹配<code>number</code>除了<code>1</code>和<code>2</code>的其他情况。</p>
<h3 id="字面值模式">字面值模式</h3>
<p>使用<code>match</code>匹配字面值： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> number &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One!&quot;</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Two!&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Other!&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> y &#123;</span><br><span class="line">    <span class="string">&quot;hello&quot;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Hello!&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Other!&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="变量模式">变量模式</h3>
<p>使用<code>match</code>匹配变量： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    var =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
需要注意的是，此时<code>x</code>的值实际上转移给了<code>var</code>中，只是示例中的<code>x</code>是<code>i32</code>类型，实现了<code>copy</code>特性。如果是<code>String</code>类型，则所有权已经发生了转移，之后不能使用：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    var =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);     <span class="comment">// 此时无法打印，因为所有权已经发生了转移</span></span><br></pre></td></tr></table></figure></p>
<h3 id="通配符模式">通配符模式</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Any Value!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构模式">结构模式</h3>
<p>下面的例子展示了如何使用<code>match</code>来解构结构体：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; x:<span class="type">i32</span>, y:<span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Point&#123; x:<span class="number">0</span>, y:<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">match</span> p &#123;</span><br><span class="line">    Point&#123; x, y:<span class="number">0</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>, x);</span><br><span class="line">    Point&#123; x:<span class="number">0</span>, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>, y);</span><br><span class="line">    Point&#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On neither axis: (&#123;&#125;,&#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="守卫和绑定">守卫和绑定</h3>
<p>· <strong>守卫</strong>：
在模式匹配中，可以使用守卫来添加额外的条件判断： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    n <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Even!&quot;</span>);</span><br><span class="line">    n =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Odd!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>·
<strong>绑定</strong>：在模式匹配中，可以使用绑定将模式中的值绑定到变量上：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello&#123; id:<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello&#123; id: var @ <span class="number">3</span>..<span class="number">7</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Found id in range, value: &#123;&#125;&quot;</span>, var);</span><br><span class="line">    Message::Hello&#123; id &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Found other id, value: &#123;&#125;&quot;</span>, var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上述代码中，最重要的就是符号<code>@</code>，它可以将匹配模式的范围进行值的绑定。</p>
<h2 id="匹配模式的应用场景">匹配模式的应用场景</h2>
<h3 id="处理错误">处理错误</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">divide</span>(<span class="number">4</span>,<span class="number">2</span>);    <span class="comment">//返回Result类型</span></span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The error is &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>,<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">From</span>(<span class="string">&quot;Cannot divide by zero&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a / b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，模式匹配还可以用于解析命令行参数、解析配置文件、解析数据包、解析XML或JSON等数据格式。</p>
<h2 id="高级技巧-嵌套模式">高级技巧-嵌套模式</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Say</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">MoveTo</span>(<span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColorRGB</span>(<span class="type">u16</span>, <span class="type">u16</span>, <span class="type">u16</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">actions</span> = [</span><br><span class="line">        Action::<span class="title function_ invoke__">Say</span>(<span class="string">&quot;Hello Rust&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        Action::<span class="title function_ invoke__">MoveTo</span>(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">        Action::<span class="title function_ invoke__">ChangeColorRGB</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">action</span> <span class="keyword">in</span> actions &#123;</span><br><span class="line">        <span class="keyword">match</span> action &#123;</span><br><span class="line">            Action::<span class="title function_ invoke__">Say</span>(s) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">            &#125;,</span><br><span class="line">            Action::<span class="title function_ invoke__">MoveTo</span>(x, y) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;point from (0, 0) move to (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">            &#125;,</span><br><span class="line">            Action::<span class="title function_ invoke__">ChangeColorRGB</span>(r, g, _) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;change color into &#x27;(r:&#123;&#125;, g:&#123;&#125;, b:0)&#x27;, &#x27;b&#x27; has been ignored&quot;</span>,</span><br><span class="line">                    r, g,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配模式与迭代器的结合">匹配模式与迭代器的结合</h2>
<p>在实战中，我们可以结合<code>iter</code>和<code>match</code>使用：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">vec2</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (a,b) <span class="keyword">in</span> vec1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(vec2) &#123;    <span class="comment">//zip()方法自行查阅文档，在提取(a,b）时用到了模式匹配</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, a, b , a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2
id="if-let和while-let"><code>if let</code>和<code>while let</code></h2>
<p>使用<code>if let</code>和<code>while let</code>可以简化单个模式匹配：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">opt</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = opt &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Value is &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_ invoke__">into_iter</span>();     <span class="comment">//迭代器类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;matched &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ref和ref-mut"><code>ref</code>和<code>ref mut</code></h2>
<p>在模式匹配中，如果我们不想所有权发生转移，则可以使用<code>ref</code>和<code>ref mut</code>关键字来借用数据而非转移所有权：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="keyword">ref</span> var =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);     <span class="comment">// 此时可以打印，因为只是借用，所有权并为发生转移</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="keyword">ref</span> var =&gt; &#123;</span><br><span class="line">        *var = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, x);     <span class="comment">// 此时可以打印，且字符串的值发生了变化</span></span><br></pre></td></tr></table></figure>
<h2 id="课后习题">课后习题</h2>
<p><img src="/images/12-1.png" alt="" width="1000"></p>
<p>解： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> serde_json::&#123;Value, json&#125;;</span><br><span class="line"><span class="keyword">use</span> serde_json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = json!(&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="number">30</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;alice@example.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;street&quot;</span>: <span class="string">&quot;123 Main St&quot;</span>,</span><br><span class="line">            <span class="string">&quot;city&quot;</span>: <span class="string">&quot;Wonderland&quot;</span> ,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;phone_numbers&quot;</span>: [<span class="string">&quot;123-456-7890&quot;</span>, <span class="string">&quot;987-654-3210&quot;</span>],</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(name) = data.<span class="title function_ invoke__">get</span>(<span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Value</span>::<span class="title function_ invoke__">String</span>(name_str) = name &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Name: &#123;&#125;&quot;</span>, name_str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(age) = data.<span class="title function_ invoke__">get</span>(<span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Value</span>::<span class="title function_ invoke__">Number</span>(age_num) = age &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Age: &#123;&#125;&quot;</span>, age_num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(address) = data.<span class="title function_ invoke__">get</span>(<span class="string">&quot;address&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Value</span>::<span class="title function_ invoke__">Object</span>(address_obj) = address &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(street) = address_obj.<span class="title function_ invoke__">get</span>(<span class="string">&quot;street&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Street: &#123;&#125;&quot;</span>, street);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(city) = address_obj.<span class="title function_ invoke__">get</span>(<span class="string">&quot;city&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;City: &#123;&#125;&quot;</span>, city);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(phone_numbers) = data.<span class="title function_ invoke__">get</span>(<span class="string">&quot;phone_numbers&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Value</span>::<span class="title function_ invoke__">Array</span>(numbers) = phone_numbers &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> numbers &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Value</span>::<span class="title function_ invoke__">String</span>(number_str) = number &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Phone number: &#123;&#125;&quot;</span>, number_str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
